//
// Function Name: vimNetworkSessionCiscoASA
// Description: This ASIM parser supports normalizing commonly used Cisco ASA messages collected using the CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoASA(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventResultMapping = datatable (Reason:string, DvcAction:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string)  [
    'Conn-timeout', '', 'Success', 'Timeout', 'The connection ended when a flow is closed because of the expiration of its inactivity timer.',
    'Deny Terminate', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by application inspection.',
    'Failover primary closed', '', 'Success', 'Failover', 'The standby unit in a failover pair deleted a connection because of a message received from the active unit.',
    'FIN Timeout', '', 'Success', 'Timeout', 'Force termination after 10 minutes awaiting the last ACK or after half-closed timeout.',  
    'Flow closed by inspection', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by the inspection feature.',
    'Flow terminated by IPS', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by IPS.',
    'Flow reset by IPS', 'Reset', 'Failure', 'Terminated', 'Flow was reset by IPS.',     
    'Flow terminated by TCP Intercept', 'TCP Intercept', 'Failure', 'Terminated', 'Flow was terminated by TCP Intercept.',
    'Flow timed out', '', 'Success', 'Timeout', 'Flow has timed out.',
    'Flow timed out with reset', 'Reset', 'Failure', 'Timeout', 'Flow has timed out, but was reset.',
    'Free the flow created as result of packet injection', '', 'Success', 'Simulation', 'The connection was built because the packet tracer feature sent a simulated packet through the Secure Firewall ASA.',
    'Invalid SYN', '', 'Failure', 'Invalid TCP', 'The SYN packet was not valid.',
    'IPS fail-close', 'Deny', 'Failure', 'Terminated', 'Flow was terminated because the IPS card is down.',
    'No interfaces associated with zone', '', 'Failure', 'Routing issue', 'Flows were torn down after the "no nameif" or "no zone-member" leaves a zone with no interface members.',
    'No valid adjacency', 'Drop', 'Failure', 'Routing issue', 'This counter is incremented when the Secure Firewall ASA tried to obtain an adjacency and could not obtain the MAC address for the next hop. The packet is dropped.',
    'Pinhole Timeout', '', 'Failure', 'Timeout', 'The counter is incremented to report that the Secure Firewall ASA opened a secondary flow, but no packets passed through this flow within the timeout interval, and so it was removed. An example of a secondary flow is the FTP data channel that is created after successful negotiation on the FTP control channel.',
    'Probe maximum retries of retransmission exceeded', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the TCP packet exceeded maximum probe retries of retransmission.',
    'Probe maximum retransmission time elapsed', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the maximum probing time for TCP packet had elapsed.',
    'Probe received RST', '', 'Failure', 'Reset', 'The connection was torn down because probe connection received RST from server.',
    'Probe received FIN', '', 'Success', '', 'The connection was torn down because probe connection received FIN from server and complete FIN closure process was completed.',
    'Probe completed', '', 'Success', '', 'The probe connection was successful.', 
    'Route change', '', 'Success', '', 'When the Secure Firewall ASA adds a lower cost (better metric) route, packets arriving that match the new route cause their existing connection to be torn down after the user-configured timeout (floating-conn) value. Subsequent packets rebuild the connection out of the interface with the better metric. To prevent the addition of lower cost routes from affecting active flows, you can set the floating-conn configuration timeout value to 0:0:0.', 
    'SYN Control', '', 'Failure', 'Invalid TCP', 'A back channel initiation occurred from the wrong side.',
    'SYN Timeout', '', 'Failure', 'Timeout', 'Force termination after 30 seconds, awaiting three-way handshake completion.',
    'TCP bad retransmission', '', 'Success', 'Invalid TCP', 'The connection was terminated because of a bad TCP retransmission.',
    'TCP FINs', '', 'Success', '', 'A normal close-down sequence occurred.',
    'TCP Invalid SYN', '', 'Failure', 'Invalid TCP', 'Invalid TCP SYN packet.',              
    'TCP Reset-APPLIANCE', '', 'Failure', 'Reset', 'The flow is closed when a TCP reset is generated by the Secure Firewall ASA.',
    'TCP Reset-I', '', 'Failure', 'Reset', 'Reset was from the inside.',
    'TCP Reset-O', '', 'Failure', 'Reset', 'Reset was from the outside.',
    'TCP segment partial overlap', '', 'Failure', 'Invalid TCP', 'A partially overlapping segment was detected.',
    'TCP unexpected window size variation', '', 'Failure', 'Invalid TCP', 'A connection was terminated due to variation in the TCP window size.',  
    'Tunnel has been torn down', '', 'Failure', 'Invalid Tunnel', 'Flow was terminated because the tunnel is down.',
    'Unknown', 'Deny', 'Failure', 'Terminated', 'An authorization was denied by a URL filter.', 'Unauth Deny', '', 'Failure', 'Unknown', 'An unknown error has occurred.',               
    'Xlate Clear', '', '', '', 'A command line was removed.',
];
let ProtocolLookup=datatable(Protocol:string,NetworkProtocol:string)[
      "0","HOPOPT"
      , "1","ICMP"
      , "2","IGMP"
      , "3","GGP"
      , "4","IPv4"
      , "5","ST"
      , "6","TCP"
      , "7","CBT"
      , "8","EGP"
      , "9","IGP"
      , "10","BBN-RCC-MON"
      , "11","NVP-II"
      , "12","PUP"
      , "13","ARGUS (deprecated)"
      , "14","EMCON"
      , "15","XNET"
      , "16","CHAOS"
      , "17","UDP"
      , "18","MUX"
      , "19","DCN-MEAS"
      , "20","HMP"
      , "21","PRM"
      , "22","XNS-IDP"
      , "23","TRUNK-1"
      , "24","TRUNK-2"
      , "25","LEAF-1"
      , "26","LEAF-2"
      , "27","RDP"
      , "28","IRTP"
      , "29","ISO-TP4"
      , "30","NETBLT"
      , "31","MFE-NSP"
      , "32","MERIT-INP"
      , "33","DCCP"
      , "34","3PC"
      , "35","IDPR"
      , "36","XTP"
      , "37","DDP"
      , "38","IDPR-CMTP"
      , "39","TP++"
      , "40","IL"
      , "41","IPv6"
      , "42","SDRP"
      , "43","IPv6-Route"
      , "44","IPv6-Frag"
      , "45","IDRP"
      , "46","RSVP"
      , "47","GRE"
      , "48","DSR"
      , "49","BNA"
      , "50","ESP"
      , "51","AH"
      , "52","I-NLSP"
      , "53","SWIPE (deprecated)"
      , "54","NARP"
      , "55","MOBILE"
      , "56","TLSP"
      , "57","SKIP"
      , "58","IPv6-ICMP"
      , "59","IPv6-NoNxt"
      , "60","IPv6-Opts"
      , "61",""
      , "62","CFTP"
      , "63",""
      , "64","SAT-EXPAK"
      , "65","KRYPTOLAN"
      , "66","RVD"
      , "67","IPPC"
      , "68",""
      , "69","SAT-MON"
      , "70","VISA"
      , "71","IPCV"
      , "72","CPNX"
      , "73","CPHB"
      , "74","WSN"
      , "75","PVP"
      , "76","BR-SAT-MON"
      , "77","SUN-ND"
      , "78","WB-MON"
      , "79","WB-EXPAK"
      , "80","ISO-IP"
      , "81","VMTP"
      , "82","SECURE-VMTP"
      , "83","VINES"
      , "84","TTP"
      , "84","IPTM"
      , "85","NSFNET-IGP"
      , "86","DGP"
      , "87","TCF"
      , "88","EIGRP"
      , "89","OSPFIGP"
      , "90","Sprite-RPC"
      , "91","LARP"
      , "92","MTP"
      , "93","AX.25"
      , "94","IPIP"
      , "95","MICP (deprecated)"
      , "96","SCC-SP"
      , "97","ETHERIP"
      , "98","ENCAP"
      , "99",""
      , "100","GMTP"
      , "101","IFMP"
      , "102","PNNI"
      , "103","PIM"
      , "104","ARIS"
      , "105","SCPS"
      , "106","QNX"
      , "107","A/N"
      , "108","IPComp"
      , "109","SNP"
      , "110","Compaq-Peer"
      , "111","IPX-in-IP"
      , "112","VRRP"
      , "113","PGM"
      , "114",""
      , "115","L2TP"
      , "116","DDX"
      , "117","IATP"
      , "118","STP"
      , "119","SRP"
      , "120","UTI"
      , "121","SMP"
      , "122","SM (deprecated)"
      , "123","PTP"
      , "124","ISIS over IPv4"
      , "125","FIRE"
      , "126","CRTP"
      , "127","CRUDP"
      , "128","SSCOPMCE"
      , "129","IPLT"
      , "130","SPS"
      , "131","PIPE"
      , "132","SCTP"
      , "133","FC"
      , "134","RSVP-E2E-IGNORE"
      , "135","Mobility Header"
      , "136","UDPLite"
      , "137","MPLS-in-IP"
      , "138","manet"
      , "139","HIP"
      , "140","Shim6"
      , "141","WESP"
      , "142","ROHC"
      , "143","Ethernet"
      , "253",""
      , "254",""
      , "255","Reserved"
  ];
  let ActionResultLookup = datatable (DeviceEventClassID:string, DvcAction:string, EventResult:string)[
        "106001", "Deny", "Failure",
        "106002", "Deny", "Failure",
        "106006", "Deny", "Failure",
        "106007", "Deny", "Failure",
        "106010", "Deny", "Failure",
        "106012", "Deny", "Failure",
        "106013", "Drop", "Failure",
        "106014", "Deny", "Failure",
        "106015", "Deny", "Failure",
        "106016", "Deny", "Failure",
        "106017", "Deny", "Failure",
        "106018", "Deny", "Failure",
        "106020", "Deny", "Failure",
        "106021", "Deny", "Failure",
        "106022", "Deny", "Failure",
        "106023", "Deny", "Failure",
        "106100", "", "",
        "302013", "Allow", "Success",
        "302014", "", "", 
        "302015", "Allow", "Success",
        "302016", "Allow", "Success",
        "302020", "Allow", "Success",
        "302021", "Allow", "Success",
        "710002", "Allow", "Success",
        "710003", "Deny", "Failure",
        "710004", "Drop", "Failure",
        "710005", "Drop", "Failure",
  ];
  let NWParser = (
        starttime:datetime=datetime(null), 
        endtime:datetime=datetime(null),
        srcipaddr_has_any_prefix:dynamic=dynamic([]), 
        dstipaddr_has_any_prefix:dynamic=dynamic([]), 
        ipaddr_has_any_prefix:dynamic=dynamic([]),
        dstportnumber:int=int(null), 
        hostname_has_any:dynamic=dynamic([]), 
        dvcaction:dynamic=dynamic([]), 
        eventresult:string='*', 
        disabled:bool=false)
    { 
  let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let allLogs = CommonSecurityLog
            | where not(disabled)
            | where (isnull(starttime) or TimeGenerated >= starttime) and (isnull(endtime) or TimeGenerated <= endtime)
            | where DeviceVendor == "Cisco" and DeviceProduct == "ASA"
            | where DeviceEventClassID in ("106001","106006","106015","106016","106021","106022","106010","106014","106018","106023","302013","302015","302014","302016","302020","302021","710002","710003","710004","710005","106007","106017","106100","106002","106012","106013","106020")
            | lookup ActionResultLookup on DeviceEventClassID
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction) or DvcAction == "")
            | where ((eventresult == "*") or EventResult == eventresult or EventResult == "")
            | project DeviceVendor, DeviceProduct, DeviceEventClassID, LogSeverity, OriginalLogSeverity, Computer, CommunicationDirection, DestinationIP, DestinationPort, DeviceAddress, DeviceName, Message, Protocol, SourceIP, SourcePort, DeviceVersion, DeviceCustomString2, DvcAction, EventResult, TimeGenerated, DeviceAction;
  let parsedData = allLogs
            | where isnotempty(SourceIP)
            | where (isnull(dstportnumber) or (DestinationPort == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | project-rename NetworkRuleName = DeviceCustomString2,
                             SrcIpAddr = SourceIP,
                             SrcPortNumber = SourcePort,
                             DstIpAddr = DestinationIP, 
                             DstPortNumber = DestinationPort;
  let unparsedData = allLogs
            | where isempty(SourceIP)
            | where Message has tostring(dstportnumber)
                    and ((array_length(src_or_any) == 0 or has_any_ipv4_prefix(Message,src_or_any)) 
                        or (array_length(dst_or_any) == 0 or has_any_ipv4_prefix(Message,dst_or_any)))
            | project DeviceVendor, DeviceProduct, DeviceEventClassID, LogSeverity, OriginalLogSeverity, Computer, DeviceAddress, DeviceName, Message, DeviceVersion, Protocol, DvcAction, EventResult, TimeGenerated, DeviceAction;
  let all_106001_alike = parsedData
            | where DeviceEventClassID in ("106001", "106006", "106015", "106016", "106021", "106022") 
            | parse Message with * " interface " DstInterfaceName;
  let all_106010_alike = parsedData
            | where DeviceEventClassID in ("106010", "106014")
            | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")";
  let all_106018 = parsedData
            | where DeviceEventClassID == "106018"
            | parse Message with * " packet type " NetworkIcmpType " " * "list " NetworkRuleName " " *;
  let all_106023 = parsedData
            | where DeviceEventClassID == "106023" and not(Message has "protocol 41")
            | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * ' by access-group "' NetworkRuleName '" '  *
            | parse Message with * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")" *;
  let all_106023_unparsed = unparsedData
            | where DeviceEventClassID == "106023" and not(Message has "protocol 41")
            | parse Message with * ":" DeviceAction " " Protocol " src " SrcInterfaceName ":" SrcIpAddrAndPort "(" SrcUsername ") dst " DstInterfaceName ":" DstIpAddrAndPort " " NetworkIcmpInfo 'by access-group "' NetworkRuleName '" [' * "]"
            | parse NetworkIcmpInfo with "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ") "
            | extend SrcIpAddrAndPort = split(SrcIpAddrAndPort,"/"), DstIpAddrAndPort = split(DstIpAddrAndPort,"/")
            | extend SrcIpAddr = tostring(SrcIpAddrAndPort[0]),
                    SrcPortNumber = toint(SrcIpAddrAndPort[1]),
                    DstIpAddr = tostring(DstIpAddrAndPort[0]),
                    DstPortNumber = toint(DstIpAddrAndPort[1])
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | project-away SrcIpAddrAndPort, DstIpAddrAndPort, NetworkIcmpInfo;
  let all_106023_41 = unparsedData
            | where DeviceEventClassID == "106023" and Message has "protocol 41"
            | parse Message with * ":" DeviceAction " " ProtocolFromLog " src " SrcInterfaceName ":" SrcIpAddr " dst " DstInterfaceName ":" DstIpAddr ' by access-group ' NetworkRuleName ' '  *
            | parse Message with * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")" *
            | extend Protocol = case(isnotempty(Protocol), Protocol,
                                    ProtocolFromLog endswith "41", "41",
                                    ""),
                    NetworkRuleName = trim_start(@"\s*",NetworkRuleName)
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | project-away ProtocolFromLog;
  let all_302013_302015_parsed = parsedData
            | where DeviceEventClassID in ("302013","302015")
            | parse Message with * ":" * " " * " " * " connection " NetworkSessionId " for " SrcInterfaceName ":" * "/" * " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" * "/" * " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
            | extend SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                    DstUsername = trim(@"\s?\(?\)?\s?", DstUsername),
                    SessionId = NetworkSessionId,
                    EventSubType = "Start";
  let all_302013_302015_unparsed = unparsedData
            | where DeviceEventClassID in ("302013","302015")
            | parse Message with * ":" DeviceAction " " NetworkDirection " " Protocol " connection " NetworkSessionId " for " SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | extend SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                    DstUsername = trim(@"\s?\(?\)?\s?", DstUsername),
                    NetworkDirection = case(NetworkDirection == "inbound", "Inbound",
                                                NetworkDirection == "outbound", "Outbound",
                                                ""),
                    SessionId = NetworkSessionId,
                    EventSubType = "Start"; 
  let all_302014_unparsed = unparsedData
            | where DeviceEventClassID == "302014"
            | project-away DvcAction, EventResult
            | parse Message with * ":" DeviceAction " " Protocol " connection " NetworkSessionId " for " SrcInfoString " to " DstInfoString " duration " NetworkDuration " bytes " NetworkBytes:long *
            // SrcInfoString is extracted from the Message and not the direct values of IP, Port, Interface and User because Username is optional here
            | parse kind=regex SrcInfoString with SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int @"\(?\s?" SrcUsername @"\)?\s?"
            // DstInfoString is extracted from the Message and not the direct values of IP, Port, Interface and User because Username is optional here
            | parse kind=regex DstInfoString with DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int @"\(?\s?" DstUsername @"\)?\s?"
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            // Remaining string can have multiple formats. Mapping of all of them is as follows:
            // 1. empty --> no mapping required, RemainingString will be empty                
            | parse Message with * " bytes " * " " RemainingString
            // 2. (domain\USER001) 3. TCP FINs from OUTSIDE (domain\USER001) 4. TCP FINs (domain\USER001) --> DstUsernameSimple will now contain the value of the Destination Username
            | parse RemainingString with ReasonString "(" DstUsernameSimple ")"
            // Now to cover case #3 and 5. TCP FINs from OUTSIDE, adding check for the word "from" 
            | extend ReasonString = case(RemainingString has "from" and RemainingString !has "(", RemainingString,
                                         ReasonString)
            // Finally extract the required Reason information from the string to be utilized later
            | parse ReasonString with Reason " from " *
            | extend Reason = case(isempty(Reason), ReasonString,
                                   Reason)
            | lookup EventResultMapping on Reason
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | extend 
                        SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                        DstUsername = case(isempty(DstUsername),DstUsernameSimple,
                                           trim(@"\s?\(?\)?\s?", DstUsername)),
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End",
                        EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
            | project-away DstUsernameSimple, *String, Reason;
  let all_302014_parsed = parsedData
            | where DeviceEventClassID == "302014"
            | project-away DvcAction, EventResult
            | parse Message with * " connection " NetworkSessionId " for " SrcInterfaceName ":" * " to " DstInterfaceName ":" * " duration " NetworkDuration " bytes " NetworkBytes:long *
            | parse Message with * " bytes " * " " ReasonString
            | parse ReasonString with Reason " from " *
            | extend Reason = case(isempty(Reason), ReasonString,
                                   Reason)
            | lookup EventResultMapping on Reason
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | extend 
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End",
                        EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
            | project-away Reason, ReasonString;
  let all_302016_parsed = parsedData
            | where DeviceEventClassID  == "302016"
            | parse Message with * " connection " NetworkSessionId " for " SrcInterfaceName ":" * " to " DstInterfaceName ":" * " duration " NetworkDuration " bytes " NetworkBytes:long *
            | extend NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                     SessionId = NetworkSessionId,
                     EventSubType = "End";
  let all_302016_unparsed = unparsedData
            | where DeviceEventClassID  == "302016"
            | parse Message with * ":" DeviceAction " " Protocol " connection " NetworkSessionId " for " SrcInfoString " to " DstInfoString " duration " NetworkDuration " bytes " NetworkBytes:long *
            | parse kind=regex SrcInfoString with SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int @"\(?\s?" SrcUsername @"\)?\s?"
            | parse kind=regex DstInfoString with DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int @"\(?\s?" DstUsername @"\)?\s?"
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | parse Message with * " bytes " * " (" DstUsernameSimple ")"
            | extend 
                        SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                        DstUsername = case(isempty(DstUsername),DstUsernameSimple,
                                           trim(@"\s?\(?\)?\s?", DstUsername)),
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End"
            | project-away DstUsernameSimple, *InfoString;
  let all_302020_302021 = parsedData
            | where DeviceEventClassID in ("302020","302021")
            | parse Message with * "(" SrcUsername ")" *
            | parse Message with * "type " NetworkIcmpType " code " NetworkIcmpCode:int *
            | extend SrcUsernameType = iif(isnotempty(SrcUsername),"Windows",""),
                        EventSubType = case(DeviceEventClassID == "302020", "Start",
                                            "End");
  let all_7_series = parsedData
            | where DeviceEventClassID in ("710002","710003","710004","710005")
            | parse Message with * " to " DstInterfaceName ":" *;
  let all_106007 = parsedData
            | where DeviceEventClassID == "106007"
            | extend DstAppName = "DNS"
            | parse Message with * " due to " EventOriginalResultDetails;
  let all_106017 = parsedData
            | where DeviceEventClassID == "106017"
            | extend ThreatName = "Land Attack";
  let all_106100_parsed = parsedData
            | where DeviceEventClassID == "106100" and isnotempty(SrcIpAddr)
            | extend DvcAction = case(Message has "denied", "Deny",
                                      "Allow")
            | extend EventResult = case(DvcAction == "Deny", "Failure",
                                        "Success")
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | parse Message with * "access-list " * " " * " " * " " SrcInterfaceName "/" * ") -> " DstInterfaceName "/" * ") hit-cnt " EventCount:int *;
  let all_106100_unparsed = unparsedData
            | where DeviceEventClassID == "106100"
            | extend DvcAction = case(Message has "denied", "Deny",
                                      "Allow")
            | extend EventResult = case(DvcAction == "Deny", "Failure",
                                        "Success")
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | parse Message with * "access-list " NetworkRuleName " " DeviceAction " " Protocol " " SrcInterfaceName "/" SrcIpAddr "(" SrcPortNumber:int ") -> " DstInterfaceName "/" DstIpAddr "(" DstPortNumber:int ") hit-cnt " EventCount:int * 
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match";
  let remainingLogs = parsedData
            | where DeviceEventClassID in ("106002", "106012", "106013", "106020");
  let networkaddressWatchlistData = materialize (_ASIM_GetWatchlistRaw("NetworkAddresses"));
  let internalInterface = networkaddressWatchlistData | where WatchlistItem.Tags has "Internal" | distinct tostring(WatchlistItem["Range Name"]);
  let externalInterface = networkaddressWatchlistData | where WatchlistItem.Tags has "External" | distinct tostring(WatchlistItem["Range Name"]);
  union isfuzzy=false all_106001_alike, all_106010_alike, all_106018, all_106023, all_106023_unparsed, all_106023_41,  all_302013_302015_unparsed, all_302013_302015_parsed, all_302014_parsed, all_302014_unparsed, all_302016_parsed, all_302016_unparsed, all_302020_302021, all_7_series, all_106007, all_106017, all_106100_parsed, all_106100_unparsed, remainingLogs
            | extend 
                    EventStartTime = TimeGenerated,
                    EventEndTime = TimeGenerated,
                    EventVendor = "Cisco",
                    EventProduct = "ASA",
                    EventCount = coalesce(EventCount,toint(1)),
                    EventType = "NetworkSession",
                    EventSchema = "NetworkSession",
                    EventSchemaVersion = "0.2.4",
                    SrcInterfaceName = tolower(SrcInterfaceName),
                    DstInterfaceName = tolower(SrcInterfaceName)
            | extend 
                    SrcUsernameType = case(isnotempty(SrcUsername) and SrcUsername has "@", "UPN",
                                           isnotempty(SrcUsername) and SrcUsername !has "@" and SrcUsername has "\\", "Windows",
                                           isnotempty(SrcUsername), "Simple",
                                           ""),
                    DstUsernameType = case(isnotempty(DstUsername) and DstUsername has "@", "UPN",
                                           isnotempty(DstUsername) and DstUsername !has "@" and DstUsername has "\\", "Windows",
                                           isnotempty(DstUsername), "Simple",
                                           "")
            | lookup ProtocolLookup on Protocol
            | project-rename 
                    EventProductVersion = DeviceVersion,
                    EventOriginalType = DeviceEventClassID,
                    EventOriginalSeverity = OriginalLogSeverity,
                    DvcOriginalAction = DeviceAction,
                    EventMessage = Message,
                    Dvc = Computer
            | extend
                    EventSeverity = iff(isempty(EventResult) or EventResult == "Success", "Informational", "Low"),
                    NetworkDirection = case(isnotempty(CommunicationDirection), CommunicationDirection,
                                SrcInterfaceName in (internalInterface) and DstInterfaceName in (internalInterface), "Local",
                                SrcInterfaceName in (externalInterface) and DstInterfaceName in (externalInterface), "External",
                                DstInterfaceName in (externalInterface), "Outbound",
                                SrcInterfaceName in (externalInterface), "Inbound",
                                ""),
                    NetworkProtocol = case(isempty(NetworkProtocol) and isnotempty(Protocol), toupper(Protocol),
                                            NetworkProtocol)
            | extend 
                    Src = SrcIpAddr,
                    Dst = DstIpAddr,
                    Duration = NetworkDuration,
                    IpAddr = SrcIpAddr,
                    Rule = NetworkRuleName,
                    User = DstUsername
            | project-away CommunicationDirection, LogSeverity, Protocol, temp_*, Device*
            };
  NWParser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionCiscoFirepower
// Description: This ASIM parser supports normalizing commonly used Cisco Firepower messages collected using the CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoFirepower(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ActionLookup = datatable(
    DeviceAction: string,
    DvcAction: string,
    EventResult: string
)
[
    "Blocked", "Deny", "Failure",
    "Alerted", "Allow", "Success",
    "Rewritten", "Allow", "Success",
    "Would be Rewritten", "Allow", "Partial",
    "Would be Blocked", "Deny", "Partial",
    "Would Be Blocked", "Deny", "Partial",
    "Dropped", "Drop", "Failure",
    "Would be Dropped", "Drop", "Partial",
    "Partially Dropped", "Drop", "Partial",
    "Would be Block", "Deny", "Partial",
    "Partial Blocked", "Deny", "Partial",
    "Rejected", "Deny", "Failure",
    "Would be Rejected", "Deny", "Partial",
    "Would Rejected", "Deny", "Partial",
    "Block", "Deny", "Failure",
    "Partial Block", "Deny", "Partial",
    "Drop", "Drop", "Failure",
    "Would Drop", "Drop", "Partial",
    "Reject", "Deny", "Failure",
    "Rewrite", "Allow", "Success",
    "Allow", "Allow", "Success",
    "Monitor", "Allow", "Success"
];
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
[
      "0", "Low",
      "1", "Low",
      "2", "Low",
      "3", "Low",
      "4", "Medium",
      "5", "Medium",
      "6", "Medium",
      "7", "High",
      "8", "High",
      "9", "High",
      "10", "High"
];
let EventResultDetailsLookup = datatable(Reason: string, EventResultDetails: string)
[
    "N/A", "NA",
    "IP Block", "Terminated",
    "IP Monitor", "Unknown",
    "User Bypass", "Unknown",
    "File Monitor", "Unknown",
    "File Block", "Terminated",
    "Intrusion Monitor", "Unknown",
    "Intrusion Block", "Terminated",
    "File Resume Block", "Terminated",
    "File Resume Allow", "Unknown",
    "File Custom Detection", "Unknown"
];
let parser = (starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]), 
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]), 
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let AllLogs = CommonSecurityLog
        | where not(disabled)
        | where (isnull(starttime) or TimeGenerated >= starttime) and (isnull(endtime) or TimeGenerated <= endtime)
            and DeviceVendor == "Cisco" and DeviceProduct == "Firepower"
            and DeviceEventClassID has_any("INTRUSION:400", "PV:112", "RNA:1003:1")
            and (array_length(hostname_has_any) == 0 or DestinationDnsDomain has_any (hostname_has_any)) 
            and (isnull(dstportnumber) or (DestinationPort == dstportnumber))
        | extend
            temp_isSrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any), 
            temp_isDstMatch = has_any_ipv4_prefix(DestinationIP, dst_or_any)
        | extend ASimMatchingIpAddr = case(
                                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", 
                                                (temp_isSrcMatch and temp_isDstMatch), "Both", 
                                                temp_isSrcMatch, "SrcIpAddr",
                                                temp_isDstMatch, "DstIpAddr",
                                                "No match" 
                                                )        
            | where ASimMatchingIpAddr != "No match"
        | invoke _ASIM_ResolveDstFQDN('DestinationDnsDomain')
        | extend temp_is_MatchDstHostname = DstHostname has_any (hostname_has_any)
        | extend ASimMatchingHostname = case(
                                    array_length(hostname_has_any) == 0,
                                    "-",
                                    temp_is_MatchDstHostname,
                                    "DstHostname",
                                    "No match"
                                )
        | where ASimMatchingHostname != "No match"
        | invoke _ASIM_ResolveNetworkProtocol('Protocol')
        | extend NetworkProtocol = iff(NetworkProtocol == "Unassigned" and Protocol !in (63, 68, 99, 114, 253, 254), Protocol, NetworkProtocol);
    let Connection_Statistics_Events = AllLogs
        | where DeviceEventClassID has "RNA:1003:1"
        | parse-kv AdditionalExtensions as (
            start: long,
            end: long,
            bytesIn: long,
            bytesOut: long,
            )
            with (pair_delimiter=';', kv_delimiter='=') 
        | lookup EventResultDetailsLookup on Reason
        | extend
            SrcBytes = bytesIn,
            DstBytes = bytesOut,
            EventOriginalResultDetails = Reason,
            AdditionalFields = bag_pack("policy", DeviceCustomString1,
                                                "instanceID", ProcessID,
                                                "clientApplicationID", RequestClientApplication,
                                                "clientUrl", RequestURL);
    let Intrusion_Events = AllLogs
        | where DeviceEventClassID has "INTRUSION:400"
        | parse-kv AdditionalExtensions as (
            start: long
            )
            with (pair_delimiter=';', kv_delimiter='=')
        | extend 
            EventMessage = Activity,
            ThreatCategory = DeviceEventCategory,
            AdditionalFields = bag_pack("policy", DeviceCustomString1,
                                                "ipspolicy", DeviceCustomString5,
                                                "clientApplicationID", RequestClientApplication,
                                                "clientUrl", RequestURL);
    let Policy_Violation_Events = AllLogs
        | where DeviceEventClassID has "PV:112"
        | extend
            EventMessage = Message,
            AdditionalFields = bag_pack("policy", DeviceCustomString1)
        | project-rename DstUsername = DestinationUserName
        | extend
            DstUsernameType = _ASIM_GetUsernameType(DstUsername),
            DstUserType = _ASIM_GetUserType(DstUsername, "");
    union Connection_Statistics_Events, Intrusion_Events, Policy_Violation_Events
    | extend
        SrcPortNumber = iff(NetworkProtocol == "ICMP", int(null), SourcePort),
        DstPortNumber = iff(NetworkProtocol == "ICMP", int(null), DestinationPort),
        NetworkIcmpCode = iff(NetworkProtocol == "ICMP", DestinationPort, int(null)),
        NetworkIcmpType = iff(NetworkProtocol == "ICMP", tostring(SourcePort), ""),
        SrcZone = DeviceCustomString3,
        DstZone = DeviceCustomString4
    | lookup ActionLookup on DeviceAction
    | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
    | where ((eventresult == "*") or EventResult == eventresult)
    | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
    | lookup EventSeverityLookup on LogSeverity
    | extend 
        EventStartTime = coalesce(unixtime_milliseconds_todatetime(start), unixtime_milliseconds_todatetime(tolong(ReceiptTime))),
        SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
        DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
        EventOriginalType = iff(DeviceEventClassID has "INTRUSION:400", "INTRUSION EVENT", Activity),
        SrcVlanId = tostring(DeviceCustomNumber1)
    | extend
        EventEndTime = coalesce(unixtime_milliseconds_todatetime(end), EventStartTime),
        NetworkProtocolVersion = case(
                            DstIpAddr contains ".",
                            "IPv4",
                            DstIpAddr contains ":",
                            "IPv6",
                            ""
                        )
    | extend Ip_device = iff(DeviceName matches regex "(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))", DeviceName, "")
    | extend
        DvcIpAddr = Ip_device,
        DeviceName = iff(isempty(Ip_device), DeviceName, "")
    | extend host = coalesce(DeviceName, Computer)
    | invoke _ASIM_ResolveDvcFQDN('host')
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventCount = int(1)
    | project-rename 
        EventProduct = DeviceProduct,
        EventVendor = DeviceVendor,
        SrcUsername = SourceUserName,
        DvcInboundInterface = DeviceInboundInterface,
        DvcOutboundInterface = DeviceOutboundInterface,
        EventOriginalSeverity = LogSeverity,
        DvcId = DeviceExternalID,
        NetworkApplicationProtocol = ApplicationProtocol,
        EventProductVersion = DeviceVersion,
        EventOriginalUid = ExtID,
        NetworkRuleName = DeviceCustomString2,
        EventUid = _ItemId,
        DvcOriginalAction = DeviceAction
    | extend
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
        DvcIdType = "Other"
    | extend 
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Dvc = coalesce(DvcIpAddr, DvcHostname),
        Rule = NetworkRuleName,
        User = SrcUsername,
        Hostname = DstHostname
    | project-away
        bytesIn,
        bytesOut,
        start,
        end,
        CommunicationDirection,
        AdditionalExtensions,
        Device*,
        Source*,
        Destination*,
        Activity,
        ProcessID,
        Protocol,
        Reason,
        ReceiptTime,
        SimplifiedDeviceAction,
        OriginalLogSeverity,
        ProcessName,
        EndTime,
        ExternalID,
        File*,
        ReceivedBytes,
        Message,
        Old*,
        EventOutcome,
        Request*,
        StartTime,
        Field*,
        Flex*,
        Remote*,
        Malicious*,
        ThreatConfidence,
        ThreatSeverity,
        IndicatorThreatType,
        ThreatDescription,
        _ResourceId,
        SentBytes,
        ReportReferenceLink,
        Computer,
        TenantId,
        Ip_*,
        host,
        NetworkProtocolNumber,
        temp*
};
parser(
    starttime=starttime, 
    endtime=endtime,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber, 
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction, 
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionCiscoISE
// Description: This ASIM parser supports normalizing Cisco ISE Events produced by the Microsoft Sentinel Cisco ISE connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoISE(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventFieldsLookup=datatable(
EventOriginalType: string,
EventResult: string,
DvcAction: string,
EventResultDetails: string,
EventSubType: string,
EventOriginalSeverity: string,
EventSeverity: string,
EventMessage: string,
EventOriginalResultDetails: string
)[
"25023", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAP connect to domain controller succeeded", "LDAP connect to domain controller succeeded",
"25024", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "LDAP connect to domain controller failed", "LDAP connect to domain controller failed",
"25025", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAP connect to global catalog succeeded", "LDAP connect to domain controller succeeded",
"25026", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "LDAP connect to global catalog failed", "LDAP connect to domain controller failed",
"25027", "Success", "Allow", "", "Start", "INFO", "Informational", "RPC connect to domain controller succeeded", "RPC connect to domain controller succeeded",
"25028", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "RPC connect to domain controller failed", "RPC connect to domain controller failed",
"25029", "Success", "Allow", "", "Start", "INFO", "Informational", "KDC connect to domain controller succeeded", "KDC connect to domain controller succeeded",
"25030", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "KDC connect to domain controller failed", "KDC connect to domain controller failed",
"25101", "Success", "Allow", "", "Start", "DEBUG", "Informational", "Successfully connected to external REST ID store server", "ISE successfully connect to external REST ID store server",
"25102", "Failure", "Drop", "Terminated", "End", "DEBUG", "Low", "Connection to external REST database failed", "ISE failed to establish a new connection to external REST database",
"60188", "Failure", "Drop", "Terminated", "End", "INFO", "Low", "An attempted SSH connection has failed", "An attempted SSH connection has failed",
"60234", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "The SXP connection has been disconnected", "The SXP connection has been disconnected",
"60235", "Success", "Allow", "", "Start", "INFO", "Informational", "SXP connection succeeded", "SXP connection succeeded",
"60236", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "SXP connection failed", "SXP connection failed",
"61010", "Success", "Allow", "", "Start", "INFO", "Informational", "ISE has established connection to APIC", "ISE has established connection to APIC",
"61011", "Success", "Allow", "", "End", "INFO", "Informational", "ISE was disconnected from APIC", "ISE was disconnected from APIC",
"61025", "Success", "Allow", "", "Start", "INFO", "Informational", "Open secure connection with TLS peer", "Secure connection established with TLS peer",
"61026", "Success", "Allow", "", "End", "INFO", "Informational", "Shutdown secure connection with TLS peer", "Secure connection with TLS peer shutdown",
"60509", "Failure", "Deny", "Maximum Retry", "End", "ERROR", "Low", "ERS request was denied as maximum possible connection was exceeded", "ERS request was denied as maximum possible connection was exceeded",
"61231", "Failure", "Drop", "Routing issue", "End", "WARN", "Low", "Kafka connection to ACI error while receiving message", "Kafka connection to ACI error while receiving message",
"61232", "Failure", "Drop", "Routing issue", "End", "WARN", "Low", "Kafka connection to ACI error while sending message", "Kafka connection to ACI error while sending message",
"89003", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "Failed to connect to MDM server", "Failed to connect to MDM server",
"24000", "Success", "Allow", "", "Start", "INFO", "Informational", "Connection established with LDAP server", "Connection established with LDAP server",
"24001", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Cannot establish connection with LDAP server", "Cannot establish connection with LDAP server",
"24019", "Failure", "Drop", "Unknown", "End", "ERROR", "Low", "LDAP connection error was encountered", "ISE cannot connect to LDAP external ID store",
"24030", "Failure", "Drop", "Unknown", "End", "ERROR", "Low", "SSL connection error was encountered", "SSL connection error was encountered",
"24400", "Success", "Allow", "", "Start", "INFO", "Informational", "Connection to ISE Active Directory agent established successfully", "Connection to ISE Active Directory agent established successfully",
"24401", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Could not establish connection with ISE Active Directory agent", "Could not establish connection with ISE Active Directory agent",
"24428", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Connection related error has occurred in either LRPC, LDAP or KERBEROS", "This RPC connection problem may be because the stub received incorrect data",
"24429", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Could not establish connection with Active Directory", "Could not establish connection with Active Directory",
"24850", "Success", "Allow", "", "Start", "DEBUG", "Informational", "Successfully connected to external ODBC database", "ISE successfully established a new connection to external ODBC database",
"24851", "Failure", "Drop", "Terminated", "End", "DEBUG", "Low", "Connection to external ODBC database failed", "ISE failed to establish a new connection to external ODBC database",
"34120", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Profiler failed to get the connection to NAC Manager", "Profiler sends a notification event to NAC Manager, but the notification fails because could not connect to NAC Manager",
"34147", "Failure", "Deny", "Terminated", "End", "WARN", "Low", "JGroups TLS Handshake Failed", "JGroups TLS Handshake Failed",
"34148", "Success", "Allow", "", "Start", "INFO", "Informational", "JGroups TLS Handshake Succeeded", "JGroups TLS Handshake Succeeded",
"34149", "Failure", "Deny", "Terminated", "End", "WARN", "Low", "HTTPS TLS Handshake Failed", "HTTPS TLS Handshake Failed",
"34150", "Success", "Allow", "", "Start", "INFO", "Informational", "HTTPS TLS Handshake Succeeded", "HTTPS TLS Handshake Succeeded",
"34159", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAPS connection established successfully", "LDAPS connection established successfully",
"34160", "Success", "Allow", "", "End", "INFO", "Informational", "LDAPS connection terminated successfully", "LDAPS connection terminated successfully",
"34161", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection establishment failed with SSL error", "LDAPS connection establishment failed with SSL error",
"34162", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection terminated with SSL error", "LDAPS connection terminated with SSL error",
"34163", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection establishment failed with non-SSL error", "LDAPS connection establishment failed with non-SSL error",
"34164", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection terminated with non-SSL error", "LDAPS connection terminated with non-SSL error",
"90062", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Cannot connect to Domain Controller", "Cannot connect to Domain Controller",
"90063", "Success", "Allow", "", "Start", "INFO", "Informational", "Successfully establish connection to Domain Controller", "Successfully establish connection to Domain Controller",
"90066", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Lost connection with Domain Controller", "Lost connection with Domain Controller",
"90078", "Success", "Allow", "", "Start", "INFO", "Informational", "Closed connection to Domain Controller", "Closed connection to Domain Controller",
"91082", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "RADIUS DTLS: Connection to OCSP server failed", "RADIUS DTLS: Connection attempt to OCSP server failed.",
"11317", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "TrustSec SSH connection failed", "ISE failed to establish SSH connection to a network device. Verify network device SSH credentials in the Network Device page are similar to the credentials configured on the network device. Check network device enabled ssh connections from ISE (ip address)",
"5405", "Failure", "Drop", "Terminated", "End", "NOTICE", "Low", "RADIUS Request dropped", "RADIUS request dropped",
"5406", "Failure", "Drop", "Terminated", "End", "NOTICE", "Low", "TACACS+ Request dropped", "TACACS+ request dropped"
];
let GetSrcIpAddr = (src_ip: string) {
    case ( 
    src_ip matches regex @"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}",
    src_ip,
    ""
    )
};
let GetMacAddr = (mac: string) {
    case ( 
    mac matches regex @"[a-fA-F0-9\-:]{17}",
    mac,
    ""
    )
};
let CiscoISENSParser = (
starttime: datetime=datetime(null), 
endtime: datetime=datetime(null),
srcipaddr_has_any_prefix: dynamic=dynamic([]), 
dstipaddr_has_any_prefix: dynamic=dynamic([]), 
ipaddr_has_any_prefix: dynamic=dynamic([]),
dstportnumber: int=int(null), 
hostname_has_any: dynamic=dynamic([]), 
dvcaction: dynamic=dynamic([]), 
eventresult: string='*', 
disabled: bool=false) {
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let EventOriginalTypeList = toscalar(EventFieldsLookup
      | where (eventresult == "*" or eventresult == EventResult) 
          and (array_length(dvcaction) == 0 or DvcAction in~ (dvcaction))
      | summarize make_set(EventOriginalType));
  Syslog
  | where not(disabled)
  | where (isnull(starttime) or TimeGenerated >= starttime) 
      and (isnull(endtime) or TimeGenerated <= endtime) 
  | where ProcessName has_any ("CISE", "CSCO")
  | parse kind = regex SyslogMessage with @"\d{10}\s" EventOriginalType @"\s(NOTICE|INFO|WARN|WARNING|ERROR|FATAL|DEBUG)"
  | where EventOriginalType in (EventOriginalTypeList)
      and (array_length(ip_any) == 0 or has_any_ipv4_prefix(SyslogMessage, ip_any)) 
      and (array_length(hostname_has_any) == 0 or SyslogMessage has_any(hostname_has_any)) 
      and (isnull(dstportnumber) or SyslogMessage has (strcat('DestinationPort=', tostring(dstportnumber))))
  | lookup EventFieldsLookup on EventOriginalType
  | parse-kv SyslogMessage as (FailureReason: string, NetworkDeviceName: string, DestinationIPAddress: string, DestinationPort: int, ['Remote-Address']: string, ['Device IP Address']: string, ['User-Name']: string, UserName: string, User: string, ['Device Port']: int, Protocol: string, ['Calling-Station-ID']: string, ['Called-Station-ID']: string) with (pair_delimiter=',', kv_delimiter='=')
  | project-rename
      DstIpAddr=DestinationIPAddress
      , DstPortNumber=DestinationPort
      , SrcPortNumber=['Device Port']
      , NetworkApplicationProtocol=Protocol
  | invoke _ASIM_ResolveSrcFQDN("['Calling-Station-ID']")
  | extend 
      EventVendor = "Cisco"
      , EventProduct = "ISE"
      , EventProductVersion = "3.2"
      , EventCount = int(1)
      , EventSchema = "NetworkSession"
      , EventSchemaVersion = "0.2.6"
      , EventStartTime = coalesce(EventTime, TimeGenerated)
      , EventEndTime = coalesce(EventTime, TimeGenerated)
      , EventType = "NetworkSession"
      , EventOriginalResultDetails = case(isnotempty(FailureReason), FailureReason, EventOriginalResultDetails)
      , DvcIpAddr = iif(isnotempty(HostIP) and HostIP != "Unknown IP", HostIP, extract(@"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", 1, Computer))
      , DstMacAddr = GetMacAddr(['Called-Station-ID'])
      , SrcMacAddr = GetMacAddr(['Calling-Station-ID'])
      , DstUsername = coalesce(UserName, ['User-Name'], User)
  | extend
      DstUsernameType = _ASIM_GetUsernameType(DstUsername)
      , DvcHostname = coalesce(NetworkDeviceName, Computer, HostName)
      , SrcIpAddr = coalesce(['Device IP Address'], ['Remote-Address'], GetSrcIpAddr(['Calling-Station-ID']))
  //********************** <Aliaces> ************************
  | extend 
      Dvc = coalesce(DvcHostname, DvcIpAddr)
      , IpAddr = SrcIpAddr
      , Dst = DstIpAddr
      , Src = SrcIpAddr
      , User = DstUsername
  //********************** </Aliases> ***********************
  | project-away
      TenantId,
      SourceSystem,
      MG,
      Computer,
      EventTime,
      Facility,
      HostName,
      SeverityLevel,
      SyslogMessage,
      HostIP,
      ProcessName,
      ProcessID,
      _ResourceId,
      FailureReason,
      NetworkDeviceName,
      ['User-Name'],
      UserName,
      ['Device IP Address'],
      ['Remote-Address'],
      ['Calling-Station-ID'],
      ['Called-Station-ID']
};
CiscoISENSParser(
starttime=starttime,
endtime=endtime, 
srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
ipaddr_has_any_prefix=ipaddr_has_any_prefix, 
dstportnumber=dstportnumber, 
hostname_has_any=hostname_has_any, 
dvcaction=dvcaction, 
eventresult=eventresult, 
disabled=disabled)
}



//
// Function Name: vimNetworkSessionCiscoMeraki
// Description: This ASIM parser supports normalizing Cisco Meraki logs ingested in 'meraki_CL' to the ASIM Network Session normalized schema. Cisco Meraki events are generated from network activity and security events from Meraki devices such as firewalls, switches, and access points. These logs are captured through the Cisco Meraki Sentinel connector which uses a Linux agent to collect logs in Syslog format.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoMeraki(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventResultDetailsLookup = datatable(reason: string, EventResultDetails: string)
  [
    "0", "Unknown",
    "1", "Unknown",
    "2", "Timeout",
    "3", "Terminated",
    "4", "Timeout",
    "5", "Transient error",
    "6", "Invalid Tunnel",
    "7", "Invalid Tunnel",
    "8", "Terminated",
    "9", "Invalid Tunnel",
    "10", "Unknown",
    "11", "Invalid TCP",
    "12", "Unknown",
    "13", "Invalid TCP",
    "14", "Invalid Tunnel",
    "15", "Invalid TCP",
    "16", "Timeout",
    "17", "Invalid Tunnel",
    "18", "Invalid TCP",
    "19", "Invalid TCP",
    "20", "Invalid TCP",
    "21", "Unknown",
    "22", "Invalid TCP",
    "23", "Invalid Tunnel",
    "24", "Invalid Tunnel",
    "32", "Unknown",
    "33", "Invalid TCP",
    "34", "Invalid TCP",
    "35", "Invalid TCP",
    "36", "Unknown",
    "37", "Unknown",
    "38", "Unknown",
    "39", "Timeout",
    "40", "Invalid TCP",
    "98", "Unknown",
    "99", "Unknown"
];
let NetworkIcmpTypeLookup = datatable(
    NetworkIcmpCode_lookup: int,
    NetworkIcmpType_lookup: string
)
    [
    0, "Reserved",
    1, "Destination Unreachable",
    2, "Packet Too Big",
    3, "Time Exceeded",
    4, "Parameter Problem",
    100, "Private experimentation",
    101, "Private experimentation",
    127, "Reserved for expansion of ICMPv6 error messages",
    128, "Echo Request",
    129, "Echo Reply",
    130, "Multicast Listener Query",
    131, "Multicast Listener Report",
    132, "Multicast Listener Done",
    133, "Router Solicitation",
    134, "Router Advertisement",
    135, "Neighbor Solicitation",
    136, "Neighbor Advertisement",
    137, "Redirect Message",
    138, "Router Renumbering",
    139, "ICMP Node Information Query",
    140, "ICMP Node Information Response",
    141, "Inverse Neighbor Discovery Solicitation Message",
    142, "Inverse Neighbor Discovery Advertisement Message",
    143, "Version 2 Multicast Listener Report",
    144, "Home Agent Address Discovery Request Message",
    145, "Home Agent Address Discovery Reply Message",
    146, "Mobile Prefix Solicitation",
    147, "Mobile Prefix Advertisement",
    148, "Certification Path Solicitation Message",
    149, "Certification Path Advertisement Message",
    150, "ICMP messages utilized by experimental mobility protocols such as Seamoby",
    151, "Multicast Router Advertisement",
    152, "Multicast Router Solicitation",
    153, "Multicast Router Termination",
    154, "FMIPv6 Messages",
    155, "RPL Control Message",
    156, "ILNPv6 Locator Update Message",
    157, "Duplicate Address Request",
    158, "Duplicate Address Confirmation",
    159, "MPL Control Message",
    160, "Extended Echo Request",
    161, "Extended Echo Reply",
    200, "Private experimentation",
    201, "Private experimentation",
    255, "Reserved for expansion of ICMPv6 informational messages"
];
let NetworkProtocolLookup = datatable(
    protocol: string,
    NetworkProtocol_lookup: string,
    NetworkProtocolVersion: string
)[
    "tcp", "TCP", "",
    "tcp/ip", "TCP", "",
    "udp", "UDP", "",
    "udp/ip", "UDP", "",
    "icmp", "ICMP", "IPV4",
    "icmp6", "ICMP", "IPV6",
];
let EventSeverityPriorityLookup = datatable(priority: string, EventSeverity: string)[
    "1", "High",
    "2", "Medium",
    "3", "Low",
    "4", "Informational"
];
let EventSeverityDvcActionLookup = datatable(DvcAction: string, EventSeverity: string)[
    "Allow", "Informational",
    "Deny", "Low"
];
let NetworkDirectionLookup = datatable(direction: string, NetworkDirection: string)[
    "ingress", "Inbound",
    "egress", "Outbound",
    "Unknown", "NA"
];
let DvcActionLookup = datatable(pattern: string, DvcAction: string, EventResult: string)[
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "0", "Allow", "Success",
    "1", "Deny", "Failure",
    "Blocked", "Deny", "Failure"
];
let EventResultLookup = datatable(LogSubType: string, EventResult_type: string)[
    "association", "Success",
    "disassociation", "Failure",
    "Virtual router collision", "Failure",
];
let parser=(disabled: bool=false, 
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null), 
    eventresult: string='*', 
    srcipaddr_has_any_prefix: dynamic=dynamic([]),
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]), 
    hostname_has_any: dynamic=dynamic([]),
    dstportnumber: int=int(null),
    dvcaction: dynamic=dynamic([])
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let allData = (
            meraki_CL
            | project-rename LogMessage =  Message
            );
    let PreFilteredData = allData
        | where not(disabled) and (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime) and (LogMessage has_any("flows", "firewall", "ids-alerts") or LogMessage has_all("security_event", "ids-alerted") or (LogMessage has "events" and (LogMessage has_any ("Blocked DHCP server response", "association") or (LogMessage has "VRRP packet" and not(LogMessage has_any ("VRRP passive", "VRRP active"))) or (LogMessage has "disassociation" and not(LogMessage has_any ("auth_neg_failed", "dhcp"))))) or (LogMessage has "airmarshal_events" and LogMessage has_any("ssid_spoofing_detected", "rogue_ssid_detected")))
        | extend Parser = extract_all(@"(\d+.\d+)\s([\w\-\_]+)\s([\w\-\_]+)\s([\S\s]+)$", dynamic([1, 2, 3, 4]), LogMessage)[0]
        | extend
            LogType = tostring(Parser[2]),
            Substring = tostring(Parser[3]),
            Device = tostring(Parser[1])
        | parse Substring with * "timestamp=" timestamp: string " " *
        | extend
            Epoch = iff(isnotempty(timestamp), timestamp, tostring(Parser[0]))
        | extend
            EpochTimestamp = split(Epoch, ".")
        | extend EventStartTime = unixtime_seconds_todatetime(tolong(EpochTimestamp[0]))
        | extend EventEndTime = EventStartTime
        | where (array_length(hostname_has_any) == 0)
            and ((isnull(dstportnumber)) or Substring has tostring(dstportnumber))
            and (array_length(dvcaction) == 0 or LogMessage has_any (dvcaction));
    let FlowsFirewallData = PreFilteredData
        | where LogType in ("flows", "firewall", "cellular_firewall", "vpn_firewall")
        | parse-kv Substring as(src: string, dst: string, mac: string, sport: string, dport: string, protocol: string, type: int) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | parse Substring with pattern1: string " src=" temp_restmessage: string
        | parse Substring with * "pattern: " pattern2: string " " temp_restmessage: string
        | extend NetworkIcmpCode_lookup = iff(protocol == 'icmp6', type, int(null))
        | extend type_icmp4 = iff(protocol == 'icmp', type, int(null))
        | lookup NetworkIcmpTypeLookup on NetworkIcmpCode_lookup
        | invoke _ASIM_ResolveICMPType('type_icmp4')
        | extend NetworkIcmpCode = coalesce(NetworkIcmpCode_lookup, NetworkIcmpCode)
        | extend NetworkIcmpType = iff(isnotempty(NetworkIcmpCode), coalesce(NetworkIcmpType_lookup, NetworkIcmpType), "")
        | extend pattern = coalesce(trim("'", pattern1), trim("'", pattern2))
        | extend pattern = trim('"', pattern)
        | extend direction = case(pattern has_any ('0','1'), 'ingress', pattern has_any ('allow','deny'), 'egress', 'unknown')
        | lookup NetworkDirectionLookup on direction
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | extend
            SrcMacAddr = trim('"', mac),
            EventType = "Flow";
    let IDSAlertData = PreFilteredData
        | where LogType in ("ids-alerts", "security_event")
        | parse LogMessage with * "security_event " LogSubType: string " " * "message: " message: string 
        | where LogType == "security_event" and LogSubType == "ids-alerted" or LogType == "ids-alerts"
        | parse-kv Substring as(priority: string, direction: string, protocol: string, src: string, dst: string, signature: string, dhost: string, shost: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend EventResult = "Success"
        | extend
            priority = trim('"', priority),
            direction = trim('"', direction)
        | lookup EventSeverityPriorityLookup on priority
        | lookup NetworkDirectionLookup on direction
        | extend AdditionalFields = bag_pack(
                                "signature", trim('"', signature)
                            )
        | extend
            SrcMacAddr = trim('"', shost),
            DstMacAddr = trim('"', dhost)
        | extend EventMessage = trim("'", message);
    let AirmarshalEvents = PreFilteredData
        | where LogType in ("airmarshal_events")
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType in ("ssid_spoofing_detected", "rogue_ssid_detected")
        | parse-kv temp_message as(src: string, dst: string, wired_mac: string, vlan_id: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend
            SrcMacAddr = trim('"', src),
            DstMacAddr = trim('"', dst),
            DvcMacAddr = trim('"', wired_mac)
        | extend
            EventResult = "Success",
            EventSeverity = "High";
    let EventsData = PreFilteredData
        | where LogType == "events";
    let EventsData_associ = EventsData
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType == "association" or (LogSubType == "disassociation" and not(Substring has_any ("auth_neg_failed", "dhcp")))
        | parse-kv Substring as (last_known_client_ip: string, client_mac: string, identity: string, aid: string, duration: string, ip_src: string, dns_server: string, reason: string, rssi: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend AdditionalFields = bag_pack(
                                "aid", aid,
                                "rssi", rssi
                            )
        | extend SrcMacAddr = trim('"', client_mac)
        | lookup EventResultLookup on LogSubType
        | extend EventResult = EventResult_type
        | lookup EventResultDetailsLookup on reason
        | extend EventResultDetails = iff((toint(reason) >= 25 and toint(reason) <= 31) or (toint(reason) >= 25 and toint(reason) <= 31), "Unknown", EventResultDetails);
    let EventsData_space = EventsData
        | where Substring has "Blocked DHCP server response" or (Substring has "VRRP packet" and not(Substring in~ ("VRRP passive", "VRRP active"))) 
        | parse Substring with LogSubType1: string " from" temp_addr1: string " on VLAN " vlan_id1: string " " restmessage
        | parse Substring with LogSubType2: string " from" temp_addr2: string " on VLAN " vlan_id2: string
        | extend LogSubType = coalesce(LogSubType1, LogSubType2)
        | extend LogSubType = iff(LogSubType has "VRRP Packet", "Virtual router collision", LogSubType)
        | extend pattern = iff(Substring has "Blocked", "Blocked", "")
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | lookup EventResultLookup on LogSubType
        | extend EventResult = coalesce(EventResult, EventResult_type)
        | extend temp_addr = coalesce(trim('"', temp_addr1), trim('"', temp_addr2))
        | extend vlan_id = coalesce(trim('"', vlan_id1), trim('"', vlan_id2))
        | extend SrcMacAddr = iff(temp_addr matches regex "(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))", temp_addr, "")
        | parse temp_addr with *  "[" temp_ip: string "]:" temp_port: string 
        | extend SrcIpAddr = case(
                        temp_addr has ".",
                        split(temp_addr, ":")[0],
                        isnotempty(temp_ip),
                        temp_ip,
                        temp_addr
                    )
        | extend SrcPortNumber = toint(case(
                          isnotempty(temp_port),
                          temp_port,
                          temp_addr has ".",
                          split(temp_addr, ":")[1],
                          ""
                      )
                    )
        | extend
            SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr),
            EventMessage = Substring;
    union
        FlowsFirewallData,
        IDSAlertData,
        EventsData_associ,
        EventsData_space,
        AirmarshalEvents
    | where (array_length(dvcaction) == 0 or DvcAction has_any (dvcaction))
    | where (eventresult == "*" or EventResult =~ eventresult)
    | extend protocol = trim('"', protocol)
    | lookup NetworkProtocolLookup on protocol
    | invoke _ASIM_ResolveNetworkProtocol('protocol')
    | extend NetworkProtocol = iff(isempty(NetworkProtocolNumber), NetworkProtocol_lookup, NetworkProtocol)
    | extend temp_srcipport = trim('"', coalesce(src, ip_src, last_known_client_ip))
    | parse temp_srcipport with *  "[" temp_srcip: string "]:" temp_srcport: string 
    | extend SrcIpAddr = case( 
                        isnotempty(SrcIpAddr),
                        SrcIpAddr,
                        temp_srcipport has ".",
                        split(temp_srcipport, ":")[0],
                        coalesce(temp_srcip, temp_srcipport)
                    )
    | extend SrcPortNumber = iff(isempty(SrcPortNumber), toint(coalesce(sport, temp_srcport)), SrcPortNumber)
    | extend SrcPortNumber = toint(iff(isempty(SrcPortNumber) and SrcIpAddr has ".", split(temp_srcipport, ":")[1], SrcPortNumber))
    | extend temp_dstipport = trim('"', coalesce(dst, dns_server))
    | parse temp_dstipport with * "[" temp_dstip "]:" temp_dstport
    | extend DstIpAddr = iff(temp_dstipport has ".", split(temp_dstipport, ":")[0], coalesce(temp_dstip, temp_dstipport))
    | extend DstPortNumber = toint(coalesce(dport, temp_dstport))
    | extend DstPortNumber = toint(iff(isempty(DstPortNumber) and DstIpAddr has ".", split(temp_dstipport, ":")[1], DstPortNumber))
    | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
    | extend DstIpAddr = iff(DstIpAddr == DstMacAddr, "", DstIpAddr)
    | where  (isnull(dstportnumber) or dstportnumber == DstPortNumber)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SrcIpAddr, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DstIpAddr, dst_or_any)
    | extend ASimMatchingIpAddr=case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
    | extend
        SrcUsername = trim('"', identity),
        SrcVlanId = trim('"', vlan_id)
    | invoke _ASIM_ResolveDvcFQDN('Device')
    | extend NetworkIcmpType = iff((protocol == 'icmp6' and isnotempty(NetworkIcmpCode)) and (NetworkIcmpCode between (5 .. 99) or NetworkIcmpCode between (102 .. 126) or NetworkIcmpCode between(162 .. 199) or NetworkIcmpCode between (202 .. 254)), "Unassigned", NetworkIcmpType)
    | extend
        EventSeverity = case(
                    isnotempty(EventSeverity),
                    EventSeverity,
                    EventResult == "Failure",
                    "Low",
                    "Informational"
                ),
        EventType = iff(isnotempty(EventType), EventType, "NetworkSession"),
        SrcUsernameType = iff(isnotempty(SrcUsername), "Simple", "")
    | extend
        Dvc = DvcHostname,
        Src = coalesce(SrcIpAddr, SrcMacAddr),
        Dst = coalesce(DstIpAddr, DstMacAddr),
        NetworkDuration = toint(todouble(trim('"', duration)) * 1000)
    | project-rename
        EventOriginalType = LogType,
        EventOriginalSubType = LogSubType
    | extend
        EventCount = int(1),
        EventProduct = "Meraki",
        EventVendor = "Cisco",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        EventUid = _ResourceId
    | project-away
        LogMessage,
        Parser,
        Epoch,
        EpochTimestamp,
        Device,
        Substring,
        protocol,
        priority,
        reason,
        direction,
        duration,
        src,
        dst,
        dns_server,
        sport,
        dport,
        *_lookup,
        type*,
        pattern*,
        last_known_client_ip,
        ip_src,
        client_mac,
        mac,
        shost,
        dhost,
        wired_mac,
        identity,
        temp*,
        vlan_id*,
        LogSubType1,
        LogSubType2,
        restmessage*,
        message,
        rssi,
        aid,
        signature,
        timestamp,
        EventResult_type,
        TenantId,
        SourceSystem,
        Computer,
        _ResourceId,
        MG,ManagementGroupName,NetworkProtocolNumber
};
parser(
    disabled=disabled,
    starttime=starttime, 
    endtime=endtime,
    eventresult=eventresult,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix,
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix,
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    hostname_has_any=hostname_has_any,
    dstportnumber=dstportnumber,
    dvcaction=dvcaction
)
}



//
// Function Name: vimNetworkSessionCiscoMerakiSyslog
// Description: This ASIM parser supports normalizing Cisco Meraki logs ingested in 'Syslog' to the ASIM Network Session normalized schema. Cisco Meraki events are generated from network activity and security events from Meraki devices such as firewalls, switches, and access points. These logs are captured through the Cisco Meraki Sentinel connector which uses a Linux agent to collect logs in Syslog format.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoMerakiSyslog(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventResultDetailsLookup = datatable(reason: string, EventResultDetails: string)
  [
    "0", "Unknown",
    "1", "Unknown",
    "2", "Timeout",
    "3", "Terminated",
    "4", "Timeout",
    "5", "Transient error",
    "6", "Invalid Tunnel",
    "7", "Invalid Tunnel",
    "8", "Terminated",
    "9", "Invalid Tunnel",
    "10", "Unknown",
    "11", "Invalid TCP",
    "12", "Unknown",
    "13", "Invalid TCP",
    "14", "Invalid Tunnel",
    "15", "Invalid TCP",
    "16", "Timeout",
    "17", "Invalid Tunnel",
    "18", "Invalid TCP",
    "19", "Invalid TCP",
    "20", "Invalid TCP",
    "21", "Unknown",
    "22", "Invalid TCP",
    "23", "Invalid Tunnel",
    "24", "Invalid Tunnel",
    "32", "Unknown",
    "33", "Invalid TCP",
    "34", "Invalid TCP",
    "35", "Invalid TCP",
    "36", "Unknown",
    "37", "Unknown",
    "38", "Unknown",
    "39", "Timeout",
    "40", "Invalid TCP",
    "98", "Unknown",
    "99", "Unknown"
];
let NetworkIcmpTypeLookup = datatable(
    NetworkIcmpCode_lookup: int,
    NetworkIcmpType_lookup: string
)
    [
    0, "Reserved",
    1, "Destination Unreachable",
    2, "Packet Too Big",
    3, "Time Exceeded",
    4, "Parameter Problem",
    100, "Private experimentation",
    101, "Private experimentation",
    127, "Reserved for expansion of ICMPv6 error messages",
    128, "Echo Request",
    129, "Echo Reply",
    130, "Multicast Listener Query",
    131, "Multicast Listener Report",
    132, "Multicast Listener Done",
    133, "Router Solicitation",
    134, "Router Advertisement",
    135, "Neighbor Solicitation",
    136, "Neighbor Advertisement",
    137, "Redirect Message",
    138, "Router Renumbering",
    139, "ICMP Node Information Query",
    140, "ICMP Node Information Response",
    141, "Inverse Neighbor Discovery Solicitation Message",
    142, "Inverse Neighbor Discovery Advertisement Message",
    143, "Version 2 Multicast Listener Report",
    144, "Home Agent Address Discovery Request Message",
    145, "Home Agent Address Discovery Reply Message",
    146, "Mobile Prefix Solicitation",
    147, "Mobile Prefix Advertisement",
    148, "Certification Path Solicitation Message",
    149, "Certification Path Advertisement Message",
    150, "ICMP messages utilized by experimental mobility protocols such as Seamoby",
    151, "Multicast Router Advertisement",
    152, "Multicast Router Solicitation",
    153, "Multicast Router Termination",
    154, "FMIPv6 Messages",
    155, "RPL Control Message",
    156, "ILNPv6 Locator Update Message",
    157, "Duplicate Address Request",
    158, "Duplicate Address Confirmation",
    159, "MPL Control Message",
    160, "Extended Echo Request",
    161, "Extended Echo Reply",
    200, "Private experimentation",
    201, "Private experimentation",
    255, "Reserved for expansion of ICMPv6 informational messages"
];
let NetworkProtocolLookup = datatable(
    protocol: string,
    NetworkProtocol_lookup: string,
    NetworkProtocolVersion: string
)[
    "tcp", "TCP", "",
    "tcp/ip", "TCP", "",
    "udp", "UDP", "",
    "udp/ip", "UDP", "",
    "icmp", "ICMP", "IPV4",
    "icmp6", "ICMP", "IPV6",
];
let EventSeverityPriorityLookup = datatable(priority: string, EventSeverity: string)[
    "1", "High",
    "2", "Medium",
    "3", "Low",
    "4", "Informational"
];
let EventSeverityDvcActionLookup = datatable(DvcAction: string, EventSeverity: string)[
    "Allow", "Informational",
    "Deny", "Low"
];
let NetworkDirectionLookup = datatable(direction: string, NetworkDirection: string)[
    "ingress", "Inbound",
    "egress", "Outbound",
    "Unknown", "NA"
];
let DvcActionLookup = datatable(pattern: string, DvcAction: string, EventResult: string)[
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "Blocked", "Deny", "Failure"
];
let EventResultLookup = datatable(LogSubType: string, EventResult_type: string)[
    "association", "Success",
    "disassociation", "Failure",
    "Virtual router collision", "Failure",
];
let parser=(disabled: bool=false, 
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null), 
    eventresult: string='*', 
    srcipaddr_has_any_prefix: dynamic=dynamic([]),
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]), 
    hostname_has_any: dynamic=dynamic([]),
    dstportnumber: int=int(null),
    dvcaction: dynamic=dynamic([])
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let allData = (
            Syslog
            | where Computer in (_ASIM_GetSourceBySourceType('CiscoMeraki'))
            | project-rename LogMessage =  SyslogMessage
            );
    let PreFilteredData = allData
        | where not(disabled) and (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime) and (LogMessage has_any("flows", "firewall", "ids-alerts") or LogMessage has_all("security_event", "ids-alerted") or (LogMessage has "events" and (LogMessage has_any ("Blocked DHCP server response", "association") or (LogMessage has "VRRP packet" and not(LogMessage has_any ("VRRP passive", "VRRP active"))) or (LogMessage has "disassociation" and not(LogMessage has_any ("auth_neg_failed", "dhcp"))))) or (LogMessage has "airmarshal_events" and LogMessage has_any("ssid_spoofing_detected", "rogue_ssid_detected")))
        | extend Parser = extract_all(@"(\d+.\d+)\s([\w\-\_]+)\s([\w\-\_]+)\s([\S\s]+)$", dynamic([1, 2, 3, 4]), LogMessage)[0]
        | extend
            LogType = tostring(Parser[2]),
            Substring = tostring(Parser[3]),
            Device = tostring(Parser[1])
        | parse Substring with * "timestamp=" timestamp: string " " *
        | extend
            Epoch = iff(isnotempty(timestamp), timestamp, tostring(Parser[0]))
        | extend
            EpochTimestamp = split(Epoch, ".")
        | extend EventStartTime = unixtime_seconds_todatetime(tolong(EpochTimestamp[0]))
        | extend EventEndTime = EventStartTime
        | where (array_length(hostname_has_any) == 0)
            and ((isnull(dstportnumber)) or Substring has tostring(dstportnumber))
            and (array_length(dvcaction) == 0 or LogMessage has_any (dvcaction));
    let FlowsFirewallData = PreFilteredData
        | where LogType in ("flows", "firewall", "cellular_firewall", "vpn_firewall")
        | parse-kv Substring as(src: string, dst: string, mac: string, sport: string, dport: string, protocol: string, type: int) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | parse Substring with pattern1: string " src=" temp_restmessage: string
        | parse Substring with * "pattern: " pattern2: string " " temp_restmessage: string
        | extend NetworkIcmpCode_lookup = iff(protocol == 'icmp6', type, int(null))
        | extend type_icmp4 = iff(protocol == 'icmp', type, int(null))
        | lookup NetworkIcmpTypeLookup on NetworkIcmpCode_lookup
        | invoke _ASIM_ResolveICMPType('type_icmp4')
        | extend NetworkIcmpCode = coalesce(NetworkIcmpCode_lookup, NetworkIcmpCode)
        | extend NetworkIcmpType = iff(isnotempty(NetworkIcmpCode), coalesce(NetworkIcmpType_lookup, NetworkIcmpType), "")
        | extend pattern = coalesce(trim("'", pattern1), trim("'", pattern2))
        | extend pattern = trim('"', pattern)
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | extend
            SrcMacAddr = trim('"', mac),
            EventType = "Flow";
    let IDSAlertData = PreFilteredData
        | where LogType in ("ids-alerts", "security_event")
        | parse LogMessage with * "security_event " LogSubType: string " " * "message: " message: string 
        | where LogType == "security_event" and LogSubType == "ids-alerted" or LogType == "ids-alerts"
        | parse-kv Substring as(priority: string, direction: string, protocol: string, src: string, dst: string, signature: string, dhost: string, shost: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend EventResult = "Success"
        | extend
            priority = trim('"', priority),
            direction = trim('"', direction)
        | lookup EventSeverityPriorityLookup on priority
        | lookup NetworkDirectionLookup on direction
        | extend AdditionalFields = bag_pack(
                                "signature", trim('"', signature)
                            )
        | extend
            SrcMacAddr = trim('"', shost),
            DstMacAddr = trim('"', dhost)
        | extend EventMessage = trim("'", message);
    let AirmarshalEvents = PreFilteredData
        | where LogType in ("airmarshal_events")
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType in ("ssid_spoofing_detected", "rogue_ssid_detected")
        | parse-kv temp_message as(src: string, dst: string, wired_mac: string, vlan_id: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend
            SrcMacAddr = trim('"', src),
            DstMacAddr = trim('"', dst),
            DvcMacAddr = trim('"', wired_mac)
        | extend
            EventResult = "Success",
            EventSeverity = "High";
    let EventsData = PreFilteredData
        | where LogType == "events";
    let EventsData_associ = EventsData
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType == "association" or (LogSubType == "disassociation" and not(Substring has_any ("auth_neg_failed", "dhcp")))
        | parse-kv Substring as (last_known_client_ip: string, client_mac: string, identity: string, aid: string, duration: string, ip_src: string, dns_server: string, reason: string, rssi: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend AdditionalFields = bag_pack(
                                "aid", aid,
                                "rssi", rssi
                            )
        | extend SrcMacAddr = trim('"', client_mac)
        | lookup EventResultLookup on LogSubType
        | extend EventResult = EventResult_type
        | lookup EventResultDetailsLookup on reason
        | extend EventResultDetails = iff((toint(reason) >= 25 and toint(reason) <= 31) or (toint(reason) >= 25 and toint(reason) <= 31), "Unknown", EventResultDetails);
    let EventsData_space = EventsData
        | where Substring has "Blocked DHCP server response" or (Substring has "VRRP packet" and not(Substring in~ ("VRRP passive", "VRRP active"))) 
        | parse Substring with LogSubType1: string " from" temp_addr1: string " on VLAN " vlan_id1: string " " restmessage
        | parse Substring with LogSubType2: string " from" temp_addr2: string " on VLAN " vlan_id2: string
        | extend LogSubType = coalesce(LogSubType1, LogSubType2)
        | extend LogSubType = iff(LogSubType has "VRRP Packet", "Virtual router collision", LogSubType)
        | extend pattern = iff(Substring has "Blocked", "Blocked", "")
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | lookup EventResultLookup on LogSubType
        | extend EventResult = coalesce(EventResult, EventResult_type)
        | extend temp_addr = coalesce(trim('"', temp_addr1), trim('"', temp_addr2))
        | extend vlan_id = coalesce(trim('"', vlan_id1), trim('"', vlan_id2))
        | extend SrcMacAddr = iff(temp_addr matches regex "(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))", temp_addr, "")
        | parse temp_addr with *  "[" temp_ip: string "]:" temp_port: string 
        | extend SrcIpAddr = case(
                        temp_addr has ".",
                        split(temp_addr, ":")[0],
                        isnotempty(temp_ip),
                        temp_ip,
                        temp_addr
                    )
        | extend SrcPortNumber = toint(case(
                          isnotempty(temp_port),
                          temp_port,
                          temp_addr has ".",
                          split(temp_addr, ":")[1],
                          ""
                      )
                    )
        | extend
            SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr),
            EventMessage = Substring;
    union
        FlowsFirewallData,
        IDSAlertData,
        EventsData_associ,
        EventsData_space,
        AirmarshalEvents
    | where (array_length(dvcaction) == 0 or DvcAction has_any (dvcaction))
    | where (eventresult == "*" or EventResult =~ eventresult)
    | extend protocol = trim('"', protocol)
    | lookup NetworkProtocolLookup on protocol
    | invoke _ASIM_ResolveNetworkProtocol('protocol')
    | extend NetworkProtocol = iff(isempty(NetworkProtocolNumber), NetworkProtocol_lookup, NetworkProtocol)
    | extend temp_srcipport = trim('"', coalesce(src, ip_src, last_known_client_ip))
    | parse temp_srcipport with *  "[" temp_srcip: string "]:" temp_srcport: string 
    | extend SrcIpAddr = case( 
                        isnotempty(SrcIpAddr),
                        SrcIpAddr,
                        temp_srcipport has ".",
                        split(temp_srcipport, ":")[0],
                        coalesce(temp_srcip, temp_srcipport)
                    )
    | extend SrcPortNumber = iff(isempty(SrcPortNumber), toint(coalesce(sport, temp_srcport)), SrcPortNumber)
    | extend SrcPortNumber = toint(iff(isempty(SrcPortNumber) and SrcIpAddr has ".", split(temp_srcipport, ":")[1], SrcPortNumber))
    | extend temp_dstipport = trim('"', coalesce(dst, dns_server))
    | parse temp_dstipport with * "[" temp_dstip "]:" temp_dstport
    | extend DstIpAddr = iff(temp_dstipport has ".", split(temp_dstipport, ":")[0], coalesce(temp_dstip, temp_dstipport))
    | extend DstPortNumber = toint(coalesce(dport, temp_dstport))
    | extend DstPortNumber = toint(iff(isempty(DstPortNumber) and DstIpAddr has ".", split(temp_dstipport, ":")[1], DstPortNumber))
    | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
    | extend DstIpAddr = iff(DstIpAddr == DstMacAddr, "", DstIpAddr)
    | where  (isnull(dstportnumber) or dstportnumber == DstPortNumber)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SrcIpAddr, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DstIpAddr, dst_or_any)
    | extend ASimMatchingIpAddr=case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
    | extend
        SrcUsername = trim('"', identity),
        SrcVlanId = trim('"', vlan_id)
    | invoke _ASIM_ResolveDvcFQDN('Device')
    | extend NetworkIcmpType = iff((protocol == 'icmp6' and isnotempty(NetworkIcmpCode)) and (NetworkIcmpCode between (5 .. 99) or NetworkIcmpCode between (102 .. 126) or NetworkIcmpCode between(162 .. 199) or NetworkIcmpCode between (202 .. 254)), "Unassigned", NetworkIcmpType)
    | extend
        EventSeverity = case(
                    isnotempty(EventSeverity),
                    EventSeverity,
                    EventResult == "Failure",
                    "Low",
                    "Informational"
                ),
        EventType = iff(isnotempty(EventType), EventType, "NetworkSession"),
        SrcUsernameType = iff(isnotempty(SrcUsername), "Simple", "")
    | extend
        Dvc = DvcHostname,
        Src = coalesce(SrcIpAddr, SrcMacAddr),
        Dst = coalesce(DstIpAddr, DstMacAddr),
        NetworkDuration = toint(todouble(trim('"', duration)) * 1000)
    | project-rename
        EventOriginalType = LogType,
        EventOriginalSubType = LogSubType
    | extend
        EventCount = int(1),
        EventProduct = "Meraki",
        EventVendor = "Cisco",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        EventUid = _ResourceId
    | project-away
        LogMessage,
        Parser,
        Epoch,
        EpochTimestamp,
        Device,
        Substring,
        protocol,
        priority,
        reason,
        direction,
        duration,
        src,
        dst,
        dns_server,
        sport,
        dport,
        *_lookup,
        type*,
        pattern*,
        last_known_client_ip,
        ip_src,
        client_mac,
        mac,
        shost,
        dhost,
        wired_mac,
        identity,
        temp*,
        vlan_id*,
        LogSubType1,
        LogSubType2,
        restmessage*,
        message,
        rssi,
        aid,
        signature,
        timestamp,
        EventResult_type,
        TenantId,
        SourceSystem,
        Computer,
        _ResourceId,
        MG,
        EventTime,
        Facility,
        HostName,
        SeverityLevel,
        ProcessID,
        HostIP,
        ProcessName,CollectorHostName,NetworkProtocolNumber
};
parser(
    disabled=disabled,
    starttime=starttime, 
    endtime=endtime,
    eventresult=eventresult,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix,
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix,
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    hostname_has_any=hostname_has_any,
    dstportnumber=dstportnumber,
    dvcaction=dvcaction
)
}



//
// Function Name: vimNetworkSessionCorelightZeek
// Description: This ASIM parser supports filtering and normalizing Corelight Zeek Connection logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCorelightZeek(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let NetworkDirectionLookup = datatable(local_orig: bool, local_resp: bool, NetworkDirection: string)
[
  false, true, 'Inbound',
  true, false, 'Outbound',
  true, true, 'Local',
  false, false, 'Local'
];
let ResultLookup = datatable (conn_state:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string, EventSeverity:string)
[ 
   'S0', 'Success', '', 'Connection attempt seen, no reply', 'Informational',
   'S1', 'Success', '', 'Connection established, not terminated', 'Informational',
   'SF', 'Success', 'Terminated', 'Normal establishment and termination', 'Informational', // Note that this is the same symbol as for state S1. You can tell the two apart because for S1 there will not be any byte counts in the summary, while for SF there will be.
   'REJ', 'Failure', 'Rejeced', 'Connection attempt rejected', 'Low',
   'S2', 'Failure', 'Terminated', 'Connection established and close attempt by originator seen (but no reply from responder)', 'Low',
   'S3', 'Failure', 'Terminated', 'Connection established and close attempt by responder seen (but no reply from originator)', 'Low',
   'RSTO', 'Failure', 'Reset', 'Connection established, originator aborted (sent a RST)', 'Low',
   'RSTR', 'Failure', 'Reset', 'Responder sent a RST', 'Low',
   'RSTOS0', 'Failure', 'Reset', 'Originator sent a SYN followed by a RST, no SYN-ACK from the responder','Low',
   'RSTRH', 'Failure', 'Reset', 'Responder sent a SYN ACK followed by a RST, no SYN from the originator','Low',
   'SH', 'Failure', 'Timeout', 'Originator sent a SYN followed by a FIN, no SYN ACK from the responder', 'Low',
   'SHR', 'Failure', 'Timeout', 'Responder sent a SYN ACK followed by a FIN, no SYN from the originator', 'Low',
   'OTH', 'Success', '', 'No SYN seen, just midstream traffic', 'Informational'
];
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null), 
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]), 
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false
) 
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);    
  Corelight_CL 
  | where (isnull(starttime) or TimeGenerated>=starttime) 
      and (isnull(endtime) or TimeGenerated<=endtime) 
      and not(disabled)
      and (array_length(hostname_has_any) == 0)
      and (array_length(dvcaction) == 0)
      and (Message has '"_path":"conn"' or Message has '"conn_red"')
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(Message,ip_any)) 
      and (isnull(dstportnumber) or Message has (strcat('"id.resp_p":', tostring(dstportnumber)))) 
  | project Message
  | parse Message with * '"conn_state":"' conn_state '",' *
  | lookup ResultLookup on conn_state
  | where (eventresult == "*" or eventresult == EventResult)
  | parse-kv Message as (
      ['"_system_name"']:string,
      ['"_write_ts"']:datetime,
      ['"ts"']:datetime,
      ['"uid"']:string,
      ['"id.orig_h"']:string,
      ['"id.orig_p"']:int,
      ['"id.resp_h"']:string,
      ['"id.resp_p"']:int,
      ['"proto"']:string,
      ['"service"']:string,
      ['"duration"']:int,
      ['"orig_bytes"']:long,
      ['"resp_bytes"']:long,
      ['"local_orig"']:bool,
      ['"local_resp"']:bool,
      ['"missed_bytes"']:long,
      ['"history"']:string,
      ['"orig_pkts"']:long,
      ['"resp_pkts"']:long,
      ['"orig_l2_addr"']:string,
      ['"resp_l2_addr"']:string,
      ['"community_id']:string,
      ['"vlan"']:string,
      ['"inner_vlan"']:string
  ) 
  with (quote = '"')
  | extend 
      EventCount=int(1),
      EventProduct="Zeek",
      EventVendor="Corelight",
      EventSchema = "NetworkSession",
      EventSchemaVersion="0.2.4",
      EventType="Flow"
  | project-rename
      EventStartTime= ['"ts"'],
      EventEndTime = ['"_write_ts"'],
      EventOriginalUid = ['"uid"'],
      SrcIpAddr = ['"id.orig_h"'],
      SrcPortNumber = ['"id.orig_p"'],
      DstIpAddr = ['"id.resp_h"'],
      DstPortNumber = ['"id.resp_p"'],
      NetworkProtocol = ['"proto"'],
      NetworkApplicationProtocol = ['"service"'],
      NetworkDuration = ['"duration"'],
      SrcBytes = ['"orig_bytes"'],
      DstBytes = ['"resp_bytes"'],
      local_orig = ['"local_orig"'],
      local_resp = ['"local_resp"'],
      FlowMissedBytes = ['"missed_bytes"'],
      SrcPackets = ['"orig_pkts"'],
      DstPackets = ['"resp_pkts"'],
      SrcMacAddr = ['"orig_l2_addr"'],
      DstMacAddr = ['"resp_l2_addr"'],
      DstVlanId = ['"vlan"'],
      SrcVlanId = ['"inner_vlan"'],
      FlowHistory = ['"history"'],
      NetworkSessionId = ['"community_id'],
      Dvc = ['"_system_name"']
  | extend 
    temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
    temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | project-away temp*
  | where ASimMatchingIpAddr != "No match"
  | lookup NetworkDirectionLookup on local_orig, local_resp
  | extend
      NetworkBytes = SrcBytes + DstBytes,
      NetworkPackets = SrcPackets + DstPackets,
      NetworkProtocol = toupper(NetworkProtocol)
  // Aliases
  | extend 
      IpAddr=SrcIpAddr,
      Src=SrcIpAddr,
      Duration=NetworkDuration,
      SessionId = NetworkSessionId,
      InnerVlanId = SrcVlanId,
      OuterVlanId = DstVlanId,
      Dst=DstIpAddr
  | project-away Message, local_orig, local_resp, conn_state
};
parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



