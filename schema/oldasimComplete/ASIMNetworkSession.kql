//
// Function Name: ASimNetworkSession
// Description: This ASIM parser supports normalizing Network Session logs from all supported sources to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSession(    ['pack']:bool=false)
{
let DisabledParsers=materialize(_GetWatchlist('ASimDisabledParsers') | where SearchKey in ('Any', 'ExcludeASimNetworkSession') | extend SourceSpecificParser=column_ifexists('SourceSpecificParser','') | distinct SourceSpecificParser);
let ASimBuiltInDisabled=toscalar('ExcludeASimNetworkSession' in (DisabledParsers) or 'Any' in (DisabledParsers)); 
let NetworkSessionsGeneric=(pack:bool=false){
union isfuzzy=true
  vimNetworkSessionEmpty
  , ASimNetworkSessionLinuxSysmon                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionLinuxSysmon'      in (DisabledParsers) ))
  
  , ASimNetworkSessionMicrosoft365Defender          (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMicrosoft365Defender'      in (DisabledParsers) ))
  , ASimNetworkSessionMD4IoTSensor                  (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMD4IoTSSensor'      in (DisabledParsers) ))
  , ASimNetworkSessionMD4IoTAgent                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMD4IoTAgent'      in (DisabledParsers) ))
  , ASimNetworkSessionMicrosoftWindowsEventFirewall (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMicrosoftWindowsEventFirewall'      in (DisabledParsers) ))
  , ASimNetworkSessionMicrosoftSecurityEventFirewall (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMicrosoftSecurityEventFirewall'      in (DisabledParsers) ))
  , ASimNetworkSessionPaloAltoCEF                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionPaloAltoCEF'      in (DisabledParsers) ))
  , ASimNetworkSessionVMConnection                  (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionVMConnection'      in (DisabledParsers) ))
  , ASimNetworkSessionAWSVPC                        (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionAWSVPC'      in (DisabledParsers) ))
  , ASimNetworkSessionAzureFirewall                 (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionAzureFirewall'      in (DisabledParsers) ))
  , ASimNetworkSessionAzureNSG                      (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionAzureNSG'      in (DisabledParsers) ))
  , ASimNetworkSessionVectraAI                      (pack=pack, disabled=(ASimBuiltInDisabled or ('ExcludeASimNetworkSessionVectraAI' in (DisabledParsers) )))
  , ASimNetworkSessionCiscoMeraki                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCiscoMeraki'      in (DisabledParsers) ))
  , ASimNetworkSessionCiscoMerakiSyslog                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCiscoMerakiSyslog'      in (DisabledParsers) ))
  , ASimNetworkSessionAppGateSDP                    (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionAppGateSDP'      in (DisabledParsers) ))
  , ASimNetworkSessionFortinetFortiGate             (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionFortinetFortiGate'      in (DisabledParsers) ))
  , ASimNetworkSessionCorelightZeek                 (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCorelightZeek'      in (DisabledParsers) ))
  , ASimNetworkSessionCheckPointFirewall            (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCheckPointFirewall'      in (DisabledParsers) ))
  , ASimNetworkSessionCiscoASA                      (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCiscoASA'      in (DisabledParsers) ))
  , ASimNetworkSessionWatchGuardFirewareOS          (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionWatchGuardFirewareOS'      in (DisabledParsers) ))
  , ASimNetworkSessionMicrosoftSysmon               (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMicrosoftSysmon'      in (DisabledParsers) ))
  , ASimNetworkSessionMicrosoftSysmonWindowsEvent               (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionMicrosoftSysmonWindowsEvent'      in (DisabledParsers) ))
  , ASimNetworkSessionForcePointFirewall            (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionForcePointFirewall'      in (DisabledParsers) ))
  , ASimNetworkSessionNative                        (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionNative'      in (DisabledParsers) ))
  , ASimNetworkSessionSentinelOne                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionSentinelOne'      in (DisabledParsers) ))
  , ASimNetworkSessionCiscoMeraki                   (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCiscoMeraki'      in (DisabledParsers) ))
  , ASimNetworkSessionCiscoISE                      (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCiscoISE'      in (DisabledParsers) ))
  , ASimNetworkSessionBarracudaWAF                  (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionBarracudaWAF'      in (DisabledParsers) ))
  , ASimNetworkSessionBarracudaCEF                  (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionBarracudaCEF'      in (DisabledParsers) ))
  , ASimNetworkSessionCiscoFirepower                (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCiscoFirepower'      in (DisabledParsers) ))
  , ASimNetworkSessionCrowdStrikeFalconHost         (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionCrowdStrikeFalconHost'      in (DisabledParsers) ))
  , ASimNetworkSessionVMwareCarbonBlackCloud        (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionVMwareCarbonBlackCloud'      in (DisabledParsers) ))
  , ASimNetworkSessionPaloAltoCortexDataLake        (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionPaloAltoCortexDataLake'      in (DisabledParsers) ))
  , ASimNetworkSessionSonicWallFirewall             (ASimBuiltInDisabled or ('ExcludeASimNetworkSessionSonicWallFirewall'      in (DisabledParsers) ))
};
NetworkSessionsGeneric (pack=pack)
}



//
// Function Name: ASimNetworkSessionAppGateSDP
// Description: This ASIM parser supports normalizing AppGate SDP logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionAppGateSDP(    ['disabled']:bool=false)
{
let parser = (disabled:bool=false) 
{
  let DirectionLookup = datatable (direction:string, NetworkDirection:string) 
  [
    'up', 'Inbound',
    'down', 'Outbound'
  ];
  let ActionLookup = datatable (DvcOriginalAction:string, DvcAction:string, EventSeverity:string, EventResult:string)
  [
    'allow', 'Allow', 'Informational', 'Success',
    'drop', 'Drop', 'Low', 'Failure',
    'reject', 'Deny', 'Low', 'Failure',
    'block', 'Deny', 'Low', 'Failure',
    'block_report', 'Deny', 'Low', 'Failure',
    'allow_report', 'Allow', 'Informational', 'Success'
  ];
  let tcpupd_success = Syslog
  | where 
    ProcessName in ("cz-sessiond", "cz-vpnd")
    and SyslogMessage has_all ("[AUDIT]","ip_access",'"rule_name"')
    and SyslogMessage has_any ('"protocol":"UDP"','"protocol":"TCP"') 
  | project TimeGenerated, SyslogMessage, Computer
  | extend type = extract (@'"event_type"\:\"(.*?)\"', 1,  SyslogMessage)
  | where type == "ip_access"
  | parse-where SyslogMessage with 
      *
      '"action":"' DvcOriginalAction:string '",' * 
      '"client_ip":"' SrcIpAddr:string '",' *
      '"client_port":' SrcPortNumber:int ',' *
      '"destination_ip":"' DstIpAddr:string '",' *
      '"destination_port":' DstPortNumber:int ',' *
      '"direction":"' direction:string '",' * 
      '"distinguished_name_device_id":"' SrcDvcId:string '",' *
      '"distinguished_name_user":"' SrcUsername:string '",' *
      '"entitlement_token_id":"' NetworkSessionId:string '",' *
      '"packet_size":' SrcBytes:long ',' *
      '"protocol":"' NetworkProtocol:string '",' *          
      '"rule_name":"' NetworkRuleName:string '",' *  
      '"source_ip":"' SrcNatIpAddr:string '",' *
      '"source_port":' SrcNatPortNumber:int ',' * 
      '"version":' EventProductVersion:string '}' *
  ;
  let tcpupd_fail = 
    Syslog
    | where 
      ProcessName in ("cz-sessiond", "cz-vpnd")
      and SyslogMessage has_all ("[AUDIT]","ip_access",'"drop-reason"')
      and SyslogMessage has_any ('"protocol":"UDP"','"protocol":"TCP"') 
    | project TimeGenerated, SyslogMessage, Computer
    | extend type = extract (@'"event_type"\:\"(.*?)\"', 1,  SyslogMessage)
    | where type == "ip_access"
    | parse-where SyslogMessage with 
        *
        '"action":"' DvcOriginalAction:string '",' * 
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"destination_port":' DstPortNumber:int ',' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"drop-reason":"' EventOriginalResultDetails:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"source_port":' SrcNatPortNumber:int ',' * 
        '"version":' EventProductVersion:string '}' *
     ;
  let icmp_success = Syslog
  | where 
    ProcessName in ("cz-sessiond", "cz-vpnd")
    and SyslogMessage has_all ("[AUDIT]","ip_access",'"protocol":"ICMP"') 
  | project TimeGenerated, SyslogMessage, Computer
  | extend type = extract (@'"event_type"\:\"(.*?)\"', 1,  SyslogMessage)
  | where type == "ip_access"
  | parse-where SyslogMessage with 
      *
      '"action":"' DvcOriginalAction:string '",' * 
      '"client_ip":"' SrcIpAddr:string '",' *
      '"client_port":' SrcPortNumber:int ',' *
      '"destination_ip":"' DstIpAddr:string '",' *
      '"direction":"' direction:string '",' * 
      '"distinguished_name_device_id":"' SrcDvcId:string '",' *
      '"distinguished_name_user":"' SrcUsername:string '",' *
      '"entitlement_token_id":"' NetworkSessionId:string '",' *
      '"icmp_code":' NetworkIcmpSubCode:int ',' *
      '"icmp_type":' NetworkIcmpCode:int ',' *  
      '"packet_size":' SrcBytes:long ',' *
      '"protocol":"' NetworkProtocol:string '",' *          
      '"rule_name":"' NetworkRuleName:string '",' *  
      '"source_ip":"' SrcNatIpAddr:string '",' *
      '"version":' EventProductVersion:string '}' *
  ;
  union  tcpupd_success, tcpupd_fail, icmp_success 
  | parse SyslogMessage with 
      *
      '"country_name":"' SrcGeoCountry:string '",' *
      '"lat":' SrcGeoLatitude:real ',' *        
      '"lon":' SrcGeoLongitude:real '}' *
  | parse SyslogMessage with 
       *
      '"city_name":"' SrcGeoCity:string '",' *
      '"region_name":"' SrcGeoRegion:string '",' *
  | extend 
      SrcDvcIdType = 'AppGateId',
      SrcUsernameType = 'UPN'
  // -- Event fields
  | project-rename 
      DvcHostname = Computer
  | extend 
      EventCount = int(1),
      EventEndTime = TimeGenerated,
      EventStartTime = TimeGenerated,
      EventSchema = 'NetworkSession',
      EventSchemaVersion = '0.2.3',
      EventVendor = 'AppGate',
      EventProduct = 'SDP',
      EventType = 'NetworkSession'
  | lookup DirectionLookup on direction
  | lookup ActionLookup on DvcOriginalAction
  // -- Aliases
  | extend 
      Src = SrcIpAddr,
      Dst = DstIpAddr,
      Dvc = DvcHostname,
      SessionId = NetworkSessionId,
      IpAddr = SrcIpAddr,
      Rule = NetworkRuleName,
  // -- Entity identifier explicit aliases
      SrcUserUpn = SrcUsername
  | project-away 
      SyslogMessage, type, direction
};
parser (disabled)
}



//
// Function Name: ASimNetworkSessionAWSVPC
// Description: This ASIM parser supports normalizing AWS VPC logs produced by the Microsoft Sentinel AWS S3 connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionAWSVPC(    ['disabled']:bool=false)
{
let ProtocolLookup = datatable(Protocol:int, NetworkProtocol:string) [
  0,"HOPOPT",
  1,"ICMP",
  2,"IGMP",
  3,"GGP",
  4,"IPv4",
  5,"ST",
  6,"TCP",
  7,"CBT",
  8,"EGP",
  9,"IGP",
  10,"BBN-RCC-MON",
  11,"NVP-II",
  12,"PUP",
  13,"ARGUS (deprecated)",
  14,"EMCON",
  15,"XNET",
  16,"CHAOS",
  17,"UDP",
  18,"MUX",
  19,"DCN-MEAS",
  20,"HMP",
  21,"PRM",
  22,"XNS-IDP",
  23,"TRUNK-1",
  24,"TRUNK-2",
  25,"LEAF-1",
  26,"LEAF-2",
  27,"RDP",
  28,"IRTP",
  29,"ISO-TP4",
  30,"NETBLT",
  31,"MFE-NSP",
  32,"MERIT-INP",
  33,"DCCP",
  34,"3PC",
  35,"IDPR",
  36,"XTP",
  37,"DDP",
  38,"IDPR-CMTP",
  39,"TP++",
  40,"IL",
  41,"IPv6",
  42,"SDRP",
  43,"IPv6-Route",
  44,"IPv6-Frag",
  45,"IDRP",
  46,"RSVP",
  47,"GRE",
  48,"DSR",
  49,"BNA",
  50,"ESP",
  51,"AH",
  52,"I-NLSP",
  53,"SWIPE (deprecated)",
  54,"NARP",
  55,"MOBILE",
  56,"TLSP",
  57,"SKIP",
  58,"IPv6-ICMP",
  59,"IPv6-NoNxt",
  60,"IPv6-Opts",
  61,"",
  62,"CFTP",
  63,"",
  64,"SAT-EXPAK",
  65,"KRYPTOLAN",
  66,"RVD",
  67,"IPPC",
  68,"",
  69,"SAT-MON",
  70,"VISA",
  71,"IPCV",
  72,"CPNX",
  73,"CPHB",
  74,"WSN",
  75,"PVP",
  76,"BR-SAT-MON",
  77,"SUN-ND",
  78,"WB-MON",
  79,"WB-EXPAK",
  80,"ISO-IP",
  81,"VMTP",
  82,"SECURE-VMTP",
  83,"VINES",
  84,"TTP",
  84,"IPTM",
  85,"NSFNET-IGP",
  86,"DGP",
  87,"TCF",
  88,"EIGRP",
  89,"OSPFIGP",
  90,"Sprite-RPC",
  91,"LARP",
  92,"MTP",
  93,"AX.25",
  94,"IPIP",
  95,"MICP (deprecated)",
  96,"SCC-SP",
  97,"ETHERIP",
  98,"ENCAP",
  99,"",
  100,"GMTP",
  101,"IFMP",
  102,"PNNI",
  103,"PIM",
  104,"ARIS",
  105,"SCPS",
  106,"QNX",
  107,"A/N",
  108,"IPComp",
  109,"SNP",
  110,"Compaq-Peer",
  111,"IPX-in-IP",
  112,"VRRP",
  113,"PGM",
  114,"",
  115,"L2TP",
  116,"DDX",
  117,"IATP",
  118,"STP",
  119,"SRP",
  120,"UTI",
  121,"SMP",
  122,"SM (deprecated)",
  123,"PTP",
  124,"ISIS over IPv4",
  125,"FIRE",
  126,"CRTP",
  127,"CRUDP",
  128,"SSCOPMCE",
  129,"IPLT",
  130,"SPS",
  131,"PIPE",
  132,"SCTP",
  133,"FC",
  134,"RSVP-E2E-IGNORE",
  135,"Mobility Header",
  136,"UDPLite",
  137,"MPLS-in-IP",
  138,"manet",
  139,"HIP",
  140,"Shim6",
  141,"WESP",
  142,"ROHC",
  143,"Ethernet",
  253,"",
  254,"",
  255,"Reserved"
];
let DirectionLookup = datatable (FlowDirection:string, NetworkDirection:string)  [
  'ingress', 'Inbound',
  'egress', 'Outbound'
];
let ActionLookup = datatable (Action:string, DvcAction:string)  [
  'ACCEPT', 'Allow',
  'REJECT', 'Deny'
];
let parser = (disabled:bool=false){
AWSVPCFlow | where not(disabled)
| where LogStatus == "OK"
| extend
    EventVendor="AWS", 
    EventProduct="VPC",
    NetworkBytes = tolong(Bytes),
    NetworkPackets = tolong(Packets),
    EventProductVersion = tostring(Version),
    EventType="NetworkSession",
    EventCount=toint(1),
    EventResult = iff (Action=="ACCEPT","Success","Failure"),
    EventSeverity = iff (Action=="ACCEPT","Informational","Low"),
    EventSchemaVersion="0.2.2",
    EventSchema="NetworkSession",
    SrcAppType = iff (PktSrcAwsService != "", "CloudService", ""),
    DstAppType = iff (PktDstAwsService != "", "CloudService", ""),
    DvcIdType = "AwsVpcId"
| lookup ProtocolLookup on Protocol
| lookup ActionLookup on Action
| lookup DirectionLookup on FlowDirection
| project-rename
    DstIpAddr = DstAddr,  
    DstPortNumber = DstPort, 
    SrcNatIpAddr=PktSrcAddr, 
    DstNatIpAddr=PktDstAddr, 
    SrcPortNumber = SrcPort, 
    SrcIpAddr = SrcAddr, 
    EventEndTime = End, 
    DvcInboundInterface = InterfaceId,
    DvcSubscriptionId = AccountId,
    DvcId = VpcId,
    NetworkProtocolVersion = TrafficType,
    EventOriginalResultDetails = LogStatus,
    SrcAppName = PktSrcAwsService,
    DstAppName = PktDstAwsService
// -- Aliases
| extend
    IpAddr = SrcIpAddr,
    Src = SrcIpAddr,
    Dst = DstIpAddr,
    Dvc = DvcId,
    EventStartTime = TimeGenerated,
    DvcInterface = DvcInboundInterface
| project-away Action, AzId, Bytes, FlowDirection, InstanceId, Packets, Protocol, Region, SourceSystem, SublocationId, SublocationType, SubnetId, TcpFlags, TenantId, TrafficPath, Version
};
parser (disabled)
}



//
// Function Name: ASimNetworkSessionAzureFirewall
// Description: This ASIM parser supports normalizing Azure Firewall logs to the ASIM Network Session normalized schema. This parser is partially based on a work by [Koos Goossens](https://github.com/TheCloudScout).

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionAzureFirewall(    ['disabled']:bool=false)
{
let parser = (disabled:bool=false) {
    let AzureFirewallNetworkRuleLogs = 
        AzureDiagnostics
        | where not(disabled)
        | where Category == "AzureFirewallNetworkRule"
        | where isnotempty(msg_s)
        | project msg_s, OperationName, SubscriptionId, ResourceId, TimeGenerated, Type, _ResourceId;
    let AzureFirewallSessionLogs = 
        AzureFirewallNetworkRuleLogs
        | where OperationName in ("AzureFirewallNetworkRuleLog","AzureFirewallThreatIntelLog")
        | parse-where
            msg_s with           NetworkProtocol:string 
            " request from "     SrcIpAddr:string
            ":"                  SrcPortNumber:int
            " to "               DstIpAddr:string
            ":"                  DstPortNumber:int
            ". Action: "         DvcAction:string
            "."                  *
        | project-away msg_s
        | extend NetworkIcmpCode = iff(NetworkProtocol startswith "ICMP", toint(extract ("type=(\\d+)",1,NetworkProtocol)), int(null))
        | extend NetworkIcmpType = iff(isnotnull(NetworkIcmpCode), _ASIM_LookupICMPType(NetworkIcmpCode), "")
        | extend NetworkProtocol = iff(NetworkProtocol startswith "ICMP", "ICMP", NetworkProtocol)
        | extend EventSeverity = case (
            OperationName  == "AzureFirewallThreatIntelLog", "Medium",
            DvcAction == "Deny", "Low",
            "Informational")
        | extend EventResult = iff(DvcAction == "Allow", "Success", "Failure")
        ;
    let AzureFirewallNATLogs = 
        AzureFirewallNetworkRuleLogs
        | where OperationName == "AzureFirewallNatRuleLog"
        | parse-where
            msg_s with           NetworkProtocol:string 
            " request from "     SrcIpAddr:string
            ":"                  SrcPortNumber:int
            " to "               DstIpAddr:string
            ":"                  DstPortNumber:int
            " was DNAT'ed to "   DstNatIpAddr:string
            ":"                  DstNatPortNumber:int
        | project-away msg_s
        | extend EventSeverity = "Informational"
        | extend EventResult = "Success"
        | extend DvcAction = "Allow"
        ;
    union AzureFirewallSessionLogs, AzureFirewallNATLogs
    | extend
        EventVendor="Microsoft",
        EventProduct="Azure Firewall",
        EventType="NetworkSession",
        EventCount=toint(1),
        EventSchemaVersion="0.2.2",
        EventSchema="NetworkSession",
        DvcIdType = "AzureResourceId"
    | project-rename
        DvcSubscriptionId = SubscriptionId,
        DvcId = ResourceId
    // -- Aliases
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Dvc = DvcId,
        EventStartTime = TimeGenerated,
        EventEndTime = TimeGenerated
    | project-keep
        Src*,
        Dst*,
        Event*,
        Dvc*,
        Network*,
        IpAddr,
        Type,
        _ResourceId,
        TimeGenerated
};
parser (disabled)
}



//
// Function Name: ASimNetworkSessionAzureNSG
// Description: This ASIM parser supports normalizing Azure Network Security Groups (NSG) flows to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionAzureNSG(    ['disabled']:bool=false)
{
let DvcActionLookup = datatable(FlowStatus_s:string, DvcAction:string, EventResult:string) [
    'A', 'Allow', 'Success',
    'D', 'Deny', 'Failure',
];
let NetworkDirectionLookup = datatable(FlowDirection_s:string, NetworkDirection:string, isOutBound:bool) [
    'I', 'Inbound', false,
    'O', 'Outbound', true
];
let NetworkProtocolLookup = datatable(L4Protocol_s:string, NetworkProtocol:string)[
    'T', 'TCP',
    'U', 'UDP'
];
let parser = (disabled:bool=false) 
{
  let AzureNetworkAnalytics = (FlowDirection: string) {
    AzureNetworkAnalytics_CL
    | where not(disabled) and isnotempty(FlowType_s)
    | where FlowDirection == FlowDirection_s
    | lookup NetworkDirectionLookup on FlowDirection_s
  };
  let AzureNetworkAnalyticsInbound =
    AzureNetworkAnalytics ('I')
    | where not(isOutBound)
    | project-rename
        DstMacAddr = MACAddress_s
    | extend
        DstBytes = tolong(OutboundBytes_d), // -- size fields seem not to be populated for inbound
        DstPackets = tolong(OutboundPackets_d),
        SrcBytes = tolong(InboundBytes_d),
        SrcPackets = tolong(InboundPackets_d),
        SrcInterfaceName = tostring(split(NIC_s, '/')[1]),
        SrcGeoCountry = toupper(Country_s)
    | extend hostelements=split(VM2_s,'/')
    | extend 
        DstFQDN = strcat(hostelements[0], @"\", hostelements[1]),
        DstHostname = tostring(hostelements[1]),
        DstDomain = tostring(hostelements[0]),
        DstDomainType = "ResourceGroup"
    | extend Hostname = DstHostname
    | project-away hostelements, isOutBound
  ;  
  let AzureNetworkAnalyticsOutbound =
    AzureNetworkAnalytics ('O')
    | where isOutBound
    | project-rename
        SrcMacAddr = MACAddress_s
    | extend
        SrcBytes = tolong(OutboundBytes_d), 
        SrcPackets = tolong(OutboundPackets_d),
        DstBytes = tolong(InboundBytes_d),
        DstPackets = tolong(InboundPackets_d),
        DstInterfaceName = tostring(split(NIC_s, '/')[1]),
        DstGeoCountry = toupper(Country_s)
    | extend hostelements=split(VM1_s,'/')
    | extend 
        SrcFQDN = strcat(hostelements[0], @"\", hostelements[1]),
        SrcHostname = tostring(hostelements[1]),
        SrcDomain = tostring(hostelements[0]),
        SrcDomainType = "ResourceGroup"
    | extend Hostname = SrcHostname
    | project-away hostelements, isOutBound
  ;
  union AzureNetworkAnalyticsInbound, AzureNetworkAnalyticsOutbound
  | project-rename
      Dvc = NSGList_s,
      DvcSubscriptionId = Subscription_g,
      EventEndTime = FlowEndTime_t,
      EventStartTime = FlowStartTime_t,
      NetworkApplicationProtocol = L7Protocol_s,
      NetworkRuleName = NSGRule_s,
      NetworkSessionId = ConnectionName_s,
      EventOriginalSubType = FlowType_s
  | extend
      DstPortNumber = toint(DestPort_d),
      EventProduct = 'NSGFlow',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.2',
      EventSeverity = 'Informational', //??
      EventType = 'Flow',
      EventVendor = 'Microsoft',
      EventCount = toint(AllowedInFlows_d+DeniedInFlows_d+AllowedOutFlows_d+DeniedOutFlows_d),
      NetworkDuration = toint((((EventEndTime - datetime(1970-01-01)) / 1s) - ((EventStartTime - datetime(1970-01-01)) / 1s )) * 1000),
      Rule = NetworkRuleName,
      SessionId = NetworkSessionId
  | lookup DvcActionLookup on FlowStatus_s
  | extend 
      DstIpAddr = iff(isnotempty(DestIP_s),
                      DestIP_s,
                      split(DestPublicIPs_s, '|')[0]),
      Duration = NetworkDuration,
      NetworkBytes = tolong(DstBytes + SrcBytes),
      NetworkPackets = tolong(DstPackets + SrcPackets),
      SrcIpAddr = iff(isnotempty(SrcIP_s),
                      SrcIP_s,
                      split(SrcPublicIPs_s, '|')[0])
  | extend
      Dst = DstIpAddr,
      IpAddr = SrcIpAddr,
      Src = SrcIpAddr
  | lookup NetworkProtocolLookup on L4Protocol_s
  | project-keep
      Src*,
      Dst*,
      Event*,
      Dvc*,
      Network*,
      IpAddr,
      Hostname,
      Type,
      Duration,
      SessionId,
      _ResourceId,
      TimeGenerated
  | project-away *_s
  };
parser (disabled)
}



//
// Function Name: ASimNetworkSessionBarracudaCEF
// Description: This ASIM parser supports normalizing Barracuda WAF logs ingested in 'CommonSecurityLog' table to the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionBarracudaCEF(    ['disabled']:bool=false)
{
let barracudaSchema = datatable(
    UnitName_s: string,
    DeviceReceiptTime_s: string,
    ActionID_s: string,
    DestinationIP_s: string,
    SourceIP: string,
    host_s: string,
    HostIP_s: string,
    Severity_s: string,
    LogType_s: string,
    DestinationPort_d: real,
    SourcePort_d: real,
    Protocol_s: string,
    DeviceVersion_s: string,
    TimeTaken_d: real,
    _ResourceId: string,
    RawData: string,
    Message: string,
    Computer: string,
    MG: string,
    ManagementGroupName: string,
    TenantId: string,
    SourceSystem: string
)[];
let ProtocolLookup = datatable(
    Protocol_s: string,
    NetworkProtocol: string,
    NetworkProtocolVersion: string
)[
    "TCP", "TCP", "",
    "TCP/ip", "TCP", "",
    "UDP", "UDP", "",
    "UDP/ip", "UDP", "",
    "ICMP", "ICMP", "IPV4",
    "ICMPv6", "ICMP", "IPV6",
];
let SeverityLookup = datatable (severity: int, EventSeverity: string)
    [
    0, "High",
    1, "High",
    2, "High",
    3, "Medium",
    4, "Low",
    5, "Low",
    6, "Informational",
    7, "Informational"
];
let EventResultLookup = datatable (
    ActionID_s: string,
    EventResult: string,
    DvcAction: string
)
    [
    "ALLOW", "Success", "Allow",
    "DENY", "Failure", "Deny"
];
let parser = (disabled: bool=false)
{
let BarracudaCEF = 
    CommonSecurityLog
    | where not(disabled) and DeviceVendor startswith "Barracuda" and (DeviceProduct == "WAF" or DeviceProduct == "WAAS")
    | where DeviceEventCategory == "NF"
    | extend
        severity = toint(LogSeverity)
    | lookup EventResultLookup on $left.DeviceAction == $right.ActionID_s
    | lookup SeverityLookup on severity
    | lookup ProtocolLookup on $left.Protocol == $right.Protocol_s
    | extend
        EventCount = toint(1),
        EventProduct = "WAF",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventVendor = "Barracuda"
    | extend
        Dvc =  DeviceName,
        EventStartTime = iff(isnotempty(FlexNumber2), unixtime_milliseconds_todatetime(tolong(ReceiptTime)-tolong(FlexNumber2)), unixtime_milliseconds_todatetime(tolong(ReceiptTime))),
        DstIpAddr = DestinationIP,
        SrcIpAddr = SourceIP,
        DvcHostname = DeviceName,
        DvcIpAddr = DestinationIP,
        DstPortNumber = toint(DestinationPort),
        SrcPortNumber = toint(SourcePort),
        EventUid = _ItemId,
        EventProductVersion = DeviceVersion
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        EventEndTime = EventStartTime
    | project-away
        ThreatConfidence,
        CommunicationDirection,
        AdditionalExtensions,
        Device*,
        Source*,
        Destination*,
        Activity,
        LogSeverity,
        ApplicationProtocol,
        ProcessID,
        ExtID,
        Protocol,
        Reason,
        ReceiptTime,
        SimplifiedDeviceAction,
        OriginalLogSeverity,
        ProcessName,
        EndTime,
        ExternalID,
        File*,
        ReceivedBytes,
        Message,
        Old*,
        EventOutcome,
        Request*,
        StartTime,
        Field*,
        Flex*,
        Remote*,
        Malicious*,
        severity,
        ThreatSeverity,
        IndicatorThreatType,
        ThreatDescription,
        _ResourceId,
        SentBytes,
        ReportReferenceLink,
        Computer,
        TenantId,CollectorHostName;
BarracudaCEF
};
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionBarracudaWAF
// Description: This ASIM parser supports normalizing Barracuda WAF logs ingested in 'barracuda_CL' tablet o the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionBarracudaWAF(    ['disabled']:bool=false)
{
let barracudaSchema = datatable(
    UnitName_s: string,
    DeviceReceiptTime_s: string,
    ActionID_s: string,
    DestinationIP_s: string,
    SourceIP: string,
    host_s: string,
    HostIP_s: string,
    Severity_s: string,
    LogType_s: string,
    DestinationPort_d: real,
    SourcePort_d: real,
    Protocol_s: string,
    DeviceVersion_s: string,
    TimeTaken_d: real,
    _ResourceId: string,
    RawData: string,
    Message: string,
    Computer: string,
    MG: string,
    ManagementGroupName: string,
    TenantId: string,
    SourceSystem: string
)[];
let ProtocolLookup = datatable(
    Protocol_s: string,
    NetworkProtocol: string,
    NetworkProtocolVersion: string
)[
    "TCP", "TCP", "",
    "TCP/ip", "TCP", "",
    "UDP", "UDP", "",
    "UDP/ip", "UDP", "",
    "ICMP", "ICMP", "IPV4",
    "ICMPv6", "ICMP", "IPV6",
];
let SeverityLookup = datatable (severity: int, EventSeverity: string)
    [
    0, "High",
    1, "High",
    2, "High",
    3, "Medium",
    4, "Low",
    5, "Low",
    6, "Informational",
    7, "Informational"
];
let EventResultLookup = datatable (
    ActionID_s: string,
    EventResult: string,
    DvcAction: string
)
    [
    "ALLOW", "Success", "Allow",
    "DENY", "Failure", "Deny"
];
let parser = (disabled: bool=false)
{
let BarracudaCustom = 
    union isfuzzy=true
        barracudaSchema,
        barracuda_CL
    | where not(disabled) and LogType_s == "NF"
    | extend
        severity = toint(Severity_s)
    | lookup EventResultLookup on ActionID_s
    | lookup SeverityLookup on severity
    | lookup ProtocolLookup on Protocol_s
    | extend
        EventCount = toint(1),
        EventProduct = "WAF",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventVendor = "Barracuda"
    | extend
        Dvc =  UnitName_s,
        EventStartTime = iff(isnotempty(TimeTaken_d), unixtime_milliseconds_todatetime(tolong(DeviceReceiptTime_s)-tolong(TimeTaken_d)), unixtime_milliseconds_todatetime(tolong(DeviceReceiptTime_s))),
        DstIpAddr = DestinationIP_s,
        SrcIpAddr = SourceIP,
        DvcHostname = host_s,
        DvcIpAddr = HostIP_s,
        DstPortNumber = toint(DestinationPort_d),
        SrcPortNumber = toint(SourcePort_d),
        EventUid = _ItemId,
        EventProductVersion = DeviceVersion_s
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        EventEndTime = EventStartTime
    | project-away
        *_d,
        *_s,
        _ResourceId,
        severity,
        RawData,
        SourceIP,
        Message,
        Computer,
        MG,
        ManagementGroupName,
        TenantId,
        SourceSystem;
BarracudaCustom
 };
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCheckPointFirewall
// Description: This ASIM parser supports normalizing Check Point VPN-1 & Firewall-1 logs coming from CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCheckPointFirewall(    ['disabled']:bool=false)
{
let ProtocolLookup=datatable(Protocol:string,NetworkProtocol:string)
    [
        "0","HOPOPT"
        , "1","ICMP"
        , "2","IGMP"
        , "3","GGP"
        , "4","IPv4"
        , "5","ST"
        , "6","TCP"
        , "7","CBT"
        , "8","EGP"
        , "9","IGP"
        , "10","BBN-RCC-MON"
        , "11","NVP-II"
        , "12","PUP"
        , "13","ARGUS (deprecated)"
        , "14","EMCON"
        , "15","XNET"
        , "16","CHAOS"
        , "17","UDP"
        , "18","MUX"
        , "19","DCN-MEAS"
        , "20","HMP"
        , "21","PRM"
        , "22","XNS-IDP"
        , "23","TRUNK-1"
        , "24","TRUNK-2"
        , "25","LEAF-1"
        , "26","LEAF-2"
        , "27","RDP"
        , "28","IRTP"
        , "29","ISO-TP4"
        , "30","NETBLT"
        , "31","MFE-NSP"
        , "32","MERIT-INP"
        , "33","DCCP"
        , "34","3PC"
        , "35","IDPR"
        , "36","XTP"
        , "37","DDP"
        , "38","IDPR-CMTP"
        , "39","TP++"
        , "40","IL"
        , "41","IPv6"
        , "42","SDRP"
        , "43","IPv6-Route"
        , "44","IPv6-Frag"
        , "45","IDRP"
        , "46","RSVP"
        , "47","GRE"
        , "48","DSR"
        , "49","BNA"
        , "50","ESP"
        , "51","AH"
        , "52","I-NLSP"
        , "53","SWIPE (deprecated)"
        , "54","NARP"
        , "55","MOBILE"
        , "56","TLSP"
        , "57","SKIP"
        , "58","IPv6-ICMP"
        , "59","IPv6-NoNxt"
        , "60","IPv6-Opts"
        , "61",""
        , "62","CFTP"
        , "63",""
        , "64","SAT-EXPAK"
        , "65","KRYPTOLAN"
        , "66","RVD"
        , "67","IPPC"
        , "68",""
        , "69","SAT-MON"
        , "70","VISA"
        , "71","IPCV"
        , "72","CPNX"
        , "73","CPHB"
        , "74","WSN"
        , "75","PVP"
        , "76","BR-SAT-MON"
        , "77","SUN-ND"
        , "78","WB-MON"
        , "79","WB-EXPAK"
        , "80","ISO-IP"
        , "81","VMTP"
        , "82","SECURE-VMTP"
        , "83","VINES"
        , "84","TTP"
        , "84","IPTM"
        , "85","NSFNET-IGP"
        , "86","DGP"
        , "87","TCF"
        , "88","EIGRP"
        , "89","OSPFIGP"
        , "90","Sprite-RPC"
        , "91","LARP"
        , "92","MTP"
        , "93","AX.25"
        , "94","IPIP"
        , "95","MICP (deprecated)"
        , "96","SCC-SP"
        , "97","ETHERIP"
        , "98","ENCAP"
        , "99",""
        , "100","GMTP"
        , "101","IFMP"
        , "102","PNNI"
        , "103","PIM"
        , "104","ARIS"
        , "105","SCPS"
        , "106","QNX"
        , "107","A/N"
        , "108","IPComp"
        , "109","SNP"
        , "110","Compaq-Peer"
        , "111","IPX-in-IP"
        , "112","VRRP"
        , "113","PGM"
        , "114",""
        , "115","L2TP"
        , "116","DDX"
        , "117","IATP"
        , "118","STP"
        , "119","SRP"
        , "120","UTI"
        , "121","SMP"
        , "122","SM (deprecated)"
        , "123","PTP"
        , "124","ISIS over IPv4"
        , "125","FIRE"
        , "126","CRTP"
        , "127","CRUDP"
        , "128","SSCOPMCE"
        , "129","IPLT"
        , "130","SPS"
        , "131","PIPE"
        , "132","SCTP"
        , "133","FC"
        , "134","RSVP-E2E-IGNORE"
        , "135","Mobility Header"
        , "136","UDPLite"
        , "137","MPLS-in-IP"
        , "138","manet"
        , "139","HIP"
        , "140","Shim6"
        , "141","WESP"
        , "142","ROHC"
        , "143","Ethernet"
        , "253",""
        , "254",""
        , "255","Reserved"];
    let DirectionLookup=datatable(conn_direction:string,NetworkDirection:string)
    [
        "Incoming","Inbound", 
        "Outgoing","Outbound", 
        "Internal","Local"];
    let ActionLookup=datatable(DeviceAction:string,DvcAction:string,EventResult:string,EventSeverity:string)
    [
        "Accept","Allow","Success","Informational",
        "Allow","Allow","Success","Informational",
        "Drop","Drop","Failure","Low",
        "Reject","Deny","Failure","Low",
        "Encrypt","Encrypt","Success","Informational",
        "Decrypt","Decrypt","Success","Informational",
        "Bypass","Allow","Success","Informational",
        "Block","Deny","Failure","Low",
        "","","NA","Informational"
     ];
      let NWParser=(disabled:bool=false)
      {
      CommonSecurityLog
      | where not(disabled)
      | where DeviceVendor=="Check Point" and DeviceProduct=="VPN-1 & FireWall-1"
      | lookup ActionLookup on DeviceAction
      | lookup ProtocolLookup on Protocol
      | extend 
              EventProduct = "Firewall",
              EventCount = toint(1),
              EventType = "NetworkSession",
              EventSchema = "NetworkSession",
              EventSchemaVersion = "0.2.4"
      | parse-kv AdditionalExtensions as (
                  rule_uid:string,
                  loguid:string,
                  origin:string,
                  originsicname:string,
                  inzone:string,
                  outzone:string,
                  conn_direction:string,
                  alert:string,
                  inspection_category:string,
                  inspection_item:string
              ) with (pair_delimiter=';', kv_delimiter='=')
      | extend
              ThreatCategory = coalesce(alert, inspection_category),
              NetworkRuleName = coalesce(DeviceCustomString2, rule_uid, Activity),
              EventStartTime = TimeGenerated
      | parse originsicname with "CN\\=" DvcHostname "," *
      | project-rename
              Dvc = origin,                
              EventOriginalUid = loguid,
              ThreatName = inspection_item,
              EventVendor = DeviceVendor,
              DstPortNumber = DestinationPort,
              DstIpAddr = DestinationIP,
              SrcPortNumber = SourcePort,
              SrcIpAddr = SourceIP,
              DstNatIpAddr = DestinationTranslatedAddress,
              DstNatPortNumber = DestinationTranslatedPort,
              SrcNatIpAddr = SourceTranslatedAddress,
              SrcNatPortNumber = SourceTranslatedPort,
              EventProductVersion = DeviceVersion,
              EventOriginalSeverity = LogSeverity,
              Rule = NetworkRuleName,
              DvcOriginalAction = DeviceAction,
              DstAppName = Activity,
              EventMessage = Message
      | lookup DirectionLookup on conn_direction
      | extend 
              EventEndTime = EventStartTime,
              IpAddr = SrcIpAddr,
              Dst = DstIpAddr,
              Src = SrcIpAddr,
              NetworkDirection = case(
                                  isnotempty(NetworkDirection), NetworkDirection,
                                  inzone == "Internal" and (outzone == "Internal" or outzone == "Local"), "Local",
                                  (inzone == "Internal" or inzone == "Local") and outzone == "External", "Outbound",
                                  inzone == "External" and (outzone == "Internal" or outzone == "Local"), "Inbound",
                                  CommunicationDirection == "0", "Inbound",
                                  CommunicationDirection == "1", "Outbound",
                                  ""
                                  ),
              EventSeverity = iif(isnotempty(ThreatCategory),"High",EventSeverity),
              NetworkIcmpType = coalesce(
                                      tostring(column_ifexists("FieldDeviceCustomNumber2", long(null))),
                                      tostring(column_ifexists("DeviceCustomNumber2",long(null)))
                                      ),
              NetworkIcmpCode = coalesce(
                                      toint(column_ifexists("FieldDeviceCustomNumber3", long(null))),
                                      toint(column_ifexists("DeviceCustomNumber3",long(null)))
                                      )
      | project-away ApplicationProtocol, AdditionalExtensions, CommunicationDirection, Computer, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, ReceivedBytes, Remote*, ReportReferenceLink, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, rule_uid, originsicname, inzone, outzone, alert, conn_direction, inspection_category, ExtID, EventOutcome, FieldDevice*, Reason
    };
    NWParser (disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCiscoASA
// Description: This ASIM parser supports normalizing commonly used Cisco ASA messages collected using the CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCiscoASA(    ['disabled']:bool=false)
{
let EventResultMapping = datatable (Reason:string, DvcAction:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string)  [
    'Conn-timeout', '', 'Success', 'Timeout', 'The connection ended when a flow is closed because of the expiration of its inactivity timer.',
    'Deny Terminate', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by application inspection.',
    'Failover primary closed', '', 'Success', 'Failover', 'The standby unit in a failover pair deleted a connection because of a message received from the active unit.',
    'FIN Timeout', '', 'Success', 'Timeout', 'Force termination after 10 minutes awaiting the last ACK or after half-closed timeout.',  
    'Flow closed by inspection', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by the inspection feature.',
    'Flow terminated by IPS', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by IPS.',
    'Flow reset by IPS', 'Reset', 'Failure', 'Terminated', 'Flow was reset by IPS.',     
    'Flow terminated by TCP Intercept', 'TCP Intercept', 'Failure', 'Terminated', 'Flow was terminated by TCP Intercept.',
    'Flow timed out', '', 'Success', 'Timeout', 'Flow has timed out.',
    'Flow timed out with reset', 'Reset', 'Failure', 'Timeout', 'Flow has timed out, but was reset.',
    'Free the flow created as result of packet injection', '', 'Success', 'Simulation', 'The connection was built because the packet tracer feature sent a simulated packet through the Secure Firewall ASA.',
    'Invalid SYN', '', 'Failure', 'Invalid TCP', 'The SYN packet was not valid.',
    'IPS fail-close', 'Deny', 'Failure', 'Terminated', 'Flow was terminated because the IPS card is down.',
    'No interfaces associated with zone', '', 'Failure', 'Routing issue', 'Flows were torn down after the "no nameif" or "no zone-member" leaves a zone with no interface members.',
    'No valid adjacency', 'Drop', 'Failure', 'Routing issue', 'This counter is incremented when the Secure Firewall ASA tried to obtain an adjacency and could not obtain the MAC address for the next hop. The packet is dropped.',
    'Pinhole Timeout', '', 'Failure', 'Timeout', 'The counter is incremented to report that the Secure Firewall ASA opened a secondary flow, but no packets passed through this flow within the timeout interval, and so it was removed. An example of a secondary flow is the FTP data channel that is created after successful negotiation on the FTP control channel.',
    'Probe maximum retries of retransmission exceeded', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the TCP packet exceeded maximum probe retries of retransmission.',
    'Probe maximum retransmission time elapsed', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the maximum probing time for TCP packet had elapsed.',
    'Probe received RST', '', 'Failure', 'Reset', 'The connection was torn down because probe connection received RST from server.',
    'Probe received FIN', '', 'Success', '', 'The connection was torn down because probe connection received FIN from server and complete FIN closure process was completed.',
    'Probe completed', '', 'Success', '', 'The probe connection was successful.', 
    'Route change', '', 'Success', '', 'When the Secure Firewall ASA adds a lower cost (better metric) route, packets arriving that match the new route cause their existing connection to be torn down after the user-configured timeout (floating-conn) value. Subsequent packets rebuild the connection out of the interface with the better metric. To prevent the addition of lower cost routes from affecting active flows, you can set the floating-conn configuration timeout value to 0:0:0.', 
    'SYN Control', '', 'Failure', 'Invalid TCP', 'A back channel initiation occurred from the wrong side.',
    'SYN Timeout', '', 'Failure', 'Timeout', 'Force termination after 30 seconds, awaiting three-way handshake completion.',
    'TCP bad retransmission', '', 'Success', 'Invalid TCP', 'The connection was terminated because of a bad TCP retransmission.',
    'TCP FINs', '', 'Success', '', 'A normal close-down sequence occurred.',
    'TCP Invalid SYN', '', 'Failure', 'Invalid TCP', 'Invalid TCP SYN packet.',              
    'TCP Reset-APPLIANCE', '', 'Failure', 'Reset', 'The flow is closed when a TCP reset is generated by the Secure Firewall ASA.',
    'TCP Reset-I', '', 'Failure', 'Reset', 'Reset was from the inside.',
    'TCP Reset-O', '', 'Failure', 'Reset', 'Reset was from the outside.',
    'TCP segment partial overlap', '', 'Failure', 'Invalid TCP', 'A partially overlapping segment was detected.',
    'TCP unexpected window size variation', '', 'Failure', 'Invalid TCP', 'A connection was terminated due to variation in the TCP window size.',  
    'Tunnel has been torn down', '', 'Failure', 'Invalid Tunnel', 'Flow was terminated because the tunnel is down.',
    'Unknown', 'Deny', 'Failure', 'Terminated', 'An authorization was denied by a URL filter.', 'Unauth Deny', '', 'Failure', 'Unknown', 'An unknown error has occurred.',               
    'Xlate Clear', '', '', '', 'A command line was removed.',
];
let ProtocolLookup=datatable(Protocol:string,NetworkProtocol:string)[
      "0","HOPOPT"
      , "1","ICMP"
      , "2","IGMP"
      , "3","GGP"
      , "4","IPv4"
      , "5","ST"
      , "6","TCP"
      , "7","CBT"
      , "8","EGP"
      , "9","IGP"
      , "10","BBN-RCC-MON"
      , "11","NVP-II"
      , "12","PUP"
      , "13","ARGUS (deprecated)"
      , "14","EMCON"
      , "15","XNET"
      , "16","CHAOS"
      , "17","UDP"
      , "18","MUX"
      , "19","DCN-MEAS"
      , "20","HMP"
      , "21","PRM"
      , "22","XNS-IDP"
      , "23","TRUNK-1"
      , "24","TRUNK-2"
      , "25","LEAF-1"
      , "26","LEAF-2"
      , "27","RDP"
      , "28","IRTP"
      , "29","ISO-TP4"
      , "30","NETBLT"
      , "31","MFE-NSP"
      , "32","MERIT-INP"
      , "33","DCCP"
      , "34","3PC"
      , "35","IDPR"
      , "36","XTP"
      , "37","DDP"
      , "38","IDPR-CMTP"
      , "39","TP++"
      , "40","IL"
      , "41","IPv6"
      , "42","SDRP"
      , "43","IPv6-Route"
      , "44","IPv6-Frag"
      , "45","IDRP"
      , "46","RSVP"
      , "47","GRE"
      , "48","DSR"
      , "49","BNA"
      , "50","ESP"
      , "51","AH"
      , "52","I-NLSP"
      , "53","SWIPE (deprecated)"
      , "54","NARP"
      , "55","MOBILE"
      , "56","TLSP"
      , "57","SKIP"
      , "58","IPv6-ICMP"
      , "59","IPv6-NoNxt"
      , "60","IPv6-Opts"
      , "61",""
      , "62","CFTP"
      , "63",""
      , "64","SAT-EXPAK"
      , "65","KRYPTOLAN"
      , "66","RVD"
      , "67","IPPC"
      , "68",""
      , "69","SAT-MON"
      , "70","VISA"
      , "71","IPCV"
      , "72","CPNX"
      , "73","CPHB"
      , "74","WSN"
      , "75","PVP"
      , "76","BR-SAT-MON"
      , "77","SUN-ND"
      , "78","WB-MON"
      , "79","WB-EXPAK"
      , "80","ISO-IP"
      , "81","VMTP"
      , "82","SECURE-VMTP"
      , "83","VINES"
      , "84","TTP"
      , "84","IPTM"
      , "85","NSFNET-IGP"
      , "86","DGP"
      , "87","TCF"
      , "88","EIGRP"
      , "89","OSPFIGP"
      , "90","Sprite-RPC"
      , "91","LARP"
      , "92","MTP"
      , "93","AX.25"
      , "94","IPIP"
      , "95","MICP (deprecated)"
      , "96","SCC-SP"
      , "97","ETHERIP"
      , "98","ENCAP"
      , "99",""
      , "100","GMTP"
      , "101","IFMP"
      , "102","PNNI"
      , "103","PIM"
      , "104","ARIS"
      , "105","SCPS"
      , "106","QNX"
      , "107","A/N"
      , "108","IPComp"
      , "109","SNP"
      , "110","Compaq-Peer"
      , "111","IPX-in-IP"
      , "112","VRRP"
      , "113","PGM"
      , "114",""
      , "115","L2TP"
      , "116","DDX"
      , "117","IATP"
      , "118","STP"
      , "119","SRP"
      , "120","UTI"
      , "121","SMP"
      , "122","SM (deprecated)"
      , "123","PTP"
      , "124","ISIS over IPv4"
      , "125","FIRE"
      , "126","CRTP"
      , "127","CRUDP"
      , "128","SSCOPMCE"
      , "129","IPLT"
      , "130","SPS"
      , "131","PIPE"
      , "132","SCTP"
      , "133","FC"
      , "134","RSVP-E2E-IGNORE"
      , "135","Mobility Header"
      , "136","UDPLite"
      , "137","MPLS-in-IP"
      , "138","manet"
      , "139","HIP"
      , "140","Shim6"
      , "141","WESP"
      , "142","ROHC"
      , "143","Ethernet"
      , "253",""
      , "254",""
      , "255","Reserved"
  ];
  let ActionResultLookup = datatable (DeviceEventClassID:string, DvcAction:string, EventResult:string)[
        "106001", "Deny", "Failure",
        "106002", "Deny", "Failure",
        "106006", "Deny", "Failure",
        "106007", "Deny", "Failure",
        "106010", "Deny", "Failure",
        "106012", "Deny", "Failure",
        "106013", "Drop", "Failure",
        "106014", "Deny", "Failure",
        "106015", "Deny", "Failure",
        "106016", "Deny", "Failure",
        "106017", "Deny", "Failure",
        "106018", "Deny", "Failure",
        "106020", "Deny", "Failure",
        "106021", "Deny", "Failure",
        "106022", "Deny", "Failure",
        "106023", "Deny", "Failure",
        "106100", "", "",
        "302013", "Allow", "Success",
        "302014", "", "", 
        "302015", "Allow", "Success",
        "302016", "Allow", "Success",
        "302020", "Allow", "Success",
        "302021", "Allow", "Success",
        "710002", "Allow", "Success",
        "710003", "Deny", "Failure",
        "710004", "Drop", "Failure",
        "710005", "Drop", "Failure",
  ];
  let NWParser = (disabled:bool=false)
    { 
  let allLogs = CommonSecurityLog
            | where not(disabled)
            | where DeviceVendor == "Cisco" and DeviceProduct == "ASA"
            | where DeviceEventClassID in ("106001","106006","106015","106016","106021","106022","106010","106014","106018","106023","302013","302015","302014","302016","302020","302021","710002","710003","710004","710005","106007","106017","106100","106002","106012","106013","106020")
            | lookup ActionResultLookup on DeviceEventClassID
            | project DeviceVendor, DeviceProduct, DeviceEventClassID, LogSeverity, OriginalLogSeverity, Computer, CommunicationDirection, DestinationIP, DestinationPort, DeviceAddress, DeviceName, Message, Protocol, SourceIP, SourcePort, DeviceVersion, DeviceCustomString2, DvcAction, EventResult, TimeGenerated, DeviceAction;
  let parsedData = allLogs
            | where isnotempty(SourceIP)
            | project-rename NetworkRuleName = DeviceCustomString2,
                             SrcIpAddr = SourceIP,
                             SrcPortNumber = SourcePort,
                             DstIpAddr = DestinationIP, 
                             DstPortNumber = DestinationPort;
  let unparsedData = allLogs
            | where isempty(SourceIP)
            | project DeviceVendor, DeviceProduct, DeviceEventClassID, LogSeverity, OriginalLogSeverity, Computer, DeviceAddress, DeviceName, Message, DeviceVersion, Protocol, DvcAction, EventResult, TimeGenerated, DeviceAction;
  let all_106001_alike = parsedData
            | where DeviceEventClassID in ("106001", "106006", "106015", "106016", "106021", "106022") 
            | parse Message with * " interface " DstInterfaceName;
  let all_106010_alike = parsedData
            | where DeviceEventClassID in ("106010", "106014")
            | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")";
  let all_106018 = parsedData
            | where DeviceEventClassID == "106018"
            | parse Message with * " packet type " NetworkIcmpType " " * "list " NetworkRuleName " " *;
  let all_106023 = parsedData
            | where DeviceEventClassID == "106023" and not(Message has "protocol 41")
            | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * ' by access-group "' NetworkRuleName '" '  *
            | parse Message with * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")" *;
  let all_106023_unparsed = unparsedData
            | where DeviceEventClassID == "106023" and not(Message has "protocol 41")
            | parse Message with * ":" DeviceAction " " Protocol " src " SrcInterfaceName ":" SrcIpAddrAndPort "(" SrcUsername ") dst " DstInterfaceName ":" DstIpAddrAndPort " " NetworkIcmpInfo 'by access-group "' NetworkRuleName '" [' * "]"
            | parse NetworkIcmpInfo with "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ") "
            | extend SrcIpAddrAndPort = split(SrcIpAddrAndPort,"/"), DstIpAddrAndPort = split(DstIpAddrAndPort,"/")
            | extend SrcIpAddr = tostring(SrcIpAddrAndPort[0]),
                    SrcPortNumber = toint(SrcIpAddrAndPort[1]),
                    DstIpAddr = tostring(DstIpAddrAndPort[0]),
                    DstPortNumber = toint(DstIpAddrAndPort[1])
            | project-away SrcIpAddrAndPort, DstIpAddrAndPort, NetworkIcmpInfo;
  let all_106023_41 = unparsedData
            | where DeviceEventClassID == "106023" and Message has "protocol 41"
            | parse Message with * ":" DeviceAction " " ProtocolFromLog " src " SrcInterfaceName ":" SrcIpAddr " dst " DstInterfaceName ":" DstIpAddr ' by access-group ' NetworkRuleName ' '  *
            | parse Message with * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")" *
            | extend Protocol = case(isnotempty(Protocol), Protocol,
                                    ProtocolFromLog endswith "41", "41",
                                    ""),
                    NetworkRuleName = trim_start(@"\s*",NetworkRuleName)
            | project-away ProtocolFromLog;
  let all_302013_302015_parsed = parsedData
            | where DeviceEventClassID in ("302013","302015")
            | parse Message with * ":" * " " * " " * " connection " NetworkSessionId " for " SrcInterfaceName ":" * "/" * " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" * "/" * " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
            | extend SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                    DstUsername = trim(@"\s?\(?\)?\s?", DstUsername),
                    SessionId = NetworkSessionId,
                    EventSubType = "Start";
  let all_302013_302015_unparsed = unparsedData
            | where DeviceEventClassID in ("302013","302015")
            | parse Message with * ":" DeviceAction " " NetworkDirection " " Protocol " connection " NetworkSessionId " for " SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
            | extend SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                    DstUsername = trim(@"\s?\(?\)?\s?", DstUsername),
                    NetworkDirection = case(NetworkDirection == "inbound", "Inbound",
                                                NetworkDirection == "outbound", "Outbound",
                                                ""),
                    SessionId = NetworkSessionId,
                    EventSubType = "Start"; 
  let all_302014_unparsed = unparsedData
            | where DeviceEventClassID == "302014"
            | project-away DvcAction, EventResult
            | parse Message with * ":" DeviceAction " " Protocol " connection " NetworkSessionId " for " SrcInfoString " to " DstInfoString " duration " NetworkDuration " bytes " NetworkBytes:long *
            // SrcInfoString is extracted from the Message and not the direct values of IP, Port, Interface and User because Username is optional here
            | parse kind=regex SrcInfoString with SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int @"\(?\s?" SrcUsername @"\)?\s?"
            // DstInfoString is extracted from the Message and not the direct values of IP, Port, Interface and User because Username is optional here
            | parse kind=regex DstInfoString with DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int @"\(?\s?" DstUsername @"\)?\s?"
            // Remaining string can have multiple formats. Mapping of all of them is as follows:
            // 1. empty --> no mapping required, RemainingString will be empty                
            | parse Message with * " bytes " * " " RemainingString
            // 2. (domain\USER001) 3. TCP FINs from OUTSIDE (domain\USER001) 4. TCP FINs (domain\USER001) --> DstUsernameSimple will now contain the value of the Destination Username
            | parse RemainingString with ReasonString "(" DstUsernameSimple ")"
            // Now to cover case #3 and 5. TCP FINs from OUTSIDE, adding check for the word "from" 
            | extend ReasonString = case(RemainingString has "from" and RemainingString !has "(", RemainingString,
                                         ReasonString)
            // Finally extract the required Reason information from the string to be utilized later
            | parse ReasonString with Reason " from " *
            | extend Reason = case(isempty(Reason), ReasonString,
                                   Reason)
            | lookup EventResultMapping on Reason
            | extend 
                        SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                        DstUsername = case(isempty(DstUsername),DstUsernameSimple,
                                           trim(@"\s?\(?\)?\s?", DstUsername)),
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End",
                        EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
            | project-away DstUsernameSimple, *String, Reason;
  let all_302014_parsed = parsedData
            | where DeviceEventClassID == "302014"
            | project-away DvcAction, EventResult
            | parse Message with * " connection " NetworkSessionId " for " SrcInterfaceName ":" * " to " DstInterfaceName ":" * " duration " NetworkDuration " bytes " NetworkBytes:long *
            | parse Message with * " bytes " * " " ReasonString
            | parse ReasonString with Reason " from " *
            | extend Reason = case(isempty(Reason), ReasonString,
                                   Reason)
            | lookup EventResultMapping on Reason
            | extend 
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End",
                        EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
            | project-away Reason, ReasonString;
  let all_302016_parsed = parsedData
            | where DeviceEventClassID  == "302016"
            | parse Message with * " connection " NetworkSessionId " for " SrcInterfaceName ":" * " to " DstInterfaceName ":" * " duration " NetworkDuration " bytes " NetworkBytes:long *
            | extend NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                     SessionId = NetworkSessionId,
                     EventSubType = "End";
  let all_302016_unparsed = unparsedData
            | where DeviceEventClassID  == "302016"
            | parse Message with * ":" DeviceAction " " Protocol " connection " NetworkSessionId " for " SrcInfoString " to " DstInfoString " duration " NetworkDuration " bytes " NetworkBytes:long *
            | parse kind=regex SrcInfoString with SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int @"\(?\s?" SrcUsername @"\)?\s?"
            | parse kind=regex DstInfoString with DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int @"\(?\s?" DstUsername @"\)?\s?"
            | parse Message with * " bytes " * " (" DstUsernameSimple ")"
            | extend 
                        SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                        DstUsername = case(isempty(DstUsername),DstUsernameSimple,
                                           trim(@"\s?\(?\)?\s?", DstUsername)),
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End"
            | project-away DstUsernameSimple, *InfoString;
  let all_302020_302021 = parsedData
            | where DeviceEventClassID in ("302020","302021")
            | parse Message with * "(" SrcUsername ")" *
            | parse Message with * "type " NetworkIcmpType " code " NetworkIcmpCode:int *
            | extend SrcUsernameType = iif(isnotempty(SrcUsername),"Windows",""),
                        EventSubType = case(DeviceEventClassID == "302020", "Start",
                                            "End");
  let all_7_series = parsedData
            | where DeviceEventClassID in ("710002","710003","710004","710005")
            | parse Message with * " to " DstInterfaceName ":" *;
  let all_106007 = parsedData
            | where DeviceEventClassID == "106007"
            | extend DstAppName = "DNS"
            | parse Message with * " due to " EventOriginalResultDetails;
  let all_106017 = parsedData
            | where DeviceEventClassID == "106017"
            | extend ThreatName = "Land Attack";
  let all_106100_parsed = parsedData
            | where DeviceEventClassID == "106100" and isnotempty(SrcIpAddr)
            | extend DvcAction = case(Message has "denied", "Deny",
                                      "Allow")
            | extend EventResult = case(DvcAction == "Deny", "Failure",
                                        "Success")
            | parse Message with * "access-list " * " " * " " * " " SrcInterfaceName "/" * ") -> " DstInterfaceName "/" * ") hit-cnt " EventCount:int *;
  let all_106100_unparsed = unparsedData
            | where DeviceEventClassID == "106100"
            | extend DvcAction = case(Message has "denied", "Deny",
                                      "Allow")
            | extend EventResult = case(DvcAction == "Deny", "Failure",
                                        "Success")
            | parse Message with * "access-list " NetworkRuleName " " DeviceAction " " Protocol " " SrcInterfaceName "/" SrcIpAddr "(" SrcPortNumber:int ") -> " DstInterfaceName "/" DstIpAddr "(" DstPortNumber:int ") hit-cnt " EventCount:int * ;
  let remainingLogs = parsedData
            | where DeviceEventClassID in ("106002", "106012", "106013", "106020");
  let networkaddressWatchlistData = materialize (_ASIM_GetWatchlistRaw("NetworkAddresses"));
  let internalInterface = networkaddressWatchlistData | where WatchlistItem.Tags has "Internal" | distinct tostring(WatchlistItem["Range Name"]);
  let externalInterface = networkaddressWatchlistData | where WatchlistItem.Tags has "External" | distinct tostring(WatchlistItem["Range Name"]);
  union isfuzzy=false all_106001_alike, all_106010_alike, all_106018, all_106023, all_106023_unparsed, all_106023_41,  all_302013_302015_unparsed, all_302013_302015_parsed, all_302014_parsed, all_302014_unparsed, all_302016_parsed, all_302016_unparsed, all_302020_302021, all_7_series, all_106007, all_106017, all_106100_parsed, all_106100_unparsed, remainingLogs
            | extend 
                    EventStartTime = TimeGenerated,
                    EventEndTime = TimeGenerated,
                    EventVendor = "Cisco",
                    EventProduct = "ASA",
                    EventCount = coalesce(EventCount,toint(1)),
                    EventType = "NetworkSession",
                    EventSchema = "NetworkSession",
                    EventSchemaVersion = "0.2.4",
                    SrcInterfaceName = tolower(SrcInterfaceName),
                    DstInterfaceName = tolower(SrcInterfaceName)
            | extend 
                    SrcUsernameType = case(isnotempty(SrcUsername) and SrcUsername has "@", "UPN",
                                           isnotempty(SrcUsername) and SrcUsername !has "@" and SrcUsername has "\\", "Windows",
                                           isnotempty(SrcUsername), "Simple",
                                           ""),
                    DstUsernameType = case(isnotempty(DstUsername) and DstUsername has "@", "UPN",
                                           isnotempty(DstUsername) and DstUsername !has "@" and DstUsername has "\\", "Windows",
                                           isnotempty(DstUsername), "Simple",
                                           "")
            | lookup ProtocolLookup on Protocol
            | project-rename 
                    EventProductVersion = DeviceVersion,
                    EventOriginalType = DeviceEventClassID,
                    EventOriginalSeverity = OriginalLogSeverity,
                    DvcOriginalAction = DeviceAction,
                    EventMessage = Message,
                    Dvc = Computer
            | extend
                    EventSeverity = iff(isempty(EventResult) or EventResult == "Success", "Informational", "Low"),
                    NetworkDirection = case(isnotempty(CommunicationDirection), CommunicationDirection,
                                SrcInterfaceName in (internalInterface) and DstInterfaceName in (internalInterface), "Local",
                                SrcInterfaceName in (externalInterface) and DstInterfaceName in (externalInterface), "External",
                                DstInterfaceName in (externalInterface), "Outbound",
                                SrcInterfaceName in (externalInterface), "Inbound",
                                ""),
                    NetworkProtocol = case(isempty(NetworkProtocol) and isnotempty(Protocol), toupper(Protocol),
                                            NetworkProtocol)
            | extend 
                    Src = SrcIpAddr,
                    Dst = DstIpAddr,
                    Duration = NetworkDuration,
                    IpAddr = SrcIpAddr,
                    Rule = NetworkRuleName,
                    User = DstUsername
            | project-away CommunicationDirection, LogSeverity, Protocol, Device*
            };
  NWParser (disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCiscoFirepower
// Description: This ASIM parser supports normalizing commonly used Cisco Firepower messages collected using the CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCiscoFirepower(    ['disabled']:bool=false)
{
let ActionLookup = datatable(
    DeviceAction: string,
    DvcAction: string,
    EventResult: string
)
    [
    "Blocked", "Deny", "Failure",
    "Alerted", "Allow", "Success",
    "Rewritten", "Allow", "Success",
    "Would be Rewritten", "Allow", "Partial",
    "Would be Blocked", "Deny", "Partial",
    "Would Be Blocked", "Deny", "Partial",
    "Dropped", "Drop", "Failure",
    "Would be Dropped", "Drop", "Partial",
    "Partially Dropped", "Drop", "Partial",
    "Would be Block", "Deny", "Partial",
    "Partial Blocked", "Deny", "Partial",
    "Rejected", "Deny", "Failure",
    "Would be Rejected", "Deny", "Partial",
    "Would Rejected", "Deny", "Partial",
    "Block", "Deny", "Failure",
    "Partial Block", "Deny", "Partial",
    "Drop", "Drop", "Failure",
    "Would Drop", "Drop", "Partial",
    "Reject", "Deny", "Failure",
    "Rewrite", "Allow", "Success",
    "Allow", "Allow", "Success",
    "Monitor", "Allow", "Success"
];
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
    [
    "0", "Low",
    "1", "Low",
    "2", "Low",
    "3", "Low",
    "4", "Medium",
    "5", "Medium",
    "6", "Medium",
    "7", "High",
    "8", "High",
    "9", "High",
    "10", "High"
];
let EventResultDetailsLookup = datatable(Reason: string, EventResultDetails: string)
    [
    "N/A", "NA",
    "IP Block", "Terminated",
    "IP Monitor", "Unknown",
    "User Bypass", "Unknown",
    "File Monitor", "Unknown",
    "File Block", "Terminated",
    "Intrusion Monitor", "Unknown",
    "Intrusion Block", "Terminated",
    "File Resume Block", "Terminated",
    "File Resume Allow", "Unknown",
    "File Custom Detection", "Unknown"
];
let parser = (disabled: bool=false) {
    let AllLogs = CommonSecurityLog
        | where not(disabled) 
        | where DeviceVendor == "Cisco" and DeviceProduct == "Firepower"
            and DeviceEventClassID has_any("INTRUSION:400", "PV:112", "RNA:1003:1")
        | invoke _ASIM_ResolveNetworkProtocol('Protocol')
        | extend NetworkProtocol = iff(NetworkProtocol == "Unassigned" and Protocol !in (63, 68, 99, 114, 253, 254), Protocol, NetworkProtocol);
    let Connection_Statistics_Events = AllLogs
        | where DeviceEventClassID has "RNA:1003:1"
        | parse-kv AdditionalExtensions as (
            start: long,
            end: long,
            bytesIn: long,
            bytesOut: long,
            )
            with (pair_delimiter=';', kv_delimiter='=')
        | lookup EventResultDetailsLookup on Reason
        | extend
            SrcBytes = bytesIn,
            DstBytes = bytesOut,
            EventOriginalResultDetails = Reason,
            AdditionalFields = bag_pack("policy", DeviceCustomString1,
                                              "instanceID", ProcessID,
                                              "clientApplicationID", RequestClientApplication,
                                              "clientUrl", RequestURL);
    let Intrusion_Events = AllLogs
        | where DeviceEventClassID has "INTRUSION:400"
        | parse-kv AdditionalExtensions as (
            start: long
            )
            with (pair_delimiter=';', kv_delimiter='=')
        | extend 
            EventMessage = Activity,
            ThreatCategory = DeviceEventCategory,
            AdditionalFields = bag_pack("policy", DeviceCustomString1,
                                              "ipspolicy", DeviceCustomString5,
                                              "clientApplicationID", RequestClientApplication,
                                              "clientUrl", RequestURL);
    let Policy_Violation_Events = AllLogs
        | where DeviceEventClassID has "PV:112"
        | extend
            EventMessage = Message,
            AdditionalFields = bag_pack("policy", DeviceCustomString1)
        | project-rename DstUsername = DestinationUserName
        | extend
            DstUsernameType = _ASIM_GetUsernameType(DstUsername),
            DstUserType = _ASIM_GetUserType(DstUsername, "");
    union Connection_Statistics_Events, Intrusion_Events, Policy_Violation_Events
    | extend
        SrcPortNumber = iff(NetworkProtocol == "ICMP", int(null), SourcePort),
        DstPortNumber = iff(NetworkProtocol == "ICMP", int(null), DestinationPort),
        NetworkIcmpCode = iff(NetworkProtocol == "ICMP", DestinationPort, int(null)),
        NetworkIcmpType = iff(NetworkProtocol == "ICMP", tostring(SourcePort), ""),
        SrcZone = DeviceCustomString3,
        DstZone = DeviceCustomString4
    | lookup ActionLookup on DeviceAction
    | lookup EventSeverityLookup on LogSeverity
    | extend 
        EventStartTime = coalesce(unixtime_milliseconds_todatetime(start), unixtime_milliseconds_todatetime(tolong(ReceiptTime))),
        SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
        DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
        EventOriginalType = iff(DeviceEventClassID has "INTRUSION:400", "INTRUSION EVENT", Activity),
        SrcVlanId = tostring(DeviceCustomNumber1)
    | extend
        EventEndTime = coalesce(unixtime_milliseconds_todatetime(end), EventStartTime),
        NetworkProtocolVersion = case(
                            DstIpAddr contains ".",
                            "IPv4",
                            DstIpAddr contains ":",
                            "IPv6",
                            ""
                        )
    | extend Ip_device = iff(DeviceName matches regex "(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))", DeviceName, "")
    | extend
        DvcIpAddr = Ip_device,
        DeviceName = iff(isempty(Ip_device), DeviceName, "")
    | extend host = coalesce(DeviceName, Computer)
    | invoke _ASIM_ResolveDvcFQDN('host')
    | invoke _ASIM_ResolveDstFQDN('DestinationDnsDomain')
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventCount = int(1)
    | project-rename 
        EventProduct = DeviceProduct,
        EventVendor = DeviceVendor,
        SrcUsername = SourceUserName,
        DvcInboundInterface = DeviceInboundInterface,
        DvcOutboundInterface = DeviceOutboundInterface,
        EventOriginalSeverity = LogSeverity,
        DvcId = DeviceExternalID,
        NetworkApplicationProtocol = ApplicationProtocol,
        EventProductVersion = DeviceVersion,
        EventOriginalUid = ExtID,
        NetworkRuleName = DeviceCustomString2,
        EventUid = _ItemId,
        DvcOriginalAction = DeviceAction
    | extend
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
        DvcIdType = "Other"
    | extend 
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Dvc = coalesce(DvcIpAddr, DvcHostname),
        Rule = NetworkRuleName,
        User = SrcUsername,
        Hostname = DstHostname
    | project-away
        bytesIn,
        bytesOut,
        start,
        end,
        CommunicationDirection,
        AdditionalExtensions,
        Device*,
        Source*,
        Destination*,
        Activity,
        ProcessID,
        Protocol,
        Reason,
        ReceiptTime,
        SimplifiedDeviceAction,
        OriginalLogSeverity,
        ProcessName,
        EndTime,
        ExternalID,
        File*,
        ReceivedBytes,
        Message,
        Old*,
        EventOutcome,
        Request*,
        StartTime,
        Field*,
        Flex*,
        Remote*,
        Malicious*,
        ThreatConfidence,
        ThreatSeverity,
        IndicatorThreatType,
        ThreatDescription,
        _ResourceId,
        SentBytes,
        ReportReferenceLink,
        Computer,
        TenantId,
        Ip_*,
        host,
        NetworkProtocolNumber
};
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCiscoISE
// Description: This ASIM parser supports normalizing Cisco ISE Events produced by the Microsoft Sentinel Cisco ISE connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCiscoISE(    ['disabled']:bool=false)
{
let EventFieldsLookup=datatable(
EventOriginalType: string,
EventResult: string,
DvcAction: string,
EventResultDetails: string,
EventSubType: string,
EventOriginalSeverity: string,
EventSeverity: string,
EventMessage: string,
EventOriginalResultDetails: string
)[
"60188", "Failure", "Drop", "Terminated", "End", "INFO", "Low", "An attempted SSH connection has failed", "An attempted SSH connection has failed",
"60234", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "The SXP connection has been disconnected", "The SXP connection has been disconnected",
"60235", "Success", "Allow", "", "Start", "INFO", "Informational", "SXP connection succeeded", "SXP connection succeeded",
"60236", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "SXP connection failed", "SXP connection failed",
"61010", "Success", "Allow", "", "Start", "INFO", "Informational", "ISE has established connection to APIC", "ISE has established connection to APIC",
"61011", "Success", "Allow", "", "End", "INFO", "Informational", "ISE was disconnected from APIC", "ISE was disconnected from APIC",
"61025", "Success", "Allow", "", "Start", "INFO", "Informational", "Open secure connection with TLS peer", "Secure connection established with TLS peer",
"61026", "Success", "Allow", "", "Start", "INFO", "Informational", "Shutdown secure connection with TLS peer", "Secure connection with TLS peer shutdown",
"60509", "Failure", "Deny", "Terminated", "End", "ERROR", "Low", "ERS request was denied as maximum possible connection was exceeded", "ERS request was denied as maximum possible connection was exceeded",
"61231", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "Kafka connection to ACI error while receiving message", "Kafka connection to ACI error while receiving message",
"61232", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "Kafka connection to ACI error while sending message", "Kafka connection to ACI error while sending message",
"89003", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "Failed to connect to MDM server", "Failed to connect to MDM server",
"24000", "Success", "Allow", "", "Start", "INFO", "Informational", "Connection established with LDAP server", "Connection established with LDAP server",
"24001", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Cannot establish connection with LDAP server", "Cannot establish connection with LDAP server",
"24019", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "LDAP connection error was encountered", "ISE cannot connect to LDAP external ID store",
"24030", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "SSL connection error was encountered", "SSL connection error was encountered",
"24400", "Success", "Allow", "", "Start", "INFO", "Informational", "Connection to ISE Active Directory agent established successfully", "Connection to ISE Active Directory agent established successfully",
"24401", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Could not establish connection with ISE Active Directory agent", "Could not establish connection with ISE Active Directory agent",
"24428", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Connection related error has occurred in either LRPC, LDAP or KERBEROS", "This RPC connection problem may be because the stub received incorrect data",
"24429", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Could not establish connection with Active Directory", "Could not establish connection with Active Directory",
"24850", "Success", "Allow", "", "Start", "DEBUG", "Informational", "Successfully connected to external ODBC database", "ISE successfully established a new connection to external ODBC database",
"24851", "Failure", "Drop", "Terminated", "End", "DEBUG", "Low", "Connection to external ODBC database failed", "ISE failed to establish a new connection to external ODBC database",
"34120", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Profiler failed to get the connection to NAC Manager", "Profiler sends a notification event to NAC Manager, but the notification fails because could not connect to NAC Manager",
"34147", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "JGroups TLS Handshake Failed", "JGroups TLS Handshake Failed",
"34148", "Success", "Allow", "", "Start", "INFO", "Informational", "JGroups TLS Handshake Succeeded", "JGroups TLS Handshake Succeeded",
"34149", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "HTTPS TLS Handshake Failed", "HTTPS TLS Handshake Failed",
"34150", "Success", "Allow", "", "Start", "INFO", "Informational", "HTTPS TLS Handshake Succeeded", "HTTPS TLS Handshake Succeeded",
"34159", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAPS connection established successfully", "LDAPS connection established successfully",
"34160", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAPS connection terminated successfully", "LDAPS connection terminated successfully",
"34161", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection establishment failed with SSL error", "LDAPS connection establishment failed with SSL error",
"34162", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection terminated with SSL error", "LDAPS connection terminated with SSL error",
"34163", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection establishment failed with non-SSL error", "LDAPS connection establishment failed with non-SSL error",
"34164", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection terminated with non-SSL error", "LDAPS connection terminated with non-SSL error",
"90062", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Cannot connect to Domain Controller", "Cannot connect to Domain Controller",
"90063", "Success", "Allow", "", "Start", "INFO", "Informational", "Successfully establish connection to Domain Controller", "Successfully establish connection to Domain Controller",
"90066", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Lost connection with Domain Controller", "Lost connection with Domain Controller",
"90078", "Success", "Allow", "", "Start", "INFO", "Informational", "Closed connection to Domain Controller", "Closed connection to Domain Controller",
"91082", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "RADIUS DTLS: Connection to OCSP server failed", "RADIUS DTLS: Connection attempt to OCSP server failed.",
"11317", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "TrustSec SSH connection failed", "ISE failed to establish SSH connection to a network device. Verify network device SSH credentials in the Network Device page are similar to the credentials configured on the network device. Check network device enabled ssh connections from ISE (ip address)",
"5405", "Failure", "Drop", "Terminated", "End", "NOTICE", "Low", "RADIUS Request dropped", "RADIUS request dropped",
"5406", "Failure", "Drop", "Terminated", "End", "NOTICE", "Low", "TACACS+ Request dropped", "TACACS+ request dropped"
];
let EventOriginalTypeList = toscalar(EventFieldsLookup 
    | summarize make_set(EventOriginalType));
let GetSrcIpAddr = (src_ip: string) {
    case ( 
          src_ip matches regex @"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}",
          src_ip,
          ""
          )
};
let GetMacAddr = (mac: string) {
    case ( 
    mac matches regex @"[a-fA-F0-9\-:]{17}",
    mac,
    ""
    )
};
let CiscoISENSParser=(disabled: bool=false) {
    Syslog
    | where not(disabled)
    | where ProcessName has_any ("CISE", "CSCO")
    | parse kind = regex SyslogMessage with @"\d{10}\s" EventOriginalType @"\s(NOTICE|INFO|WARN|WARNING|ERROR|FATAL|DEBUG)"
    | where EventOriginalType in (EventOriginalTypeList)
    | lookup EventFieldsLookup on EventOriginalType
    | parse-kv SyslogMessage as (FailureReason: string, NetworkDeviceName: string, DestinationIPAddress: string, DestinationPort: int, ['Remote-Address']: string, ['Device IP Address']: string, ['User-Name']: string, UserName: string, User: string, ['Device Port']: int, Protocol: string, ['Calling-Station-ID']: string, ['Called-Station-ID']: string) with (pair_delimiter=',', kv_delimiter='=')
    | project-rename
        DstIpAddr=DestinationIPAddress
        , DstPortNumber=DestinationPort
        , SrcPortNumber=['Device Port']
        , NetworkApplicationProtocol=Protocol
    | invoke _ASIM_ResolveSrcFQDN("['Calling-Station-ID']")
    | extend 
        EventVendor = "Cisco"
        , EventProduct = "ISE"
        , EventProductVersion = "3.2"
        , EventCount = int(1)
        , EventSchema = "NetworkSession"
        , EventSchemaVersion = "0.2.6"
        , EventStartTime = coalesce(EventTime, TimeGenerated)
        , EventEndTime = coalesce(EventTime, TimeGenerated)
        , EventType = "NetworkSession"
        , EventOriginalResultDetails = case(isnotempty(FailureReason), FailureReason, EventOriginalResultDetails)
        , DvcIpAddr = iif(isnotempty(HostIP) and HostIP != "Unknown IP", HostIP, extract(@"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", 1, Computer))
        , DstMacAddr = GetMacAddr(['Called-Station-ID'])
        , SrcMacAddr = GetMacAddr(['Calling-Station-ID'])
        , DstUsername = coalesce(UserName, ['User-Name'], User)
    | extend
        DstUsernameType = _ASIM_GetUsernameType(DstUsername)
        , DvcHostname = coalesce(NetworkDeviceName, Computer, HostName)
        , SrcIpAddr = coalesce(['Device IP Address'], ['Remote-Address'], GetSrcIpAddr(['Calling-Station-ID']))
    //********************** <Aliaces> ************************
    | extend 
        Dvc = coalesce(DvcHostname, DvcIpAddr)
        , IpAddr = SrcIpAddr
        , Dst = DstIpAddr
        , Src = SrcIpAddr
        , User = DstUsername
    //********************** </Aliases> ***********************
    | project-away
        TenantId,
        SourceSystem,
        MG,
        Computer,
        EventTime,
        Facility,
        HostName,
        SeverityLevel,
        SyslogMessage,
        HostIP,
        ProcessName,
        ProcessID,
        _ResourceId,
        FailureReason,
        NetworkDeviceName,
        ['User-Name'],
        UserName,
        ['Device IP Address'],
        ['Remote-Address'],
        ['Calling-Station-ID'],
        ['Called-Station-ID']
};
CiscoISENSParser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCiscoMeraki
// Description: This ASIM parser supports normalizing Cisco Meraki logs ingested in 'meraki_CL' table to the ASIM Network Session normalized schema. Cisco Meraki events are generated from network activity and security events from Meraki devices such as firewalls, switches, and access points. These logs are captured through the Cisco Meraki Sentinel connector which uses a Linux agent to collect logs in Syslog format.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCiscoMeraki(    ['disabled']:bool=false)
{
let EventResultDetailsLookup = datatable(reason: string, EventResultDetails: string)
[
    "0", "Unknown",
    "1", "Unknown",
    "2", "Timeout",
    "3", "Terminated",
    "4", "Timeout",
    "5", "Transient error",
    "6", "Invalid Tunnel",
    "7", "Invalid Tunnel",
    "8", "Terminated",
    "9", "Invalid Tunnel",
    "10", "Unknown",
    "11", "Invalid TCP",
    "12", "Unknown",
    "13", "Invalid TCP",
    "14", "Invalid Tunnel",
    "15", "Invalid TCP",
    "16", "Timeout",
    "17", "Invalid Tunnel",
    "18", "Invalid TCP",
    "19", "Invalid TCP",
    "20", "Invalid TCP",
    "21", "Unknown",
    "22", "Invalid TCP",
    "23", "Invalid Tunnel",
    "24", "Invalid Tunnel",
    "32", "Unknown",
    "33", "Invalid TCP",
    "34", "Invalid TCP",
    "35", "Invalid TCP",
    "36", "Unknown",
    "37", "Unknown",
    "38", "Unknown",
    "39", "Timeout",
    "40", "Invalid TCP",
    "98", "Unknown",
    "99", "Unknown"
];
let NetworkIcmpTypeLookup=datatable(
    NetworkIcmpCode_lookup: int,
    NetworkIcmpType_lookup: string
)
    [
    0, "Reserved",
    1, "Destination Unreachable",
    2, "Packet Too Big",
    3, "Time Exceeded",
    4, "Parameter Problem",
    100, "Private experimentation",
    101, "Private experimentation",
    127, "Reserved for expansion of ICMPv6 error messages",
    128, "Echo Request",
    129, "Echo Reply",
    130, "Multicast Listener Query",
    131, "Multicast Listener Report",
    132, "Multicast Listener Done",
    133, "Router Solicitation",
    134, "Router Advertisement",
    135, "Neighbor Solicitation",
    136, "Neighbor Advertisement",
    137, "Redirect Message",
    138, "Router Renumbering",
    139, "ICMP Node Information Query",
    140, "ICMP Node Information Response",
    141, "Inverse Neighbor Discovery Solicitation Message",
    142, "Inverse Neighbor Discovery Advertisement Message",
    143, "Version 2 Multicast Listener Report",
    144, "Home Agent Address Discovery Request Message",
    145, "Home Agent Address Discovery Reply Message",
    146, "Mobile Prefix Solicitation",
    147, "Mobile Prefix Advertisement",
    148, "Certification Path Solicitation Message",
    149, "Certification Path Advertisement Message",
    150, "ICMP messages utilized by experimental mobility protocols such as Seamoby",
    151, "Multicast Router Advertisement",
    152, "Multicast Router Solicitation",
    153, "Multicast Router Termination",
    154, "FMIPv6 Messages",
    155, "RPL Control Message",
    156, "ILNPv6 Locator Update Message",
    157, "Duplicate Address Request",
    158, "Duplicate Address Confirmation",
    159, "MPL Control Message",
    160, "Extended Echo Request",
    161, "Extended Echo Reply",
    200, "Private experimentation",
    201, "Private experimentation",
    255, "Reserved for expansion of ICMPv6 informational messages"
];
let NetworkProtocolLookup=datatable(
    protocol: string,
    NetworkProtocol_lookup: string,
    NetworkProtocolVersion: string
)[
    "tcp", "TCP", "",
    "tcp/ip", "TCP", "",
    "udp", "UDP", "",
    "udp/ip", "UDP", "",
    "icmp", "ICMP", "IPV4",
    "icmp6", "ICMP", "IPV6",
];
let EventSeverityPriorityLookup=datatable(priority: string, EventSeverity: string)[
    "1", "High",
    "2", "Medium",
    "3", "Low",
    "4", "Informational"
];
let EventSeverityDvcActionLookup=datatable(DvcAction: string, EventSeverity: string)[
    "Allow", "Informational",
    "Deny", "Low"
];
let NetworkDirectionLookup=datatable(direction: string, NetworkDirection: string)[
    "ingress", "Inbound",
    "egress", "Outbound",
    "Unknown", "NA"
];
let DvcActionLookup = datatable(pattern: string, DvcAction: string, EventResult: string)[
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "0", "Allow", "Success",
    "1", "Deny", "Failure",
    "Blocked", "Deny", "Failure"
];
let EventResultLookup = datatable(LogSubType: string, EventResult_type: string)[
    "association", "Success",
    "disassociation", "Failure",
    "Virtual router collision", "Failure",
];
let parser=(disabled: bool=false) {
    let allData = (
            meraki_CL
            | project-rename LogMessage =  Message
            );
    let PreFilteredData = allData
        | where not(disabled) and (LogMessage has_any("flows", "firewall", "ids-alerts") or LogMessage has_all("security_event", "ids-alerted") or (LogMessage has "events" and (LogMessage has_any ("Blocked DHCP server response", "association") or (LogMessage has "VRRP packet" and not(LogMessage has_any ("VRRP passive", "VRRP active"))) or (LogMessage has "disassociation" and not(LogMessage has_any ("auth_neg_failed", "dhcp"))))) or (LogMessage has "airmarshal_events" and LogMessage has_any("ssid_spoofing_detected", "rogue_ssid_detected")))
        | extend Parser = extract_all(@"(\d+.\d+)\s([\w\-\_]+)\s([\w\-\_]+)\s([\S\s]+)$", dynamic([1, 2, 3, 4]), LogMessage)[0]
        | extend
            LogType = tostring(Parser[2]),
            Substring = tostring(Parser[3]);
    let FlowsFirewallData = PreFilteredData
        | where LogType in ("flows", "firewall", "cellular_firewall", "vpn_firewall")
        | parse-kv Substring as(src: string, dst: string, mac: string, sport: string, dport: string, protocol: string, type: int) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | parse Substring with pattern1: string " src=" temp_restmessage: string
        | parse Substring with * "pattern: " pattern2: string " " temp_restmessage: string
        | extend NetworkIcmpCode_lookup = iff(protocol == 'icmp6', type, int(null))
        | extend type_icmp4 = iff(protocol == 'icmp', type, int(null))
        | lookup NetworkIcmpTypeLookup on NetworkIcmpCode_lookup
        | invoke _ASIM_ResolveICMPType('type_icmp4')
        | extend NetworkIcmpCode = coalesce(NetworkIcmpCode_lookup, NetworkIcmpCode)
        | extend NetworkIcmpType = iff(isnotempty(NetworkIcmpCode), coalesce(NetworkIcmpType_lookup, NetworkIcmpType), "")
        | extend pattern = coalesce(pattern1, pattern2)
        | lookup DvcActionLookup on pattern
        | extend direction = case(pattern has_any ('0','1'), 'ingress', pattern has_any ('allow','deny'), 'egress', 'unknown')
        | lookup NetworkDirectionLookup on direction
        | lookup EventSeverityDvcActionLookup on DvcAction
        | extend
            SrcMacAddr = trim('"', mac),
            EventType = "Flow";
    let IDSAlertData = PreFilteredData
        | where LogType in ("ids-alerts", "security_event")
        | parse LogMessage with * "security_event " LogSubType: string " " * "message: " message: string 
        | where LogType == "security_event" and LogSubType == "ids-alerted" or LogType == "ids-alerts"
        | parse-kv Substring as(priority: string, timestamp: string, direction: string, protocol: string, src: string, dst: string, signature: string, dhost: string, shost: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend EventResult = "Success"
        | extend
            priority = trim('"', priority),
            direction = trim('"', direction)
        | lookup EventSeverityPriorityLookup on priority
        | lookup NetworkDirectionLookup on direction
        | extend AdditionalFields = bag_pack(
                                "signature", trim('"', signature)
                            )
        | extend
            SrcMacAddr = trim('"', shost),
            DstMacAddr = trim('"', dhost),
            EventMessage = trim('"', message);
    let AirmarshalEvents = PreFilteredData
        | where LogType in ("airmarshal_events")
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | parse-kv temp_message as(src: string, dst: string, wired_mac: string, vlan_id: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend
            SrcMacAddr = trim('"', src),
            DstMacAddr = trim('"', dst),
            DvcMacAddr = trim('"', wired_mac)
        | extend
            EventResult = "Success",
            EventSeverity = "High";
    let EventsData = PreFilteredData
        | where LogType == "events";
    let EventsData_associ = EventsData
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType == "association" or (LogSubType == "disassociation" and not(Substring has_any ("auth_neg_failed", "dhcp")))
        | parse-kv Substring as (last_known_client_ip: string, client_mac: string, identity: string, aid: string, duration: string, ip_src: string, dns_server: string, reason: string, rssi: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend AdditionalFields = bag_pack(
                                "aid", aid,
                                "rssi", rssi
                            )
        | extend SrcMacAddr = trim('"', client_mac)
        | lookup EventResultLookup on LogSubType
        | extend EventResult = EventResult_type
        | lookup EventResultDetailsLookup on reason
        | extend EventResultDetails = iff((toint(reason) >= 25 and toint(reason) <= 31) or (toint(reason) >= 25 and toint(reason) <= 31), "Unknown", EventResultDetails);
    let EventsData_space = EventsData
        | where Substring has "Blocked DHCP server response" or (Substring has "VRRP packet" and not(Substring in~ ("VRRP passive", "VRRP active"))) 
        | parse Substring with LogSubType1: string " from" temp_addr1: string " on VLAN " vlan_id1: string " " restmessage
        | parse Substring with LogSubType2: string " from" temp_addr2: string " on VLAN " vlan_id2: string
        | extend LogSubType = coalesce(LogSubType1, LogSubType2)
        | extend LogSubType = iff(LogSubType has "VRRP Packet", "Virtual router collision", LogSubType)
        | extend pattern = iff(Substring has "Blocked", "Blocked", "")
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | lookup EventResultLookup on LogSubType
        | extend EventResult = coalesce(EventResult, EventResult_type)
        | extend temp_addr = coalesce(trim('"', temp_addr1), trim('"', temp_addr2))
        | extend vlan_id = coalesce(trim('"', vlan_id1), trim('"', vlan_id2))
        | extend SrcMacAddr = iff(temp_addr matches regex "(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))", temp_addr, "")
        | parse temp_addr with *  "[" temp_ip "]:" temp_port 
        | extend SrcIpAddr = case(
                        temp_addr has ".",
                        split(temp_addr, ":")[0],
                        isnotempty(temp_ip),
                        temp_ip,
                        temp_addr
                    )
        | extend SrcPortNumber = toint(case(
                            isnotempty(temp_port),
                            temp_port,
                            temp_addr has ".",
                            split(temp_addr, ":")[1],
                            ""
                        )
                    )
        | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
        | extend EventMessage = Substring;
    union
        FlowsFirewallData,
        IDSAlertData,
        EventsData_associ,
        EventsData_space,
        AirmarshalEvents
    | lookup NetworkProtocolLookup on protocol
    | invoke _ASIM_ResolveNetworkProtocol('protocol')
    | extend NetworkProtocol = iff(isempty(NetworkProtocolNumber), NetworkProtocol_lookup, NetworkProtocol)
    | extend 
        Epoch = tostring(Parser[0]),
        Device = tostring(Parser[1])
    | extend
        Epoch = iff(isnotempty(column_ifexists("timestamp", "")), timestamp, Epoch)
    | extend
        EpochTimestamp = split(Epoch, ".")
    | extend
        EventStartTime = unixtime_seconds_todatetime(tolong(EpochTimestamp[0]))
    | extend temp_srcipport= coalesce(src, ip_src, last_known_client_ip) 
    | extend temp_srcipport =  trim('"', temp_srcipport)
    | parse temp_srcipport with *  "[" temp_srcip "]:" temp_srcport
    | extend SrcIpAddr = case(
                        temp_srcipport has ".",
                        split(temp_srcipport, ":")[0], 
                        isnotempty(SrcIpAddr),
                        SrcIpAddr,
                        coalesce(temp_srcip, temp_srcipport)
                    )
    | extend SrcPortNumber = iff(isempty(SrcPortNumber), toint(coalesce(sport, temp_srcport)), SrcPortNumber)
    | extend SrcPortNumber = toint(iff(isempty(SrcPortNumber) and SrcIpAddr has ".", split(temp_srcipport, ":")[1], SrcPortNumber))
    | extend temp_dstipport = coalesce(dst, dns_server)
    | extend temp_dstipport =  trim('"', temp_dstipport)
    | parse temp_dstipport with * "[" temp_dstip "]:" temp_dstport
    | extend DstIpAddr = iff(temp_dstipport has ".", split(temp_dstipport, ":")[0], coalesce(temp_dstip, temp_dstipport))
    | extend DstPortNumber = toint(coalesce(dport, temp_dstport))
    | extend DstPortNumber = toint(iff(isempty(DstPortNumber) and DstIpAddr has ".", split(temp_dstipport, ":")[1], DstPortNumber))
    | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
    | extend DstIpAddr = iff(DstIpAddr == DstMacAddr, "", DstIpAddr)
    | extend 
        EventMessage = iff(
                LogSubType has_any("Blocked DHCP server", "Virtual router collision"),
                Substring,
                coalesce(message, "")
            ),
        SrcUsername = trim('"', identity),
        SrcVlanId = trim('"', vlan_id)
    | extend
        EventSeverity = case(
                    isnotempty(EventSeverity),
                    EventSeverity,
                    EventResult == "Failure",
                    "Low",
                    "Informational"
                ),
        EventType = iff(isnotempty(EventType), EventType, "NetworkSession"),
        SrcUsernameType = iff(isnotempty(SrcUsername), "Simple", "")
    | invoke _ASIM_ResolveDvcFQDN('Device')
    | extend
        Dvc = DvcHostname,
        Src = coalesce(SrcIpAddr, SrcMacAddr),
        Dst = coalesce(DstIpAddr, DstMacAddr),
        NetworkDuration = toint(todouble(duration) * 1000)
    | project-rename
        EventOriginalType = LogType,
        EventOriginalSubType = LogSubType
    | extend
        EventEndTime = EventStartTime,
        EventCount = int(1),
        EventProduct = "Meraki",
        EventVendor = "Cisco",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        EventUid = _ResourceId
    | project-away
        LogMessage,
        Parser,
        Epoch,
        EpochTimestamp,
        Device,
        Substring,
        protocol,
        priority,
        reason,
        direction,
        duration,
        src,
        dst,
        dns_server,
        sport,
        dport,
        *_lookup,
        type*,
        pattern*,
        last_known_client_ip,
        ip_src,
        client_mac,
        mac,
        shost,
        dhost,
        wired_mac,
        identity,
        temp*,
        vlan_id*,
        LogSubType1,
        LogSubType2,
        restmessage*,
        message,
        rssi,
        aid,
        signature,
        timestamp,
        EventResult_type,
        TenantId,
        SourceSystem,
        Computer,
        _ResourceId,
        MG
};
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCiscoMerakiSyslog
// Description: This ASIM parser supports normalizing Cisco Meraki logs ingested in 'Syslog' to the ASIM Network Session normalized schema. Cisco Meraki events are generated from network activity and security events from Meraki devices such as firewalls, switches, and access points. These logs are captured through the Cisco Meraki Sentinel connector which uses a Linux agent to collect logs in Syslog format.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCiscoMerakiSyslog(    ['disabled']:bool=false)
{
let EventResultDetailsLookup = datatable(reason: string, EventResultDetails: string)
[
    "0", "Unknown",
    "1", "Unknown",
    "2", "Timeout",
    "3", "Terminated",
    "4", "Timeout",
    "5", "Transient error",
    "6", "Invalid Tunnel",
    "7", "Invalid Tunnel",
    "8", "Terminated",
    "9", "Invalid Tunnel",
    "10", "Unknown",
    "11", "Invalid TCP",
    "12", "Unknown",
    "13", "Invalid TCP",
    "14", "Invalid Tunnel",
    "15", "Invalid TCP",
    "16", "Timeout",
    "17", "Invalid Tunnel",
    "18", "Invalid TCP",
    "19", "Invalid TCP",
    "20", "Invalid TCP",
    "21", "Unknown",
    "22", "Invalid TCP",
    "23", "Invalid Tunnel",
    "24", "Invalid Tunnel",
    "32", "Unknown",
    "33", "Invalid TCP",
    "34", "Invalid TCP",
    "35", "Invalid TCP",
    "36", "Unknown",
    "37", "Unknown",
    "38", "Unknown",
    "39", "Timeout",
    "40", "Invalid TCP",
    "98", "Unknown",
    "99", "Unknown"
];
let NetworkIcmpTypeLookup=datatable(
    NetworkIcmpCode_lookup: int,
    NetworkIcmpType_lookup: string
)
    [
    0, "Reserved",
    1, "Destination Unreachable",
    2, "Packet Too Big",
    3, "Time Exceeded",
    4, "Parameter Problem",
    100, "Private experimentation",
    101, "Private experimentation",
    127, "Reserved for expansion of ICMPv6 error messages",
    128, "Echo Request",
    129, "Echo Reply",
    130, "Multicast Listener Query",
    131, "Multicast Listener Report",
    132, "Multicast Listener Done",
    133, "Router Solicitation",
    134, "Router Advertisement",
    135, "Neighbor Solicitation",
    136, "Neighbor Advertisement",
    137, "Redirect Message",
    138, "Router Renumbering",
    139, "ICMP Node Information Query",
    140, "ICMP Node Information Response",
    141, "Inverse Neighbor Discovery Solicitation Message",
    142, "Inverse Neighbor Discovery Advertisement Message",
    143, "Version 2 Multicast Listener Report",
    144, "Home Agent Address Discovery Request Message",
    145, "Home Agent Address Discovery Reply Message",
    146, "Mobile Prefix Solicitation",
    147, "Mobile Prefix Advertisement",
    148, "Certification Path Solicitation Message",
    149, "Certification Path Advertisement Message",
    150, "ICMP messages utilized by experimental mobility protocols such as Seamoby",
    151, "Multicast Router Advertisement",
    152, "Multicast Router Solicitation",
    153, "Multicast Router Termination",
    154, "FMIPv6 Messages",
    155, "RPL Control Message",
    156, "ILNPv6 Locator Update Message",
    157, "Duplicate Address Request",
    158, "Duplicate Address Confirmation",
    159, "MPL Control Message",
    160, "Extended Echo Request",
    161, "Extended Echo Reply",
    200, "Private experimentation",
    201, "Private experimentation",
    255, "Reserved for expansion of ICMPv6 informational messages"
];
let NetworkProtocolLookup=datatable(
    protocol: string,
    NetworkProtocol_lookup: string,
    NetworkProtocolVersion: string
)[
    "tcp", "TCP", "",
    "tcp/ip", "TCP", "",
    "udp", "UDP", "",
    "udp/ip", "UDP", "",
    "icmp", "ICMP", "IPV4",
    "icmp6", "ICMP", "IPV6",
];
let EventSeverityPriorityLookup=datatable(priority: string, EventSeverity: string)[
    "1", "High",
    "2", "Medium",
    "3", "Low",
    "4", "Informational"
];
let EventSeverityDvcActionLookup=datatable(DvcAction: string, EventSeverity: string)[
    "Allow", "Informational",
    "Deny", "Low"
];
let NetworkDirectionLookup=datatable(direction: string, NetworkDirection: string)[
    "ingress", "Inbound",
    "egress", "Outbound",
    "Unknown", "NA"
];
let DvcActionLookup = datatable(pattern: string, DvcAction: string, EventResult: string)[
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "Blocked", "Deny", "Failure"
];
let EventResultLookup = datatable(LogSubType: string, EventResult_type: string)[
    "association", "Success",
    "disassociation", "Failure",
    "Virtual router collision", "Failure",
];
let parser=(disabled: bool=false) {
    let allData = (
            Syslog
            | where Computer in (_ASIM_GetSourceBySourceType('CiscoMeraki'))
            | project-rename LogMessage =  SyslogMessage
            );
    let PreFilteredData = allData
        | where not(disabled) and (LogMessage has_any("flows", "firewall", "ids-alerts") or LogMessage has_all("security_event", "ids-alerted") or (LogMessage has "events" and (LogMessage has_any ("Blocked DHCP server response", "association") or (LogMessage has "VRRP packet" and not(LogMessage has_any ("VRRP passive", "VRRP active"))) or (LogMessage has "disassociation" and not(LogMessage has_any ("auth_neg_failed", "dhcp"))))) or (LogMessage has "airmarshal_events" and LogMessage has_any("ssid_spoofing_detected", "rogue_ssid_detected")))
        | extend Parser = extract_all(@"(\d+.\d+)\s([\w\-\_]+)\s([\w\-\_]+)\s([\S\s]+)$", dynamic([1, 2, 3, 4]), LogMessage)[0]
        | extend
            LogType = tostring(Parser[2]),
            Substring = tostring(Parser[3]);
    let FlowsFirewallData = PreFilteredData
        | where LogType in ("flows", "firewall", "cellular_firewall", "vpn_firewall")
        | parse-kv Substring as(src: string, dst: string, mac: string, sport: string, dport: string, protocol: string, type: int) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | parse Substring with pattern1: string " src=" temp_restmessage: string
        | parse Substring with * "pattern: " pattern2: string " " temp_restmessage: string
        | extend NetworkIcmpCode_lookup = iff(protocol == 'icmp6', type, int(null))
        | extend type_icmp4 = iff(protocol == 'icmp', type, int(null))
        | lookup NetworkIcmpTypeLookup on NetworkIcmpCode_lookup
        | invoke _ASIM_ResolveICMPType('type_icmp4')
        | extend NetworkIcmpCode = coalesce(NetworkIcmpCode_lookup, NetworkIcmpCode)
        | extend NetworkIcmpType = iff(isnotempty(NetworkIcmpCode), coalesce(NetworkIcmpType_lookup, NetworkIcmpType), "")
        | extend pattern = coalesce(pattern1, pattern2)
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | extend
            SrcMacAddr = trim('"', mac),
            EventType = "Flow";
    let IDSAlertData = PreFilteredData
        | where LogType in ("ids-alerts", "security_event")
        | parse LogMessage with * "security_event " LogSubType: string " " * "message: " message: string 
        | where LogType == "security_event" and LogSubType == "ids-alerted" or LogType == "ids-alerts"
        | parse-kv Substring as(priority: string, timestamp: string, direction: string, protocol: string, src: string, dst: string, signature: string, dhost: string, shost: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend EventResult = "Success"
        | extend
            priority = trim('"', priority),
            direction = trim('"', direction)
        | lookup EventSeverityPriorityLookup on priority
        | lookup NetworkDirectionLookup on direction
        | extend AdditionalFields = bag_pack(
                                "signature", trim('"', signature)
                            )
        | extend
            SrcMacAddr = trim('"', shost),
            DstMacAddr = trim('"', dhost),
            EventMessage = trim('"', message);
    let AirmarshalEvents = PreFilteredData
        | where LogType in ("airmarshal_events")
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | parse-kv temp_message as(src: string, dst: string, wired_mac: string, vlan_id: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend
            SrcMacAddr = trim('"', src),
            DstMacAddr = trim('"', dst),
            DvcMacAddr = trim('"', wired_mac)
        | extend
            EventResult = "Success",
            EventSeverity = "High";
    let EventsData = PreFilteredData
        | where LogType == "events";
    let EventsData_associ = EventsData
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType == "association" or (LogSubType == "disassociation" and not(Substring has_any ("auth_neg_failed", "dhcp")))
        | parse-kv Substring as (last_known_client_ip: string, client_mac: string, identity: string, aid: string, duration: string, ip_src: string, dns_server: string, reason: string, rssi: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend AdditionalFields = bag_pack(
                                "aid", aid,
                                "rssi", rssi
                            )
        | extend SrcMacAddr = trim('"', client_mac)
        | lookup EventResultLookup on LogSubType
        | extend EventResult = EventResult_type
        | lookup EventResultDetailsLookup on reason
        | extend EventResultDetails = iff((toint(reason) >= 25 and toint(reason) <= 31) or (toint(reason) >= 25 and toint(reason) <= 31), "Unknown", EventResultDetails);
    let EventsData_space = EventsData
        | where Substring has "Blocked DHCP server response" or (Substring has "VRRP packet" and not(Substring in~ ("VRRP passive", "VRRP active"))) 
        | parse Substring with LogSubType1: string " from" temp_addr1: string " on VLAN " vlan_id1: string " " restmessage
        | parse Substring with LogSubType2: string " from" temp_addr2: string " on VLAN " vlan_id2: string
        | extend LogSubType = coalesce(LogSubType1, LogSubType2)
        | extend LogSubType = iff(LogSubType has "VRRP Packet", "Virtual router collision", LogSubType)
        | extend pattern = iff(Substring has "Blocked", "Blocked", "")
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | lookup EventResultLookup on LogSubType
        | extend EventResult = coalesce(EventResult, EventResult_type)
        | extend temp_addr = coalesce(trim('"', temp_addr1), trim('"', temp_addr2))
        | extend vlan_id = coalesce(trim('"', vlan_id1), trim('"', vlan_id2))
        | extend SrcMacAddr = iff(temp_addr matches regex "(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))", temp_addr, "")
        | parse temp_addr with *  "[" temp_ip "]:" temp_port 
        | extend SrcIpAddr = case(
                        temp_addr has ".",
                        split(temp_addr, ":")[0],
                        isnotempty(temp_ip),
                        temp_ip,
                        temp_addr
                    )
        | extend SrcPortNumber = toint(case(
                            isnotempty(temp_port),
                            temp_port,
                            temp_addr has ".",
                            split(temp_addr, ":")[1],
                            ""
                        )
                    )
        | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
        | extend EventMessage = Substring;
    union
        FlowsFirewallData,
        IDSAlertData,
        EventsData_associ,
        EventsData_space,
        AirmarshalEvents
    | lookup NetworkProtocolLookup on protocol
    | invoke _ASIM_ResolveNetworkProtocol('protocol')
    | extend NetworkProtocol = iff(isempty(NetworkProtocolNumber), NetworkProtocol_lookup, NetworkProtocol)
    | extend 
        Epoch = tostring(Parser[0]),
        Device = tostring(Parser[1])
    | extend
        Epoch = iff(isnotempty(column_ifexists("timestamp", "")), timestamp, Epoch)
    | extend
        EpochTimestamp = split(Epoch, ".")
    | extend
        EventStartTime = unixtime_seconds_todatetime(tolong(EpochTimestamp[0]))
    | extend temp_srcipport= coalesce(src, ip_src, last_known_client_ip) 
    | extend temp_srcipport =  trim('"', temp_srcipport)
    | parse temp_srcipport with *  "[" temp_srcip "]:" temp_srcport
    | extend SrcIpAddr = case(
                        temp_srcipport has ".",
                        split(temp_srcipport, ":")[0], 
                        isnotempty(SrcIpAddr),
                        SrcIpAddr,
                        coalesce(temp_srcip, temp_srcipport)
                    )
    | extend SrcPortNumber = iff(isempty(SrcPortNumber), toint(coalesce(sport, temp_srcport)), SrcPortNumber)
    | extend SrcPortNumber = toint(iff(isempty(SrcPortNumber) and SrcIpAddr has ".", split(temp_srcipport, ":")[1], SrcPortNumber))
    | extend temp_dstipport = coalesce(dst, dns_server)
    | extend temp_dstipport =  trim('"', temp_dstipport)
    | parse temp_dstipport with * "[" temp_dstip "]:" temp_dstport
    | extend DstIpAddr = iff(temp_dstipport has ".", split(temp_dstipport, ":")[0], coalesce(temp_dstip, temp_dstipport))
    | extend DstPortNumber = toint(coalesce(dport, temp_dstport))
    | extend DstPortNumber = toint(iff(isempty(DstPortNumber) and DstIpAddr has ".", split(temp_dstipport, ":")[1], DstPortNumber))
    | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
    | extend DstIpAddr = iff(DstIpAddr == DstMacAddr, "", DstIpAddr)
    | extend 
        EventMessage = iff(
                LogSubType has_any("Blocked DHCP server", "Virtual router collision"),
                Substring,
                coalesce(message, "")
            ),
        SrcUsername = trim('"', identity),
        SrcVlanId = trim('"', vlan_id)
    | extend
        EventSeverity = case(
                    isnotempty(EventSeverity),
                    EventSeverity,
                    EventResult == "Failure",
                    "Low",
                    "Informational"
                ),
        EventType = iff(isnotempty(EventType), EventType, "NetworkSession"),
        SrcUsernameType = iff(isnotempty(SrcUsername), "Simple", "")
    | invoke _ASIM_ResolveDvcFQDN('Device')
    | extend
        Dvc = DvcHostname,
        Src = coalesce(SrcIpAddr, SrcMacAddr),
        Dst = coalesce(DstIpAddr, DstMacAddr),
        NetworkDuration = toint(todouble(duration) * 1000)
    | project-rename
        EventOriginalType = LogType,
        EventOriginalSubType = LogSubType
    | extend
        EventEndTime = EventStartTime,
        EventCount = int(1),
        EventProduct = "Meraki",
        EventVendor = "Cisco",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        EventUid = _ResourceId
    | project-away
        LogMessage,
        Parser,
        Epoch,
        EpochTimestamp,
        Device,
        Substring,
        protocol,
        priority,
        reason,
        direction,
        duration,
        src,
        dst,
        dns_server,
        sport,
        dport,
        *_lookup,
        type*,
        pattern*,
        last_known_client_ip,
        ip_src,
        client_mac,
        mac,
        shost,
        dhost,
        wired_mac,
        identity,
        temp*,
        vlan_id*,
        LogSubType1,
        LogSubType2,
        restmessage*,
        message,
        rssi,
        aid,
        signature,
        timestamp,
        EventResult_type,
        TenantId,
        SourceSystem,
        Computer,
        _ResourceId,
        MG,
        EventTime,
        Facility,
        HostName,
        SeverityLevel,
        ProcessID,
        HostIP,
        ProcessName,CollectorHostName,NetworkProtocolNumber
};
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCorelightZeek
// Description: This ASIM parser supports normalizing Corelight Zeek Connection logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCorelightZeek(    ['disabled']:bool=false)
{
let NetworkDirectionLookup = datatable(local_orig: bool, local_resp: bool, NetworkDirection: string)
[
  false, true, 'Inbound',
  true, false, 'Outbound',
  true, true, 'Local',
  false, false, 'Local'
];
let ResultLookup = datatable (conn_state:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string, EventSeverity:string)
[ 
   'S0', 'Success', '', 'Connection attempt seen, no reply', 'Informational',
   'S1', 'Success', '', 'Connection established, not terminated', 'Informational',
   'SF', 'Success', 'Terminated', 'Normal establishment and termination', 'Informational', // Note that this is the same symbol as for state S1. You can tell the two apart because for S1 there will not be any byte counts in the summary, while for SF there will be.
   'REJ', 'Failure', 'Rejeced', 'Connection attempt rejected', 'Low',
   'S2', 'Failure', 'Terminated', 'Connection established and close attempt by originator seen (but no reply from responder)', 'Low',
   'S3', 'Failure', 'Terminated', 'Connection established and close attempt by responder seen (but no reply from originator)', 'Low',
   'RSTO', 'Failure', 'Reset', 'Connection established, originator aborted (sent a RST)', 'Low',
   'RSTR', 'Failure', 'Reset', 'Responder sent a RST', 'Low',
   'RSTOS0', 'Failure', 'Reset', 'Originator sent a SYN followed by a RST, no SYN-ACK from the responder','Low',
   'RSTRH', 'Failure', 'Reset', 'Responder sent a SYN ACK followed by a RST, no SYN from the originator','Low',
   'SH', 'Failure', 'Timeout', 'Originator sent a SYN followed by a FIN, no SYN ACK from the responder', 'Low',
   'SHR', 'Failure', 'Timeout', 'Responder sent a SYN ACK followed by a FIN, no SYN from the originator', 'Low',
   'OTH', 'Success', '', 'No SYN seen, just midstream traffic', 'Informational'
];
let parser=(disabled:bool=false){
  Corelight_CL | where not(disabled)
  | where (Message has '"_path":"conn"' or Message has '"conn_red"')
  | project Message
  | parse-kv Message as (
      ['"_system_name"']:string,
      ['"_write_ts"']:datetime,
      ['"ts"']:datetime,
      ['"uid"']:string,
      ['"id.orig_h"']:string,
      ['"id.orig_p"']:int,
      ['"id.resp_h"']:string,
      ['"id.resp_p"']:int,
      ['"proto"']:string,
      ['"service"']:string,
      ['"duration"']:int,
      ['"orig_bytes"']:long,
      ['"resp_bytes"']:long,
      ['"local_orig"']:bool,
      ['"local_resp"']:bool,
      ['"missed_bytes"']:long,
      ['"history"']:string,
      ['"orig_pkts"']:long,
      ['"resp_pkts"']:long,
      ['"orig_l2_addr"']:string,
      ['"resp_l2_addr"']:string,
      ['"community_id']:string,
      ['"conn_state"']:string,
      ['"vlan"']:string,
      ['"inner_vlan"']:string
  ) 
  with (quote = '"')
  | extend 
      EventCount=int(1),
      EventProduct="Zeek",
      EventVendor="Corelight",
      EventSchema = "NetworkSession",
      EventSchemaVersion="0.2.4",
      EventType="Flow"
  | project-rename
      EventStartTime= ['"ts"'],
      EventEndTime = ['"_write_ts"'],
      EventOriginalUid = ['"uid"'],
      SrcIpAddr = ['"id.orig_h"'],
      SrcPortNumber = ['"id.orig_p"'],
      DstIpAddr = ['"id.resp_h"'],
      DstPortNumber = ['"id.resp_p"'],
      NetworkProtocol = ['"proto"'],
      NetworkApplicationProtocol = ['"service"'],
      NetworkDuration = ['"duration"'],
      SrcBytes = ['"orig_bytes"'],
      DstBytes = ['"resp_bytes"'],
      local_orig = ['"local_orig"'],
      local_resp = ['"local_resp"'],
      FlowMissedBytes = ['"missed_bytes"'],
      SrcPackets = ['"orig_pkts"'],
      DstPackets = ['"resp_pkts"'],
      SrcMacAddr = ['"orig_l2_addr"'],
      DstMacAddr = ['"resp_l2_addr"'],
      DstVlanId = ['"vlan"'],
      SrcVlanId = ['"inner_vlan"'], 
      conn_state = ['"conn_state"'],
      FlowHistory = ['"history"'],
      NetworkSessionId = ['"community_id'],
      Dvc = ['"_system_name"']
  | lookup NetworkDirectionLookup on local_orig, local_resp
  | lookup ResultLookup on conn_state
  | extend
      NetworkBytes = SrcBytes + DstBytes,
      NetworkPackets = SrcPackets + DstPackets,
      NetworkProtocol = toupper(NetworkProtocol)
  // Aliases
  | extend 
      IpAddr=SrcIpAddr,
      Src=SrcIpAddr,
      Duration=NetworkDuration,
      SessionId = NetworkSessionId,
      InnerVlanId = SrcVlanId,
      OuterVlanId = DstVlanId,
      Dst=DstIpAddr
  | project-away Message, local_orig, local_resp, conn_state
};
parser (disabled=disabled)
}



//
// Function Name: ASimNetworkSessionCrowdStrikeFalconHost
// Description: This ASIM parser supports normalizing CrowdStrike Falcon Endpoint Protection logs to the ASIM Network Session normalized schema. These events are captured through CrowdStrike Falcon Endpoint Protection data connector which allows you to easily connect your CrowdStrike Falcon Event Stream with Microsoft Sentinel.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionCrowdStrikeFalconHost(    ['disabled']:bool=false)
{
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
[
    "0", "Informational",
    "1", "Informational",
    "2", "Low",
    "3", "Medium",
    "4", "High",
    "5", "High"
];
let EventFieldsLookup = datatable (
    ruleAction: int,
    DvcOriginalAction: string,
    DvcAction: string,
    EventResult: string
)
    [
    0, "invalid", "Deny", "Failure",
    1, "allowed", "Allow", "Success",
    2, "blocked", "Deny", "Failure"
];
//ActionLokkup is prepapred by considering facts as below:
//Response bit: KILL PROCESS, modifier bit: '', DvcAction: Deny
//Response bit: KILL PROCESS, modifier bit: POLICY_DISABLED, DvcAction: Allow as here process would have been killed or blocked if policy was enabled so current event is not killed.
let ActionLookup = datatable (
    EventOutcome: string,
    DvcOriginalAction: string,
    DvcAction: string,
    EventResult: string
)
    [
    "0", "Detection", "Allow", "Success",
    "2", "Detection", "Allow", "Success",
    "16", "Prevention-killed", "Deny", "Failure",
    "128", "Quarantine", "Allow", "Success",
    "144", "Prevention-killed,quarantine", "Deny", "Failure",
    "272", "Detection", "Allow", "Success",
    "400", "Detection-quarantine", "Allow", "Success",
    "512", "Prevention-killed", "Deny", "Failure",
    "640", "Prevention-killed,quarantine", "Deny", "Failure",
    "768", "Detection", "Allow", "Success", 
    "1024", "Prevention-blocked", "Deny", "Failure",
    "1040", "Prevention-killed,blocked", "Deny", "Failure",
    "1152", "Prevention-blocked,quarantine", "Deny", "Failure",
    "1168", "Prevention-killed,blocked,quarnatine", "Deny", "Failure",
    "1280", "Detection", "Allow", "Success",
    "1296", "Detection", "Allow", "Success",
    "2048", "Prevention-blocked", "Deny", "Failure",
    "2176", "Prevention-quarantine,blocked ", "Deny", "Failure",
    "2304", "Detection", "Allow", "Success",
    "2432", "Detection-quarantine", "Allow", "Success",
    "4096", "Prevention-blocked", "Deny", "Failure",
    "4112", "Prevention-blocked,killed", "Deny", "Failure",
    "4224", "Prevention-blocked,quarantine", "Deny", "Failure",
    "4240", "Prevention-killed,blocked,quarantine", "Deny", "Failure",
    "4352", "Detection", "Allow", "Success",
    "4368", "Detection", "Allow", "Success",
    "4638", "Detection", "Allow", "Success",
    "5120", "Prevention-blocked", "Deny", "Failure",
    "8192", "Disabled", "Allow", "Success",
    "8208", "Detection", "Allow", "Success",
    "8320", "Detection-quarnatine", "Allow", "Success",
    "8704", "Detection", "Allow", "Success",
    "9216", "Detection", "Allow", "Success",
    "10240", "Detection", "Allow", "Success",
    "12304", "Detection", "Allow", "Success",
    "16400", "Killed", "Deny", "Failure",
    "32768", "Prevention-blocked", "Deny", "Failure",
    "32896", "Prevention-blocked,quarantine", "Deny", "Failure",
    "33024", "Detection", "Allow", "Success",
    "65536", "Downgraded", "Allow", "Success",
    "65552", "Prevention-killed", "Deny", "Failure",
    "65792", "Detection-downgraded", "Allow", "Success",
    "65808", "Detection-downgraded", "Allow", "Success",
    "73728", "Detection-downgraded", "Allow", "Success",
    "73744", "Detection-downgraded", "Allow", "Success",
    "131088", "Prevention-killed", "Deny", "Failure",
    "131216", "Prevention-killed,quarantine", "Deny", "Failure",
    "131584", "Prevention-killed", "Deny", "Failure",
    "131712", "Prevention-killed,quarantine", "Deny", "Failure",
    "2099200", "Prevention-blocked", "Deny", "Failure",
    "2099328", "Prevention-blocked,quarantine", "Deny", "Failure",
    "4196352", "Prevention-blocked", "Deny", "Failure",
    "4196480", "Prevention-blocked,quarantine", "Deny", "Failure",
    "1048576", "Prevention-suspend", "Deny", "Failure",
    "524288", "Prevention-suspend", "Deny", "Failure",
    "262144", "Blocking Disabled", "Allow", "Success",
    "16384", "Safeguard Enabled", "Allow", "Success",
    "131072", "Kill Failed", "Deny", "Failure",
    "256", "Policy Disabled", "Allow", "Success",
    "2097152", "Response Action Already Applied", "Deny", "Failure",
    "4194304", "Response Failed", "Deny", "Failure"
];
let parser = (disabled: bool=false) {
    let alldata = CommonSecurityLog
        | where not(disabled)
            and DeviceVendor == "CrowdStrike"
            and DeviceProduct == "FalconHost"
        | where DeviceEventClassID in ("Network Access In A Detection Summary Event", "FirewallMatchEvent");
    let firewalldata = alldata
        | where DeviceEventClassID == "FirewallMatchEvent"
        | parse-kv AdditionalExtensions as (deviceId: string, cmdLine: string, connectionDirection: int, eventType: string, hostName: string, icmpCode: int, icmpType: string, localAddress: string, localPort: int, matchCount: int, networkProfile: string, protocol: int, remoteAddress: string, remotePort: int, ruleAction: int, ruleDescription: string, ruleGroupName: string, ruleName: string, status: string) with (pair_delimiter=";", kv_delimiter="=")
        | extend
            EventCount = matchCount,
            EventStartTime = unixtime_milliseconds_todatetime(tolong(ReceiptTime)),
            NetworkDirection = case(
                    connectionDirection == 1, "Inbound",
                    connectionDirection == 2, "Outbound",
                    ""
                ),
            SrcIpAddr = case(
                connectionDirection == 1, remoteAddress,
                connectionDirection == 2, localAddress,
                ""
            ),
            SrcPortNumber = case(
                    connectionDirection == 1, remotePort,
                    connectionDirection == 2, localPort,
                    int(null)
                ),
            DstIpAddr = case(
                connectionDirection == 1, remoteAddress,
                connectionDirection == 2, localAddress,
                ""
            ),
            DstPortNumber = case(
                    connectionDirection == 1, localPort,
                    connectionDirection == 2, remotePort,
                    int(null)
                ),
            deviceIp = iff(hostName matches regex "(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))", hostName, "")
        | extend 
            hostName = iff(isempty(deviceIp), hostName, ""),
            AdditionalFields = bag_pack(
                  "networkProfile", networkProfile,
                  "ruleDescription", ruleDescription,
                  "ruleGroupName", ruleGroupName,
                  "cmdLine", cmdLine
              ),
            NetworkIcmpCode = icmpCode
        | invoke _ASIM_ResolveDvcFQDN('hostName')
        | invoke _ASIM_ResolveNetworkProtocol('protocol')
        | extend NetworkIcmpType = _ASIM_LookupICMPType('icmpType')
        | lookup EventFieldsLookup on ruleAction
        | project-rename
            DvcId = deviceId,
            DvcIpAddr = deviceIp,
            EventOriginalSubType = eventType,
            NetworkRuleName = ruleName
        | extend
            Rule = NetworkRuleName,
            Dvc = coalesce(DvcId, DvcHostname, DvcIpAddr);
    let networkaccessdata = alldata
        | where DeviceEventClassID has "Network Access In A Detection Summary Event"
        | parse-kv AdditionalExtensions as (CSMTRPatternDisposition: string, tactic: string, technique: string, objective: string) with (pair_delimiter=";", kv_delimiter="=")
        | lookup ActionLookup on EventOutcome
        | invoke _ASIM_ResolveSrcFQDN('DestinationHostName')
        | extend
            EventStartTime = todatetime(DeviceCustomDate1),
            DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
            SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
            EventCount = int(1),
            SrcDomain = coalesce(DestinationNTDomain, SrcDomain),
            EventOriginalResultDetails = CSMTRPatternDisposition,
            SrcProcessId = tostring(FieldDeviceCustomNumber2),
            SrcDomainType = iff(isnotempty(DestinationNTDomain), "Windows", SrcDomainType),
            AdditionalFields = bag_pack(
                    "CSMTRPatternDisposition", CSMTRPatternDisposition, 
                    "Tactic", coalesce(tactic, Activity),
                    "Technique", coalesce(technique, DeviceAction),
                    "Objective", coalesce(objective, Reason),
                    DeviceCustomString6Label, DeviceCustomString6
                )
        | project-rename
            DvcId = ExtID,
            DstPortNumber = DestinationPort,
            SrcPortNumber = SourcePort,
            SrcMacAddr = SourceMACAddress,
            SrcUsername = DestinationUserName,
            SrcProcessName = FileName
        | extend
            Dvc = DvcId,
            Hostname = SrcHostname,
            User = SrcUsername,
            SrcAppId = SrcProcessId,
            SrcAppName = SrcProcessName,
            SrcAppType = "Process",
            SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
            SrcUsernameType = _ASIM_GetUsernameType(SrcUsername);
    union firewalldata, networkaccessdata
    | lookup EventSeverityLookup on LogSeverity
    | extend NetworkProtocolVersion = case(
                                    DstIpAddr contains ".", "IPv4",
                                    DstIpAddr contains ":", "IPv6",
                                    ""
                                )
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventVendor = "CrowdStrike",
        EventProduct = "FalconHost",
        EventType = "EndpointNetworkSession"
    | project-rename
        EventOriginalType = DeviceEventClassID,
        EventProductVersion = DeviceVersion,
        EventUid = _ItemId,
        EventOriginalSeverity= LogSeverity
    | extend
        EventEndTime = EventStartTime,
        Dst = DstIpAddr,
        Src = coalesce(SrcFQDN, SrcHostname, SrcIpAddr),
        IpAddr = SrcIpAddr,
        DvcIdType = iff(isnotempty(DvcId), "Other", "")
    | project-away
        Source*,
        Destination*,
        Device*,
        AdditionalExtensions,
        CommunicationDirection,
        Computer,
        EndTime,
        FieldDevice*,
        Flex*,
        File*,
        Old*,
        MaliciousIP*,
        OriginalLogSeverity,
        Process*,
        Protocol,
        Activity,
        ReceivedBytes,
        SentBytes,
        Remote*,
        Request*,
        SimplifiedDeviceAction,
        StartTime,
        TenantId,
        Threat*,
        ExternalID,
        ReportReferenceLink,
        ReceiptTime,
        Reason,
        ApplicationProtocol,
        _ResourceId,
        ExtID,
        Message,
        EventOutcome,
        IndicatorThreatType,
        cmdLine,
        connectionDirection,
        hostName,
        matchCount,
        networkProfile,
        protocol,
        ruleAction,
        ruleDescription,
        ruleGroupName,
        icmpCode,
        icmpType,
        status,
        CSMTRPatternDisposition,
        NetworkProtocolNumber,
        localAddress,
        localPort,
        remoteAddress,
        remotePort
};
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionForcePointFirewall
// Description: This ASIM parser supports normalizing Force Point Firewall logs coming from CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionForcePointFirewall(    ['disabled']:bool=false)
{
let ApplicationProtocolLookup=datatable(ApplicationProtocol:string,NetworkApplicationProtocol:string)
   [
         "HTTPS","HTTPS",
         "HTTP-Over-QUIC","HTTP",
         "HTTP","HTTP",
         "DNS Over TLS","DNS",
         "HTTP proxy","HTTP",
         "IMAPS","IMAPS",
         "SMTP","SMTP",
         "IMAP","IMAP",
         "POP3S","POP3",
         "SMTP Submission Service","SMTP",
         "X11","X11",
         "RTSP","RTSP",
         "Telnet","TELNET",
         "NNTP","NNTP",
         "ISAKMP","ISAKMP","ISAKMP","ISAKMP",
         "POP3","POP3",
         "BGP","BGP",
         "FTP","FTP",
         "RIP","RIP",
         "Squid HTTP proxy","HTTP",
         "TFTP","TFTP",
         "QOTD","QOTD",
         "SCCP","SCCP",
         "Modbus","MODBUS",
         "SVN","SVN",
         "RADIUS (Accounting)","RADIUS",
         "Kerberos","KERBEROS",
         "GRE","GRE",
         "UUCP-rlogin","UUCP",
         "GTP User Data Tunneling","GTP",
         "NNTPS","NNTP",
         "GTP Control","GTP",
         "IRC-default","IRC",
         "FTPS (Control)","FTPS",
         "ICCP","ICCP",
         "IRCS","IRC",
         "Telnets","TELNET",
         "Finger","FINGER",
         "ESP","ESP",
         "Rlogin","RLP",
         "IMAP3","IMAP",
         "MGCP","MGCP",
         "RADIUS Accounting (Old)","RADIUS",
         "RADIUS (Old)","RADIUS",
         "CVS","CVS",
         "Ident","IDENT",
         "Gopher","GOPHER",
         "BGMP","BGMP",
         "FTPS (Data)","FTPS",
         "POP2","POP",
         "TLISRV","TLISRV",
         "INGRES-NET","INGRES-NET",
         "IPIP","IPIP",
         "XTP","XTP",
         "UUCP","UUCP",
         "IRC","IRC",
         "Photuris (ICMP)","ICMP",
         "TACACS-DS","TACACS-DS",
         "WESP","WESP",
         "EGP","EGP",
         "WSN","WSN",
         "XDMCP","XDMCP",
         "Kerberos IV","KERBEROS",
         "IRTP","IRTP",
         "TTP","TTP",
         "IRC-SERV","IRC",
         "I-NLSP","NLSP",
         "SNP","SNP",
         "XNS-IDP","XNS",
         "SECURE-VMTP","VMTP",
         "VMTP","VMTP",
         "IPLT","IPLT",
         "GGP","GGP",
         "MFE-NSP","NSP",
         "HIP","HIP",
         "MERIT-NSP","NSP",
         "NSFNET-IGP","IGP",
         "DCN-MEAS","DCN",
         "STP","STP",
         "SRP","SRP",
         "HMP","HMP",
         "XNET","XNET",
         "VRRP","VRRP",
         "ENCAP","ENCAP",
         "CPNX","CPNX",
         "PTP","PTP",
         "SKIP","SKIP",
         "SCPS","SCPS",
         "Sprite-RPC","RPC",
         "IPv6 ICMP","ICMP",
         "MUX","MUX",
         "CHAOS","CHAOS",
         "SSCOPMCE","SSCOPMCE",
         "CBT","CBT",
         "SPS","SPS",
         "ETHERIP","ETHERIP",
         "MTP","MTP",
         "ROHC","ROHC",
         "CRTP","CRTP",
         "PNNI","PNNI",
         "NETBLT","NETBLT",
         "TLSP","TLSP",
         "IDPR","IDPR",
         "DDX","DDX",
         "PUP","PUP",
         "DSR","DSR",
         "NARP","NARP",
         "CPHB","CPHB",
         "SMP","SMP",
         "L2TP","L2TP",
         "IPv6 ICMP/143/0","ICMP",
         "MICP","MICP",
         "GMTP","GMTP",
         "LARP","LARP",
         "IFMP","IFMP",
         "IGP","IGP",
         "CFTP","CFTP",
         "PGM","PGM",
         "DDP","DDP",
         "PIPE","PIPE",
         "IATP","IATP",
         "IGMP","IGMP",
         "3PC","3PC",
         "DGP","DGP",
         "TCF","TCF",
         "UTI","UTI",
         "DCCP","DCCP",
         "SWIPE","SWIPE",
         "EMCON","EMCON",
         "PIM","PIM",
         "RVD","RVD",
   ];
 let ActionLookup=datatable(DeviceAction:string,DvcAction_ActionLookup:string,EventResult_ActionLookup:string,EventSeverity_ActionLookup:string)
 [
           "Allow","Allow","Success","Informational",          
           "Discard","Drop","Failure","Low",
           "Permit","Allow","Success","Informational",          
           "Refuse","Deny","Failure","Low",
           "Terminate","Reset Source","Failure","Low",          
           "Terminate (failed)","","Failure","Low",
           "Terminate (passive)","Reset Destination","Failure","Low",          
           "Terminate (reset)","Reset","Failure","Low",
           "Wait for Authentication","","Success","Informational",
           "Wait for Further Actions","","Success","Informational",          
           "Wait for RPC Reply","","Success","Informational"
 ];
 let DeviceEventClassIDLookup_Packet=datatable(DeviceEventClassID:string,EventSubType:string,DvcAction_DeviceEventClassIDLookup:string,EventResult_DeviceEventClassIDLookup:string,EventSeverity_DeviceEventClassIDLookup:string) //Add more codes if needed
 [
           "70018","Start","Allow","Success","Informational", // Connection_Allowed
           "70019","End","Deny","Failure","Low", // Connection_Discarded
           "70021","End","Reset","Failure","Low", // Connection_Closed
           "70022","End","Reset","Failure","Low", // Connection_Closed-Abnormally
           "70026","","","Success","Informational", // Connection_Progress
 ];
 let DeviceEventClassIDLookup_File=datatable(DeviceEventClassID:string,DvcAction_DeviceEventClassIDLookup:string,EventResult_DeviceEventClassIDLookup:string,EventSeverity_DeviceEventClassIDLookup:string)
 [
           "76506","Allow","Success","Informational", // File_Allowed
           "76508","Deny","Failure","Low", // File_Malware-Blocked
           "76509","","Failure","Low" // File_Malware-Detected
 ];
 let MessageLookup = datatable (Message:string, DvcAction_MessageLookup:string, EventResult_MessageLookup:string, EventResultDetails:string, EventOriginalResultDetails:string)  
 [
         "Connection dropped", "Drop", "Failure","Terminated", "Connection dropped",
         "Connection removed because NGFW Engine is low on memory.","Drop", "Failure","Terminated","Connection removed because NGFW Engine is low on memory.",
         "Connection timeout in state TCP_CLOSE_WAIT", "", "Success", "Timeout",	"One end of the Connection waits for the FIN packet (passive close).",
         "Connection timeout in state TCP_CLOSE_WAIT_ACK", "", "Success", "Timeout", "One end of the Connection waits for the FIN packet (passive close)",
         "Connection timeout in state TCP_CLOSING", "", "Success", "Timeout", "Closing packet (FIN) sent by one end of the Connection (simultaneous).",
         "Connection timeout in state TCP_CLOSING_ACK", "", "Success", "Timeout", "Waiting for ACK for the FIN before going to closing status (active close).",
         "Connection timeout in state TCP_ESTABLISHED", "", "Failure", "Timeout", "Normal status of TCP Connections for data transfer.",
         "Connection timeout in state TCP_FIN_WAIT_1", "", "Success", "Timeout",	"One end of the Connection waits for sending the FIN packet (active close).",
         "Connection timeout in state TCP_FIN_WAIT_2", "", "Success", "Timeout", "One end of the Connection waits for receiving ACK packet.",
         "Connection timeout in state TCP_LAST_ACK", "",	"Success", "Timeout", "One end of the Connection sent a FIN packet (passive close).",
         "Connection timeout in state TCP_LAST_ACK_WAIT", "", "Failure",	"Timeout", "Waiting for the FIN packet to be acknowledged.",
         "Connection timeout in state TCP_SYN_ACK_SEEN", "", "Failure",	"Timeout", "Second phase of the TCP three-way handshake, the server has replied to client sent SYN with SYN+ACK, next status will be established.",
         "Connection timeout in state TCP_SYN_FIN_SEEN", "",	"Success", "Timeout", "T/TCP (Transactional TCP) Connection, RFC 1644.",
         "Connection timeout in state TCP_SYN_RETURN", "", "Failure", "Timeout", "Received simultaneous SYN from the other end (simultaneous open).",
         "Connection timeout in state TCP_SYN_SEEN", "", "Failure", "Timeout", "First packet sent by one end of the Connection.",
         "Connection timeout in state TCP_TIME_WAIT", "", "Success", "Timeout", "One end of the Connection acknowledged closing packet (FIN).",
         "Connection timeout in state TCP_TIME_WAIT_ACK", "", "Failure",	"Timeout", "Waiting for ACK for the FIN status before going to time wait status (active close).",
         "Connection timeout in state ICMP_ECHO", "", "Failure", "Timeout", "Ping reply is expected.",
         "Connection timeout in state ICMP_REPLY_WAIT", "", "Failure", "Timeout", "Other ICMP request or reply types.",
         "Connection was reset by client", "Reset Source", "Failure","Reset", "",
         "Connection was reset by server", "Reset Destination", "Failure","Reset", "",
         "invalid packet (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [A] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [FA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [FPA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [PA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [RA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [SA] (CT)", "", "Failure", "Invalid TCP", "",
         "TCP state violation","Deny","Failure", "Invalid TCP", "",
         "TCP state violation: Connection end-point replied with ACK to SYN-packet. Connection refused.", "Deny", "Failure", "Invalid TCP", "",
         "TSC error: Query timed out", "", "Failure", "Timeout", ""
 ];
 let parser = (disabled:bool) { 
 let ForcePointNetwork = CommonSecurityLog
         | where not(disabled)
         | where DeviceVendor=="FORCEPOINT" and DeviceProduct=="Firewall"
         | where DeviceFacility in~ ("Inspection","Packet Filtering","File Filtering") and isnotempty(DeviceEventClassID) and DeviceEventClassID != "0" 
         ;
 let PacketFilteringData = ForcePointNetwork
         | where DeviceFacility == "Packet Filtering" and DeviceEventClassID !in ("70383","70393","70734","71009","71040")
         | lookup DeviceEventClassIDLookup_Packet on DeviceEventClassID
         | lookup MessageLookup on Message
         | extend DvcAction = coalesce(DvcAction_MessageLookup, DvcAction_DeviceEventClassIDLookup), 
                 EventResult = case (Message startswith "Referred connection not known", "Failure",
                                     coalesce(EventResult_MessageLookup, EventResult_DeviceEventClassIDLookup)), 
                 EventSeverity = case(Message startswith "Referred connection not known", "Low",
                                     EventSeverity_DeviceEventClassIDLookup),
                 EventOriginalResultDetails = case(Message startswith "Referred connection not known", Message,
                                                 EventOriginalResultDetails),
                 EventType = "NetworkSession"
         | project-away DvcAction_*, EventResult_*, EventSeverity_DeviceEventClassIDLookup;
 let FileFilteringData = ForcePointNetwork
         | where DeviceFacility == "File Filtering"
         | lookup DeviceEventClassIDLookup_File on DeviceEventClassID
         | extend ThreatName = case (DeviceEventClassID in ("76508", "76509"), Activity,
                                     "")
         | project-rename DvcAction = DvcAction_DeviceEventClassIDLookup
         | extend EventResult = case(isnotempty(Message), "Failure",
                                     EventResult_DeviceEventClassIDLookup), 
                  EventSeverity = case(isnotempty(Message), "Low",
                                     EventSeverity_DeviceEventClassIDLookup),
                  EventOriginalResultDetails = case(isnotempty(Message), Message,
                                                 ""),
                 EventType = "NetworkSession"
         | project-away *_DeviceEventClassIDLookup;
 let InspectionData = ForcePointNetwork
         | where DeviceFacility == "Inspection" or DeviceEventClassID == "70734"
         | extend MessageCode = toint(DeviceEventClassID)
         | extend EventSeverity = case (DeviceAction in~ ("Allow","Permit"), "Informational",
                                     MessageCode >= 200000, "High",
                                     MessageCode < 200000, "Low",
                                     ""),
                 EventType = case (MessageCode < 80000, "NetworkSession",
                                  "IDS")
         | extend ThreatName = Activity
         | project-away MessageCode;
 union PacketFilteringData, FileFilteringData, InspectionData
         | extend NetworkProtocol = _ASIM_LookupNetworkProtocol(Protocol)
         | lookup ActionLookup on DeviceAction
         | extend DvcAction = coalesce(DvcAction,DvcAction_ActionLookup), 
                  EventResult = coalesce(EventResult,EventResult_ActionLookup), 
                  EventSeverity = coalesce(EventSeverity, EventSeverity_ActionLookup)
         | project-away *_ActionLookup
         | lookup ApplicationProtocolLookup on ApplicationProtocol
         | extend 
                 EventCount = toint(1),
                 EventSchema = "NetworkSession",
                 EventSchemaVersion = "0.2.6",
                 EventVendor = "Forcepoint",
                 EventProduct = "Firewall"
         | parse AdditionalExtensions with * "requestURL=" requestURL            
         | project-rename
                 EventOriginalType = DeviceEventClassID,
                 DstPortNumber = DestinationPort,
                 DstIpAddr = DestinationIP,
                 SrcPortNumber = SourcePort,
                 SrcIpAddr = SourceIP,
                 DstNatIpAddr = DestinationTranslatedAddress,
                 DstNatPortNumber = DestinationTranslatedPort,
                 SrcNatIpAddr = SourceTranslatedAddress,
                 SrcNatPortNumber = SourceTranslatedPort,
                 EventProductVersion = DeviceVersion,
                 EventMessage = Message,
                 DvcOriginalAction = DeviceAction,
                 SrcBytes = SentBytes,
                 DstBytes = ReceivedBytes,
                 EventOriginalSubType = DeviceFacility,
                 DvcId = DeviceExternalID,
                 DvcInboundInterface = DeviceInboundInterface,
                 DvcOutboundInterface = DeviceOutboundInterface,
                 DvcIpAddr = DeviceAddress,
                 EventOriginalSeverity = LogSeverity,
                 ThreatId = DeviceCustomString3
         | invoke _ASIM_ResolveDvcFQDN('Computer')
         | extend
                 ThreatCategory = column_ifexists("DeviceEventCategory",""),
                 EventStartTime = todatetime(ReceiptTime),
                 EventEndTime = todatetime(ReceiptTime),
                 ipv6_parts = extract_all (@'^\[(.+)\](?:\:(\d+))?$',requestURL)[0],
                 ipv4_parts = extract_all (@'^(\d+\.\d+\.\d+\.\d+)(?:\:(\d+))?$',requestURL)[0],
                 host_parts = extract_all (@'^([^\\\d:]+)(?:\:(\d+))?$',requestURL)[0]
         | extend 
                  NetworkRuleName = case(isnotempty(DeviceCustomString2), strcat(DeviceCustomString1,',',DeviceCustomString2),
                                         DeviceCustomString1),
                  DstDomainPart = tostring(host_parts[0]),
                  DstIpAddr = coalesce(DstIpAddr, tostring(ipv4_parts[0]), tostring(ipv6_parts[0])),
                  DstPortNumber = coalesce(DstPortNumber, toint(host_parts[1]), toint(ipv4_parts[1]), toint(ipv6_parts[1]))
         | invoke _ASIM_ResolveDstFQDN('DstDomainPart')
         | extend
                  DvcIdType = case(isnotempty(DvcId), "ForcepointId",
                                 ""),
                  DstPortNumber = case(
                                 isnotempty(DstPortNumber), DstPortNumber,
                                 ApplicationProtocol startswith "TCP", toint(split(ApplicationProtocol,'/')[1]),
                                 ApplicationProtocol startswith "UDP", toint(split(ApplicationProtocol,'/')[1]),
                                 int(null)),
                  AdditionalFields = pack(iff(isnotempty(RequestMethod) and RequestMethod != "UNKNOWN", "RequestMethod", ""),RequestMethod,
                                          iff(isnotempty(DeviceCustomString4),"VirusId",""),DeviceCustomString4),
                  DstAppName = case(DestinationServiceName in~ ("Generic-Web-HTTP","Application-Unknown","Unknown-Encrypted-Application"), "",
                                     DestinationServiceName),
                  DvcIpAddr = coalesce(DvcIpAddr,DeviceName)
         | extend
                 Dvc = DvcIpAddr,
                 IpAddr = SrcIpAddr,
                 Rule = NetworkRuleName,
                 Dst = DstIpAddr,
                 Src = SrcIpAddr,
                 DvcInterface = DvcInboundInterface,
                 Hostname = DstHostname
         | project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, Remote*, ReportReferenceLink, Request*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, ExtID, EventOutcome, FieldDevice*, Reason, ApplicationProtocol, Activity, requestURL, Computer, DstDomainPart, host_parts, ipv4_parts, ipv6_parts
     };
     parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionFortinetFortiGate
// Description: This ASIM parser supports normalizing Fortinet FortiGate logs to the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionFortinetFortiGate(    ['disabled']:bool=false)
{
let EventLookup=datatable(DeviceAction:string,DvcAction:string,EventResult:string,EventResultDetails:string)
[
  "accept","Allow","Success",""
  , "client-rst","Reset Source","Failure",""
  , "close","","Success",""
  , "deny","Deny","Failure",""
  , "ip-conn","","Failure","IP connection error"
  , "server-rst","Reset Destination","Failure",""
  , "timeout","","Failure",""
];
// -- See https://docs.fortinet.com/document/fortigate/7.2.4/fortios-log-message-reference/671442/cef-priority-levels
let SeverityLookup = datatable (EventOriginalSeverity:string, EventSeverity:string)
[
  "1", "Informational", // Debug
  "2", "Informational", // Information
  "3", "Informational", // Notification
  "4", "Low", // Warning
  "5", "Low", // Error
  "6", "Critical", // High
  "7", "Alert", // Medium
  "8", "High" // Emergency
];
let Parser=(disabled:bool=false){
   CommonSecurityLog
  | where not(disabled)
  | where DeviceVendor == "Fortinet" and DeviceProduct startswith "FortiGate" and (column_ifexists("DeviceEventCategory","") has "traffic"  or AdditionalExtensions has "cat=traffic")
  | where DeviceAction != "dns" and Activity !has "dns" 
  | parse Activity with "traffic:forward " temp_DeviceAction:string 
  | extend DeviceAction = coalesce(DeviceAction, temp_DeviceAction)  
  | lookup EventLookup on DeviceAction 
  | project Activity,AdditionalExtensions,DestinationIP,DestinationPort,DeviceAction,DeviceInboundInterface,DeviceOutboundInterface,DeviceProduct,DeviceVersion,LogSeverity,Protocol,ReceivedBytes,SentBytes,SourceIP,SourcePort,TimeGenerated, DeviceExternalID, Type, _ItemId, Computer, EventResult, EventResultDetails, DvcAction
  | project-rename DstBytes = ReceivedBytes
    , DstInterfaceName = DeviceOutboundInterface
    , DstIpAddr = DestinationIP
    , DstPortNumber = DestinationPort
    , Dvc = Computer
    , EventMessage = Activity
    , EventOriginalSeverity = LogSeverity
    , EventProduct = DeviceProduct
    , EventProductVersion = DeviceVersion
    , SrcBytes = SentBytes
    , SrcInterfaceName = DeviceInboundInterface
    , SrcIpAddr = SourceIP
    , SrcPortNumber = SourcePort
    , DvcId = DeviceExternalID
    , EventUid = _ItemId
  | invoke _ASIM_ResolveNetworkProtocol ('Protocol')
  | project-rename DvcOriginalAction = DeviceAction
  | parse-kv AdditionalExtensions as (
          FortinetFortiGatestart:datetime,
          FortinetFortiGatesrcintfrole:string,
          FortinetFortiGatedstintfrole:string,
          FortinetFortiGateexternalID:string,
          FortinetFortiGatepolicyid:int,
          FortinetFortiGatedstcountry:string,
          FortinetFortiGatesrccountry:string,
          FortinetFortiGatecrscore:string,
          FortinetFortiGateduration:int,
          FortinetFortiGatesentpkt:long,
          FortinetFortiGatercvdpkt:long
      ) with (pair_delimiter=';', kv_delimiter='=')
  | project-rename
      EventStartTime          = FortinetFortiGatestart,
      SrcZone                 = FortinetFortiGatesrcintfrole,
      DstZone                 = FortinetFortiGatedstintfrole,
      NetworkSessionId        = FortinetFortiGateexternalID,
      NetworkRuleNumber       = FortinetFortiGatepolicyid,
      NetworkDuration         = FortinetFortiGateduration,
      DstGeoCountry           = FortinetFortiGatedstcountry,
      SrcGeoCountry           = FortinetFortiGatesrccountry,
      ThreatOriginalRiskLevel = FortinetFortiGatecrscore,
      SrcPackets              = FortinetFortiGatesentpkt,
      DstPackets              = FortinetFortiGatercvdpkt
  | extend EventCount = int(1)
    , EventSchema = "NetworkSession"
    , EventSchemaVersion = "0.2.3"
    , EventType = "NetworkSession"
    , EventVendor = "Fortinet"
    , DvcIdType = "Other"
    , NetworkBytes = DstBytes + SrcBytes
    , EventEndTime = TimeGenerated
    , EventStartTime = coalesce(EventStartTime, TimeGenerated)
    , NetworkProtocolVersion = case(DstIpAddr contains ".", "IPv4"
        , DstIpAddr contains ":", "IPv6"
        , "")
    , NetworkPackets = DstPackets + SrcPackets
    | lookup SeverityLookup on EventOriginalSeverity
    | extend 
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        SessionId = NetworkSessionId,
        IpAddr = SrcIpAddr,
        Duration = NetworkDuration,
        Rule = tostring(NetworkRuleNumber)
  | project-away Protocol, AdditionalExtensions, NetworkProtocolNumber
};
Parser (disabled=disabled)
}



//
// Function Name: ASimNetworkSessionMD4IoTAgent
// Description: This ASIM parser supports normalizing Microsoft Defender for IoT micro agent logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMD4IoTAgent(    ['disabled']:bool=false)
{
let DirectionNetworkEvents =
  SecurityIoTRawEvent | where not(disabled)
  | where RawEventName == "NetworkActivity"
  | parse EventDetails with * ',"LocalPort":' LocalPort:int ',"RemotePort":' RemotePort:int ',' *
  | extend outbound = LocalPort > RemotePort
;
let parser = (T: (EventDetails: string)) {
  T 
   | parse EventDetails with 
    '{"LocalAddress":"' LocalAddress:string '",'
    '"RemoteAddress":"' RemoteAddress:string '",'
    *
    '"BytesIn":' BytesIn:long ','
    '"BytesOut":' BytesOut:long ','
    '"Protocol":"' Protocol:string '",'
    '"ProcessId":' ProcessId:string ','
    '"UserId":' UserId:string ','
    '"ApplicationProtocol":"' ApplicationProtocol:string '",'
    * // '"AzureResourceId":"' AzureResourceId:string '",'
    '"DeviceId":"' DeviceId:string '",'
    '"MessageSource":"' MessageSource:string '",'
    '"OriginalEventId":"' OriginalEventId:string '",'
    '"TimestampUTC":"' TimestampUTC:datetime '",'
    *
}
; 
let OutboundNetworkEvents = 
  DirectionNetworkEvents
  | where outbound
  | invoke parser ()
  | project-rename
     SrcBytes = BytesOut,
     DstBytes = BytesIn,
     SrcPortNumber = LocalPort,
     DstIpAddr = RemoteAddress,
     DstPortNumber = RemotePort,
     SrcProcessId = ProcessId
  | extend
     SrcIpAddr = LocalAddress,
     SrcDvcIdType = "MD4IoTid",
     SrcUserId = UserId,
     SrcUserIdType = "UID",
     SrcDvcId = DeviceId,
     Process = SrcProcessId, // alias
     SrcDvcOs = iif (MessageSource == "Linux", "Linux", "Windows")
;
let InboundNetworkEvents = 
  DirectionNetworkEvents
  | where not(outbound)
  | invoke parser ()
  | project-rename
     DstBytes = BytesOut,
     SrcBytes = BytesIn,
     DstPortNumber = LocalPort,
     SrcIpAddr = RemoteAddress,
     SrcPortNumber = RemotePort,
     DstProcessId = ProcessId
   | extend
      DstIpAddr = LocalAddress,
     DstDvcIdType = "MD4IoTid",
     DstUserId = UserId,
     DstUserIdType = "UID",
     DstDvcId = DeviceId,
     Process = DstProcessId, // alias
     DstDvcOs = iif (MessageSource == "Linux", "Linux", "Windows")
;
let NetworkSessionMD4IoT = 
  union InboundNetworkEvents, OutboundNetworkEvents
   | extend
    EventCount = int(1),
    EventProduct = 'Azure Defender for IoT', 
    EventVendor = 'Microsoft',
    EventSchemaVersion = '0.2.0',
    EventSchema = "NetworkSession", 
    EventType = 'NetworkSession',
    EventStartTime = TimeGenerated, // Open question about timestamps
    EventEndTime = TimeGenerated,  // Open question about timestamps
    EventResult = 'Success',
    EventSeverity = 'Informational'
  | project-rename
     EventProductVersion = AgentVersion, // Not available in Windows
     _ResourceId = AssociatedResourceId, 
     _SubscriptionId = AzureSubscriptionId, 
    EventOriginalUid = OriginalEventId,  // OK pending question
    DvcOs = MessageSource,
    NetworkProtocol = Protocol,
    NetworkApplicationProtocol = ApplicationProtocol,
    DvcId = DeviceId,
    DvcIpAddr = LocalAddress
  | extend
    Dvc = DvcId,
    DvcIdType = "MD4IoTid",
    User = UserId,
    IpAddr = SrcIpAddr,
    Src = SrcIpAddr,
    Dst = DstIpAddr
  | project-away outbound
;
NetworkSessionMD4IoT
}



//
// Function Name: ASimNetworkSessionMD4IoTSensor
// Description: This ASIM parser supports normalizing Microsoft Defender for IoT sensor logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMD4IoTSensor(    ['disabled']:bool=false)
{
let parser = (disabled:bool=false) 
{
  DefenderIoTRawEvent
  | where RawEventName == "NetworkConnectionData"
  | project-rename 
      DvcSubscriptionId = AzureSubscriptionId
  | extend 
      Dvc = tostring(EventDetails.SourceId),
      DstDvcId = tostring(EventDetails.Destination.DeviceId),
      DstMacAddr = tostring(EventDetails.Destination.MacAddress),
      DstIpAddr = tostring(EventDetails.Destination.IPAddress),
      DstPortNumber = toint(EventDetails.Destination.Port),
      DstDescription = tostring(EventDetails.Destination.DeviceName),
      SrcDvcId = tostring(EventDetails.Source.DeviceId),
      SrcMacAddr = tostring(EventDetails.Source.MacAddress),
      SrcIpAddr = tostring(EventDetails.Source.IPAddress),
      SrcPortNumber = toint(EventDetails.Source.Port),
      SrcDescription = tostring(EventDetails.Source.DeviceName),
      EventOriginalUid = tostring(EventDetails.Id),
      EventEndTime = todatetime(EventDetails.LastSeen),
      EventStartTime = todatetime(EventDetails.StartTime),
      NetworkProtocol = tostring(EventDetails.TransportProtocol)
  | extend
      EventProduct = 'Defender for IoT',
      EventResult = 'Success',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.4',
      EventCount = toint(1),
      EventSeverity = 'Informational',
      EventType = iff(DstIpAddr=='' and SrcIpAddr == '','L2NetworkSession','NetworkSession'),
      NetworkDirection = iff(tobool(EventDetails.IsInternal), 'Local',''),
      EventVendor = 'Microsoft',
      DstDvcIdType = 'MD4IoTid',
      SrcDvcIdType = 'MD4IoTid'
  | extend // -- Aliases
      Dst = coalesce(DstIpAddr,DstMacAddr),
      Src = coalesce(SrcIpAddr,SrcMacAddr),
      IpAddr = SrcIpAddr,
      EventStartTime = EventEndTime
  | project-away 
      RawEventCategory, RawEventName, RawEventType, SourceSystem, TenantId, AgentVersion, IoTRawEventId, IsEmpty, AgentId, DeviceId, TimeStamp
  | project-away EventDetails, AssociatedResourceId
};
parser (disabled)
}



//
// Function Name: ASimNetworkSessionMicrosoft365Defender
// Description: This ASIM parser supports normalizing M365 Defender for Endpoint to the ASIM Network Session schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMicrosoft365Defender(    ['disabled']:bool=false)
{
let M365Defender=(disabled:bool=false){
 let DirectionLookup=datatable(ActionType:string,NetworkDirection:string,Outbound:boolean)[
   'ConnectionSuccess','Outbound', true
   ,'ConnectionFailed', 'Outbound', true
   ,'ConnectionRequest','Outbound', true
   ,'InboundConnectionAccepted', 'Inbound', false
   ,'ConnectionFound', 'Unknown', false
   ,'ListeningConnectionCreated', 'Listen', false 
 ];
 // -- Common preprocessing to both input and outbound events
 let RawNetworkEvents = (select_outbound:boolean) {
   DeviceNetworkEvents | where not(disabled) 
   | lookup DirectionLookup on ActionType
   | where Outbound == select_outbound
   | project-away AppGuardContainerId, LocalIPType, MachineGroup, RemoteIPType, Timestamp, Outbound //, SourceSystem, TenantId
   | extend
     // Event
     EventOriginalUid = tostring(ReportId),
     EventCount = int(1),
     EventProduct = 'M365 Defender for Endpoint',
     EventVendor = 'Microsoft',
     EventSchema = 'NetworkSession',
     EventSchemaVersion = '0.1.0',
     EventStartTime = TimeGenerated,
     EventEndTime = TimeGenerated,
     EventType = 'NetworkSession',
     EventResult = iff(ActionType=='ConnectionFailed','Failure','Success'),
     EventSeverity = "Informational",
     DvcIdType = 'MDEid'
   | project-away 
       ReportId
   | project-rename 
       EventOriginalResultDetails = ActionType
   | extend
     RemoteUrl = extract (@"(?:https?://)?(.*)", 1, RemoteUrl)
   | extend
     User = iff (InitiatingProcessAccountDomain == '', InitiatingProcessAccountName, strcat(InitiatingProcessAccountDomain, '\\', InitiatingProcessAccountName)),
     UsernameType = iff(InitiatingProcessAccountDomain == '','Simple', 'Windows'),
     SplitHostname = split(DeviceName,"."),
     SplitUrl = split(RemoteUrl,"."),
     NetworkProtocol = case (
       Protocol startswith "Tcp", "TCP",
       Protocol == "Unknown", "",
       toupper(Protocol)
     )
   | project-away Protocol
   | extend  
     DvcHostname = tostring(SplitHostname[0]),
     DvcDomain = tostring(strcat_array(array_slice(SplitHostname, 1, -1), '.')),
     DvcFQDN = iif (DeviceName contains ".", DeviceName, ""),
     UrlHostname = tostring(SplitUrl[0]),
     UrlDomain = tostring(strcat_array(array_slice(SplitUrl, 1, -1), '.')),
     UrlFQDN = iif(RemoteUrl contains ".", RemoteUrl, "")
   | project-away RemoteUrl, DeviceName
   | extend
     DvcDomainType = iif(DvcFQDN != "", "FQDN", ""),
     UrlDomainType = iff(UrlFQDN != "", "FQDN", ""),
     DvcIpAddr = LocalIP
   | extend
     Dvc = DvcHostname  
   | project-rename
     DvcId = DeviceId
   | project-away SplitUrl, SplitHostname
 };
 let OutboundNetworkEvents = 
   RawNetworkEvents (true)
   | project-rename
      DstIpAddr = RemoteIP,
      SrcIpAddr = LocalIP,
      DstPortNumber = RemotePort,
      SrcPortNumber = LocalPort,
      SrcUsernameType = UsernameType,
      SrcUserAadId = InitiatingProcessAccountObjectId,
      SrcUserUpn = InitiatingProcessAccountUpn,
      SrcUserId = InitiatingProcessAccountSid
   | extend
      SrcUsername = User,
      SrcDvcId = DvcId,
      SrcDvcIdType = 'MDEid',
      SrcUserIdType = iff (SrcUserId <> "S-1-0-0", "SID", ""),
      SrcUserId = iff (SrcUserId <> "S-1-0-0", SrcUserId, ""),
      DstHostname = UrlHostname
   | project-rename
      DstDomain = UrlDomain,
      DstFQDN = UrlFQDN,
      DstDomainType = UrlDomainType
   | extend  
      SrcHostname = DvcHostname,
      SrcDomain = DvcDomain,
      SrcFQDN = DvcDomain
   // Processes
   | extend
      SrcProcessId = tostring(InitiatingProcessId),
      ParentProcessId = tostring(InitiatingProcessParentId)
   | project-rename
      SrcProcessName = InitiatingProcessFileName,
      SrcProcessCommandLine = InitiatingProcessCommandLine,
      SrcProcessCreationTime = InitiatingProcessCreationTime,
      SrcProcessIntegrityLevel = InitiatingProcessIntegrityLevel,
      SrcProcessTokenElevation = InitiatingProcessTokenElevation,
      ParentProcessName = InitiatingProcessParentFileName,
      ParentProcessCreationTime = InitiatingProcessParentCreationTime
      // SrcProcessFileSize = InitiatingProcessFileSize,
      // SrcProcessCompany = InitiatingProcessVersionInfoCompanyName,
      // SrcProcessFileProduct = InitiatingProcessVersionInfoProductName,
      // SrcProcessFileVersion = InitiatingProcessVersionInfoProductVersion,
      // SrcProcessFileInternalName = InitiatingProcessVersionInfoInternalFileName,
      // SrcProcessFileOriginalName = InitiatingProcessVersionInfoOriginalFileName,
      // SrcProcessFileDescription = InitiatingProcessVersionInfoFileDescription
   | extend
      Process = SrcProcessName,
      SrcAppName = SrcProcessName,
      SrcAppType = "Process"
 ;
 let InboundNetworkEvents = 
   RawNetworkEvents (false)
   | project-rename
      SrcIpAddr = RemoteIP,
      DstIpAddr = LocalIP,
      SrcPortNumber = RemotePort,
      DstPortNumber = LocalPort,
      DstUsernameType = UsernameType,
      DstUserAadId = InitiatingProcessAccountObjectId,
      DstUserId = InitiatingProcessAccountSid,
      DstUserUpn = InitiatingProcessAccountUpn
   | extend
      DstUsername = User,
      DstDvcId = DvcId,
      DstDvcIdType = 'MDEid',
      DstUserIdType = 'SID',
      SrcHostname = UrlHostname
  | project-rename
      SrcDomain = UrlDomain,
      SrcFQDN = UrlFQDN,
      SrcDomainType = UrlDomainType,
      DstHostname = DvcHostname,
      DstDomain = DvcDomain,
      DstFQDN = DvcFQDN
   // Processes
   | extend
      DstProcessId = tostring(InitiatingProcessId),
      ParentProcessId = tostring(InitiatingProcessParentId)
   | project-rename
      DstProcessName = InitiatingProcessFileName,
      DstProcessCommandLine = InitiatingProcessCommandLine,
      DstProcessCreationTime = InitiatingProcessCreationTime,
      DstProcessIntegrityLevel = InitiatingProcessIntegrityLevel,
      DstProcessTokenElevation = InitiatingProcessTokenElevation,
      ParentProcessName = InitiatingProcessParentFileName,
      ParentProcessCreationTime = InitiatingProcessParentCreationTime
      // SrcProcessFileSize = InitiatingProcessFileSize,
      // SrcProcessCompany = InitiatingProcessVersionInfoCompanyName,
      // SrcProcessFileProduct = InitiatingProcessVersionInfoProductName,
      // SrcProcessFileVersion = InitiatingProcessVersionInfoProductVersion,
      // SrcProcessFileInternalName = InitiatingProcessVersionInfoInternalFileName,
      // SrcProcessFileOriginalName = InitiatingProcessVersionInfoOriginalFileName,
      // SrcProcessFileDescription = InitiatingProcessVersionInfoFileDescription
   | extend
      Process = DstProcessName,
      DstAppName = DstProcessName,
      DstAppType = "Process"
 ;
 union InboundNetworkEvents, OutboundNetworkEvents
 | project-rename 
    Hostname = UrlHostname
 | extend // aliases
    IpAddr = SrcIpAddr,
    Src = SrcIpAddr,
    Dst = DstIpAddr
 };
 M365Defender (disabled)
}



//
// Function Name: ASimNetworkSessionLinuxSysmon
// Description: This ASIM parser supports normalizing Sysmon for Linux event 3 to the ASIM Network Session schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionLinuxSysmon(    ['disabled']:bool=false)
{
let DirectionNetworkEvents =
 Syslog | where not(disabled)
 | project SyslogMessage, TimeGenerated, HostIP
 | where SyslogMessage has_all ('<Provider Name="Linux-Sysmon"', '<EventID>3</EventID>')
 | parse SyslogMessage with * '<Data Name="SourceIp">' SrcIpAddr:string '</Data>' *
 | extend outbound = (SrcIpAddr == HostIP or SrcIpAddr in ('127.0.0.1', '0.0.0.0'))
 ;
 let parser = (T: (SyslogMessage: string)) {
   T 
   | parse SyslogMessage with 
       *
       '<EventRecordID>' EventOriginalUid:string '</EventRecordID>'
       *
       '<Computer>' SysmonComputer:string '</Computer>'
       *
       '<Data Name="RuleName">' RuleName:string '</Data>'
       '<Data Name="UtcTime">' EventEndTime:datetime '</Data>'
       '<Data Name="ProcessGuid">{' ProcessGuid:string '}</Data>'
       '<Data Name="ProcessId">' ProcessId:string '</Data>'
       '<Data Name="Image">' Process:string '</Data>'
       '<Data Name="User">' User:string '</Data>'
       '<Data Name="Protocol">' Protocol:string '</Data>' // -- source is lowercase
       '<Data Name="Initiated">' Initiated:bool '</Data>' 
       '<Data Name="SourceIsIpv6">' SourceIsIpv6:bool '</Data>'		
       '<Data Name="SourceIp">' * '</Data>'
       '<Data Name="SourceHostname">' SrcHostname:string '</Data>'
       '<Data Name="SourcePort">' SrcPortNumber:int '</Data>'
       '<Data Name="SourcePortName">' SrcPortName:string '</Data>'
       '<Data Name="DestinationIsIpv6">' DestinationIsIpv6:bool '</Data>'
       '<Data Name="DestinationIp">' DstIpAddr:string '</Data>'
       '<Data Name="DestinationHostname">' DstHostname:string '</Data>'
       '<Data Name="DestinationPort">' DstPortNumber:int '</Data>'
       '<Data Name="DestinationPortName">' DstPortName:string '</Data>'
       *
       | project-away DstPortName, DestinationIsIpv6, Initiated, SourceIsIpv6, SrcPortName, RuleName
 };
 let OutboundNetworkEvents = 
   DirectionNetworkEvents
   | where outbound
   | invoke parser ()
   | extend
     SrcUsernameType = 'Simple',
     SrcAppType = 'Process'
   | project-rename 
     SrcUsername = User,
     SrcProcessId = ProcessId, 
     SrcProcessGuid = ProcessGuid,
     SrcProcessName = Process
   | extend
     SrcAppName = SrcProcessName
   | project-away SyslogMessage
 ;
 let InboundNetworkEvents = 
   DirectionNetworkEvents
   | where not(outbound)
   | invoke parser ()
   | extend
     DstUsernameType = 'Simple',
     DstAppType = 'Process'
   | project-rename 
     DstUsername = User,
     DstProcessId = ProcessId, 
     DstProcessGuid = ProcessGuid,
     DstProcessName = Process
   | extend
     DstAppName = DstProcessName
   | project-away SyslogMessage
 ; 
 let SysmonForLinuxNetwork=
     union OutboundNetworkEvents, InboundNetworkEvents
     | extend 
         EventType = 'NetworkSession',
         EventStartTime = EventEndTime,
         EventCount = int(1),
         EventVendor = 'Microsoft',
         EventSchemaVersion = '0.2.0',
         EventSchema = 'NetworkSession', 
         EventProduct = 'Sysmon for Linux',
         EventResult = 'Success',
         EventSeverity = 'Informational',
         DvcOs = 'Linux',
         NetworkProtocol = toupper(Protocol),
         NetworkDirection = iff(outbound, "Outbound", "Inbound"),
         EventOriginalType = '3' // Set with a constant value to avoid parsing
     | project-away
         outbound, Protocol
     | project-rename 
         DvcIpAddr = HostIP,
         DvcHostname = SysmonComputer
     | extend // aliases
         Dvc = DvcHostname,
         Hostname = DstHostname,
         IpAddr = SrcIpAddr,
         Src = SrcIpAddr,
         Dst = DstIpAddr
 ;
 SysmonForLinuxNetwork
}



//
// Function Name: ASimNetworkSessionMicrosoftSecurityEventFirewall
// Description: This ASIM parser supports normalizing Microsoft Windows Firewall Events logs ingested in 'SecurityEvent' table to the ASIM Network Session schema. Event IDs which are parsed as part of this parser: 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5167, 5158, 5159

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMicrosoftSecurityEventFirewall(    ['disabled']:bool=false)
{
// Data tables for mapping raw values into string
let LayerCodeTable = datatable (LayerCode:string,LayerName:string)[
  '%%14596', 'IP Packet',
  '%%14597', 'Transport',
  '%%14598', 'Forward',
  '%%14599', 'Stream',
  '%%14600', 'Datagram Data',
  '%%14601', 'ICMP Error',
  '%%14602', 'MAC 802.3',
  '%%14603', 'MAC Native',
  '%%14604', 'vSwitch',
  '%%14608', 'Resource Assignment',
  '%%14609', 'Listen',
  '%%14610', 'Receive/Accept',
  '%%14611', 'Connect',
  '%%14612', 'Flow Established',
  '%%14614', 'Resource Release',
  '%%14615', 'Endpoint Closure',
  '%%14616', 'Connect Redirect',
  '%%14617', 'Bind Redirect',
  '%%14624', 'Stream Packet'];
let ProtocolTable = datatable (Protocol:int, NetworkProtocol: string)[
  1, 'ICMP',
  3, 'GGP',
  6, 'TCP',
  8, 'EGP',
  12, 'PUP',
  17, 'UDP',
  20, 'HMP',
  27, 'RDP',
  46, 'RSVP',
  47, 'PPTP data over GRE',
  50, 'ESP',
  51, 'AH',
  66, 'RVD',
  88, 'IGMP',
  89, 'OSPF'];
let Directions = datatable (DirectionCode:string,NetworkDirection:string, isOutBound:bool)[
  '%%14592', 'Inbound', false,
  '%%14593', 'Outbound', true,
  '%%14594', 'Forward',false,
  '%%14595', 'Bidirectional', false,
  '%%14609', 'Listen', false];
///////////////////////////////////////////////////////
// this query extract data fields from EventData column from SecurityEvent table
///////////////////////////////////////////////////////
let parser = (disabled: bool=false) {
let WindowsFirewall_SecurityEvent=(){ // Event IDs between (5151 .. 5159)
// will be extracting Event specific fields from 'EventData' field
  let SecurityEventProjected =
      SecurityEvent
      | project EventID, EventData, Computer, TimeGenerated, _ResourceId, _SubscriptionId, Type
  ;
  let SecurityEvent_5152 = 
      SecurityEventProjected | where not(disabled)
      | where EventID==5152
      | parse EventData with * '<Data Name="ProcessId">'ProcessId:string'</Data>'
          '\x0d\x0a  <Data Name="Application">'Application'</Data>'
          '\x0d\x0a  <Data Name="Direction">'DirectionCode'</Data>'
          '\x0d\x0a  <Data Name="SourceAddress">'SrcIpAddr:string'</Data>'
          '\x0d\x0a  <Data Name="SourcePort">'SrcPortNumber:int'</Data>'
          '\x0d\x0a  <Data Name="DestAddress">'DstIpAddr:string'</Data>'
          '\x0d\x0a  <Data Name="DestPort">'DstPortNumber:int'</Data>'
          '\x0d\x0a  <Data Name="Protocol">'Protocol:int'</Data>'
          '\x0d\x0a  <Data Name="FilterRTID">'NetworkRuleNumber:int'</Data>'
          '\x0d\x0a  <Data Name="LayerName">'LayerCode'</Data>'
          '\x0d\x0a  <Data Name="LayerRTID">'LayerRTID'</Data>'*
      | project-away EventData;
  let SecurityEvent_5154_5155_5158_5159 =
      SecurityEventProjected | where not(disabled)
      | where EventID in (5154, 5155, 5158, 5159)
      | parse EventData with * '<Data Name="ProcessId">'ProcessId:string'</Data>' 
          '\x0d\x0a  <Data Name="Application">'Application'</Data>'
          '\x0d\x0a  <Data Name="SourceAddress">'SrcIpAddr:string'</Data>'
          '\x0d\x0a  <Data Name="SourcePort">'SrcPortNumber:int'</Data>'
          '\x0d\x0a  <Data Name="Protocol">'Protocol:int'</Data>'
          '\x0d\x0a  <Data Name="FilterRTID">'NetworkRuleNumber:int'</Data>'
          '\x0d\x0a  <Data Name="LayerName">'LayerCode'</Data>'
          '\x0d\x0a  <Data Name="LayerRTID">'LayerRTID'</Data>'*
      | extend DirectionCode = "%%14609"
      | project-away EventData;
  let SecurityEvent_5156_5157 =
      SecurityEventProjected | where not(disabled)
      | where EventID in (5156, 5157)
      | parse EventData with * '<Data Name="ProcessID">'ProcessId:string'</Data>'
          '\x0d\x0a  <Data Name="Application">'Application:string'</Data>'
          '\x0d\x0a  <Data Name="Direction">'DirectionCode:string'</Data>'
          '\x0d\x0a  <Data Name="SourceAddress">'SrcIpAddr:string'</Data>'
          '\x0d\x0a  <Data Name="SourcePort">'SrcPortNumber:int'</Data>'
          '\x0d\x0a  <Data Name="DestAddress">'DstIpAddr:string'</Data>'
          '\x0d\x0a  <Data Name="DestPort">'DstPortNumber:int'</Data>'
          '\x0d\x0a  <Data Name="Protocol">'Protocol:int'</Data>'
          '\x0d\x0a  <Data Name="FilterRTID">'NetworkRuleNumber:int'</Data>'
          '\x0d\x0a  <Data Name="LayerName">'LayerCode'</Data>'
          '\x0d\x0a  <Data Name="LayerRTID">'LayerRTID'</Data>'
          '\x0d\x0a  <Data Name="RemoteUserID">'RemoteUserID'</Data>'
          '\x0d\x0a  <Data Name="RemoteMachineID">'RemoteMachineID'</Data>'*
      | project-away EventData;
  union SecurityEvent_5152, SecurityEvent_5156_5157, SecurityEvent_5154_5155_5158_5159
      | lookup Directions on DirectionCode
      | project-rename DvcHostname = Computer
      | extend
          SrcAppName = iff(isOutBound, Application, ""),
          DstAppName = iff(not(isOutBound), Application, ""),
          SrcDvcId = iff(isOutBound, RemoteMachineID, ""),
          DstDvcId = iff(not(isOutBound), RemoteMachineID, ""),
          SrcProcessId =  iff(isOutBound, tostring(ProcessId), ""),
          DstProcessId =  iff(not(isOutBound), tostring(ProcessId), ""),
          DstUserId = iff(isOutBound, RemoteUserID, ""),
          SrcUserId = iff(not(isOutBound), RemoteUserID, ""),
          DstHostname = iff(isOutBound, "", DvcHostname),
          SrcHostname = iff(isOutBound, DvcHostname, "")
      | project-away Application, RemoteMachineID, RemoteUserID, ProcessId
};
WindowsFirewall_SecurityEvent 
     | extend 
            DvcAction = iff(EventID in (5154, 5156, 5158), "Allow", "Deny"),
            DvcOs = 'Windows',
            DstAppType = "Process",
            SrcUserIdType = iff (SrcUserId <> "S-1-0-0", "SID", ""),
            SrcUserId = iff (SrcUserId <> "S-1-0-0", SrcUserId, ""),
            DstUserIdType = iff (DstUserId <> "S-1-0-0", "SID", ""),
            DstUserId = iff (DstUserId <> "S-1-0-0", DstUserId, ""),
            SrcAppType = "Process",
            EventType = "NetworkSession",
            EventSchema = "NetworkSession",
            EventSchemaVersion="0.2.0",
            EventCount=toint(1),
            EventVendor = "Microsoft",
            EventProduct = "Windows Firewall",
            EventResult = iff(EventID in (5154, 5156, 5158), "Success", "Failure"),
            EventStartTime = TimeGenerated,
            EventEndTime = TimeGenerated,
            EventSeverity = iff(EventID  in (5154, 5156, 5158), "Informational", "Low"),
            EventOriginalType = tostring(EventID),
            DstDvcIdType = iff (DstDvcId != "", "SID", ""),
            SrcDvcIdType = iff (SrcDvcId != "", "SID", "")
   // aliases
    | extend
            Dvc = DvcHostname,
            Hostname = DstHostname,
            IpAddr = SrcIpAddr,
            Src = SrcIpAddr,
            Dst = DstIpAddr,
            Rule = tostring (NetworkRuleNumber)
    | lookup LayerCodeTable on LayerCode
    | lookup ProtocolTable on Protocol
    | project-away LayerCode, DirectionCode, Protocol, isOutBound, LayerName, EventID, LayerRTID,_ResourceId,_SubscriptionId
    };
    parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionMicrosoftSysmon
// Description: This ASIM parser supports normalizing Sysmon network session events (event 3) collected logs ingested in 'Event' table to the ASIM Process Event normalized schema. 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMicrosoftSysmon(    ['disabled']:bool=false)
{
let parser = (disabled:bool = false) {
      Event
      | where not(disabled)
      | where Source == "Microsoft-Windows-Sysmon" and EventID==3
      | parse-kv EventData as (
                  SourceIp:string,
                  DestinationIp:string,
                  SourceHostname:string,
                  DestinationHostname:string,
                  Initiated:bool,  // Initiated indicates the process initiated a connection (meaning outbound)
                  RuleName:string,
                  UtcTime:datetime,
                  ProcessGuid:string,
                  ProcessId:string,
                  Image:string,
                  User:string,
                  Protocol:string,
                  SourceIsIpv6:bool,
                  SourcePort:int,
                  SourcePortName:string,
                  DestinationIsIpv6:bool,
                  DestinationPort:int,
                  DestinationPortName:string
              ) with (regex=@'<Data Name="(\w+)">{?([^>]*?)}?</Data>')
      | project-away EventData
      | project-rename
              SrcHostname = SourceHostname,
              DstHostname = DestinationHostname
      | project-away
              Source,
              EventLog,
              EventCategory,
              UserName,
              Message,
              ParameterXml,
              RenderedDescription,
              MG,
              AzureDeploymentID,
              Role
      | extend
              AppName = tostring(split(Image, "\\")[-1])
      | extend
              SrcUsernameType = iff(not(Initiated), "Windows", ""),
              SrcUsername = iff(not(Initiated), tostring(User), ""),
              SrcProcessId = iff(not(Initiated), tostring(ProcessId), ""),
              SrcProcessGuid = iff(not(Initiated), ProcessGuid, ""),
              SrcProcessName = iff(not(Initiated), tostring(Image), ""),
              SrcAppName = iff(not(Initiated), AppName, ""),
              SrcAppType = iff(not(Initiated), 'Process', ""),
              DstUsernameType = iff(Initiated, "Windows", ""),
              DstUsername = iff(Initiated, tostring(User), ""),
              DstProcessId = iff(Initiated, tostring(ProcessId), ""),
              DstProcessGuid = iff(Initiated, ProcessGuid, ""),
              DstProcessName = iff(Initiated, tostring(Image), ""),
              DstAppName = iff(Initiated, AppName, ""),
              DstAppType = iff(Initiated, 'Process', ""),
              EventUid = _ItemId
      | project-away  ProcessId, ProcessGuid, Image, AppName
      | project-rename 
              EventStartTime = UtcTime,
              Dvc = Computer,
              SrcIpAddr = SourceIp,
              DstIpAddr  = DestinationIp,
              DstPortNumber = DestinationPort,
              SrcPortNumber = SourcePort,
              NetworkRuleName = RuleName 
      | extend 
              EventEndTime = EventStartTime,
              Hostname = case(
                              Initiated, DstHostname,
                              not(Initiated), SrcHostname,
                              Dvc),
              Src = SrcIpAddr,
              Dst = DstIpAddr,
              DvcIpAddr = iff(Initiated, SrcIpAddr, DstIpAddr),
              IpAddr = SrcIpAddr,
              EventType = 'EndpointNetworkSession',
              EventCount = int(1),
              EventVendor = 'Microsoft',
              EventSchemaVersion = '0.2.5',
              EventSchema = 'NetworkSession', 
              EventProduct = 'Sysmon',
              EventResult = 'Success',
              EventSeverity = 'Informational',
              DvcOs = 'Windows',
              Protocol = toupper(Protocol),
              EventOriginalType = '3' // Set with a constant value to avoid parsing   
      | extend
              DvcHostname = Hostname
      | extend
              SrcHostname = iff( SrcHostname == "-", "", SrcHostname),
              DvcHostname = iff( DvcHostname == "-", "", DvcHostname),
              DstHostname = iff( DstHostname == "-", "", DstHostname) // let's make empty values actually empty
      | project-rename
              TmpSrcHostname = SrcHostname,
              TmpDvcHostname = DvcHostname,
              TmpDstHostname = DstHostname
      | invoke 
              _ASIM_ResolveSrcFQDN('TmpSrcHostname')
      | invoke 
              _ASIM_ResolveDvcFQDN('TmpDvcHostname')
      | invoke 
              _ASIM_ResolveDstFQDN('TmpDstHostname')
      | project-away
              TmpSrcHostname,
              TmpDvcHostname,
              TmpDstHostname
      | extend                         
              NetworkProtocolVersion = iff((DestinationIsIpv6) or (SourceIsIpv6), "IPV6", "IPV4"),
              NetworkProtocol = toupper(Protocol)
      | project-away 
              Destination*,
              Initiated,
              ManagementGroupName,
              TenantId,
              Protocol,
              Source*,
              EventID,
              EventLevelName,
              EventLevel,_ResourceId
    };
    parser (disabled)
}



//
// Function Name: ASimNetworkSessionMicrosoftSysmonWindowsEvent
// Description: This ASIM parser supports normalizing Sysmon network session events (event 3) collected using the Event or WEF (WindowsEvent table) connectors logs ingested in 'WindowsEvent' table to the ASIM Process Event normalized schema. 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMicrosoftSysmonWindowsEvent(    ['disabled']:bool=false)
{
let parser = (disabled:bool = false) {
let Sysmon3_WindowsEvent=(disabled:bool=false){
      WindowsEvent
      | where not(disabled) 
      | where Provider == "Microsoft-Windows-Sysmon" and EventID == 3
      | extend
              SourceIp = tostring(EventData.SourceIp),
              DestinationIp = tostring(EventData.DestinationIp),
              DstHostname = tostring(EventData.DestinationHostname),
              SrcHostname = tostring(EventData.SrcHostname),
              RuleName = tostring(EventData.RuleName),
              UtcTime = todatetime(EventData.UtcTime),
              ProcessId = tostring(EventData.ProcessId),
              Image = tostring(EventData.Image),
              User = tostring(EventData.User),
              Protocol = tostring(EventData.Protocol),
              Initiated = tobool(EventData.Initiated), // Initiated indicates the process initiated a connection (meaning outbound)
              SourceIsIpv6 = tobool(EventData.SourceIsIpv6),
              SourcePort = toint(EventData.SourcePort),
              SourcePortName = tostring(EventData.SourcePortName),
              DestinationIsIpv6 = tobool(EventData.DestinationIsIpv6),
              DestinationPort = toint(EventData.DestinationPort),
              DestinationPortName = tostring(EventData.DestinationPortName)
      | parse EventData.ProcessGuid with "{" ProcessGuid "}"
      | project-away EventData
      | project-away
                     Provider,
                     Channel,
                     Task,
                     Data,
                     RawEventData,
                     EventOriginId
    };
Sysmon3_WindowsEvent
      | extend
              AppName = tostring(split(Image, "\\")[-1])
      | extend
              SrcUsernameType = iff(not(Initiated), "Windows", ""),
              SrcUsername = iff(not(Initiated), tostring(User), ""),
              SrcProcessId = iff(not(Initiated), tostring(ProcessId), ""),
              SrcProcessGuid = iff(not(Initiated), ProcessGuid, ""),
              SrcProcessName = iff(not(Initiated), tostring(Image), ""),
              SrcAppName = iff(not(Initiated), AppName, ""),
              SrcAppType = iff(not(Initiated), 'Process', ""),
              DstUsernameType = iff(Initiated, "Windows", ""),
              DstUsername = iff(Initiated, tostring(User), ""),
              DstProcessId = iff(Initiated, tostring(ProcessId), ""),
              DstProcessGuid = iff(Initiated, ProcessGuid, ""),
              DstProcessName = iff(Initiated, tostring(Image), ""),
              DstAppName = iff(Initiated, AppName, ""),
              DstAppType = iff(Initiated, 'Process', ""),
              EventUid = _ItemId
      | project-away  ProcessId, ProcessGuid, Image, AppName
      | project-rename 
              EventStartTime = UtcTime,
              Dvc = Computer,
              SrcIpAddr = SourceIp,
              DstIpAddr  = DestinationIp,
              DstPortNumber = DestinationPort,
              SrcPortNumber = SourcePort,
              NetworkRuleName = RuleName 
      | extend 
              EventEndTime = EventStartTime,
              Hostname = case(
                              Initiated, DstHostname,
                              not(Initiated), SrcHostname,
                              Dvc),
              Src = SrcIpAddr,
              Dst = DstIpAddr,
              DvcIpAddr = iff(Initiated, SrcIpAddr, DstIpAddr),
              IpAddr = SrcIpAddr,
              EventType = 'EndpointNetworkSession',
              EventCount = int(1),
              EventVendor = 'Microsoft',
              EventSchemaVersion = '0.2.5',
              EventSchema = 'NetworkSession', 
              EventProduct = 'Sysmon',
              EventResult = 'Success',
              EventSeverity = 'Informational',
              DvcOs = 'Windows',
              Protocol = toupper(Protocol),
              EventOriginalType = '3' // Set with a constant value to avoid parsing   
      | extend
              DvcHostname = Hostname
      | extend
              SrcHostname = iff( SrcHostname == "-", "", SrcHostname),
              DvcHostname = iff( DvcHostname == "-", "", DvcHostname),
              DstHostname = iff( DstHostname == "-", "", DstHostname) // let's make empty values actually empty
      | project-rename
              TmpSrcHostname = SrcHostname,
              TmpDvcHostname = DvcHostname,
              TmpDstHostname = DstHostname
      | invoke 
              _ASIM_ResolveSrcFQDN('TmpSrcHostname')
      | invoke 
              _ASIM_ResolveDvcFQDN('TmpDvcHostname')
      | invoke 
              _ASIM_ResolveDstFQDN('TmpDstHostname')
      | project-away
              TmpSrcHostname,
              TmpDvcHostname,
              TmpDstHostname
      | extend                         
              NetworkProtocolVersion = iff((DestinationIsIpv6) or (SourceIsIpv6), "IPV6", "IPV4"),
              NetworkProtocol = toupper(Protocol)
      | project-away 
              Destination*,
              Initiated,
              ManagementGroupName,
              TenantId,
              Protocol,
              Source*,
              EventID,
              EventLevelName,
              EventLevel,Correlation,EventRecordId,Keywords,Opcode,SystemProcessId,SystemThreadId,SystemUserId,TimeCreated,_ResourceId,Version
    };
    parser (disabled)
}



//
// Function Name: ASimNetworkSessionMicrosoftWindowsEventFirewall
// Description: This ASIM parser supports normalizing Microsoft Windows Firewall Events logs ingested in 'WindowsEvent' table to the ASIM Network Session schema. Event IDs which are parsed as part of this parser: 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5167, 5158, 5159

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionMicrosoftWindowsEventFirewall(    ['disabled']:bool=false)
{
// Data tables for mapping raw values into string
let LayerCodeTable = datatable (LayerCode:string,LayerName:string)[
  '%%14596', 'IP Packet',
  '%%14597', 'Transport',
  '%%14598', 'Forward',
  '%%14599', 'Stream',
  '%%14600', 'Datagram Data',
  '%%14601', 'ICMP Error',
  '%%14602', 'MAC 802.3',
  '%%14603', 'MAC Native',
  '%%14604', 'vSwitch',
  '%%14608', 'Resource Assignment',
  '%%14609', 'Listen',
  '%%14610', 'Receive/Accept',
  '%%14611', 'Connect',
  '%%14612', 'Flow Established',
  '%%14614', 'Resource Release',
  '%%14615', 'Endpoint Closure',
  '%%14616', 'Connect Redirect',
  '%%14617', 'Bind Redirect',
  '%%14624', 'Stream Packet'];
let ProtocolTable = datatable (Protocol:int, NetworkProtocol: string)[
  1, 'ICMP',
  3, 'GGP',
  6, 'TCP',
  8, 'EGP',
  12, 'PUP',
  17, 'UDP',
  20, 'HMP',
  27, 'RDP',
  46, 'RSVP',
  47, 'PPTP data over GRE',
  50, 'ESP',
  51, 'AH',
  66, 'RVD',
  88, 'IGMP',
  89, 'OSPF'];
let Directions = datatable (DirectionCode:string,NetworkDirection:string, isOutBound:bool)[
  '%%14592', 'Inbound', false,
  '%%14593', 'Outbound', true,
  '%%14594', 'Forward',false,
  '%%14595', 'Bidirectional', false,
  '%%14609', 'Listen', false];
//////////////////////////////////////////////////////
// this query extract the data from WindowsEvent table
//////////////////////////////////////////////////////
let parser = (disabled: bool=false) {
let WindowsFirewall_WindowsEvent=(){   
      WindowsEvent | where not(disabled)
      | project EventID, EventData, Computer, TimeGenerated, _ResourceId, _SubscriptionId, Type
      | where EventID between (5150 .. 5159)
      | project-rename DvcHostname = Computer
      | extend 
          EventSeverity=tostring(EventData.Severity),
          LayerCode = tostring(EventData.LayerName),
          NetworkRuleNumber = toint(EventData.FilterRTID),
          Protocol = toint(EventData.Protocol),
          DirectionCode = iff(EventID in (5154, 5155, 5158, 5159), "%%14609",tostring(EventData.Direction))
      | lookup Directions on DirectionCode 
      | extend  SrcAppName = iff(isOutBound, tostring(EventData.Application), ""),
                  DstAppName = iff(not(isOutBound), tostring(EventData.Application), ""),
                  SrcIpAddr = tostring(EventData.SourceAddress),
                  DstIpAddr = tostring(EventData.DestAddress),
                  SrcDvcId = iff(isOutBound, tostring(EventData.RemoteMachineID), ""),
                  DstDvcId = iff(not(isOutBound), tostring(EventData.RemoteMachineID), ""),
                  SrcPortNumber=toint(EventData.SourcePort),
                  DstPortNumber=toint(EventData.DestPort),
                  SrcProcessId =  iff(isOutBound, tostring(EventData.ProcessId), ""),
                  DstProcessId =  iff(not(isOutBound), tostring(EventData.ProcessId), ""),
                  DstUserId = iff(isOutBound, tostring(EventData.RemoteUserID), ""),
                  SrcUserId = iff(not(isOutBound), tostring(EventData.RemoteUserID), ""),
                  DstHostname = iff(isOutBound, "", DvcHostname),
                  SrcHostname = iff(isOutBound, DvcHostname, "")
      | project-away EventData
  };
// Main query -> outputs both schemas as one normalized table
WindowsFirewall_WindowsEvent 
     | extend 
            DvcAction = iff(EventID in (5154, 5156, 5158), "Allow", "Deny"),
            DvcOs = 'Windows',
            DstAppType = "Process",
            SrcUserIdType = iff (SrcUserId <> "S-1-0-0", "SID", ""),
            SrcUserId = iff (SrcUserId <> "S-1-0-0", SrcUserId, ""),
            DstUserIdType = iff (DstUserId <> "S-1-0-0", "SID", ""),
            DstUserId = iff (DstUserId <> "S-1-0-0", DstUserId, ""),
            SrcAppType = "Process",
            EventType = "NetworkSession",
            EventSchema = "NetworkSession",
            EventSchemaVersion="0.2.0",
            EventCount=toint(1),
            EventVendor = "Microsoft",
            EventProduct = "Windows Firewall",
            EventResult = iff(EventID in (5154, 5156, 5158), "Success", "Failure"),
            EventStartTime = TimeGenerated,
            EventEndTime = TimeGenerated,
            EventSeverity = iff(EventID  in (5154, 5156, 5158), "Informational", "Low"),
            EventOriginalType = tostring(EventID),
            DstDvcIdType = iff (DstDvcId != "", "SID", ""),
            SrcDvcIdType = iff (SrcDvcId != "", "SID", "")
   // aliases
    | extend
            Dvc = DvcHostname,
            Hostname = DstHostname,
            IpAddr = SrcIpAddr,
            Src = SrcIpAddr,
            Dst = DstIpAddr,
            Rule = tostring (NetworkRuleNumber)
    | lookup LayerCodeTable on LayerCode
    | lookup ProtocolTable on Protocol
    | project-away LayerCode, DirectionCode, Protocol, isOutBound, LayerName, EventID,_ResourceId,_SubscriptionId
    };                    
    parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionNative
// Description: This ASIM parser supports normalizing the native Microsoft Sentinel Network Session table (ASimNetworkSessionLogs) to the ASIM NetworkSession normalized schema. While the native table is ASIM compliant, the parser is needed to add capabilities, such as aliases, available only at query time. 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionNative(    ['disabled']:bool=false)
{
let parser=(disabled:bool=false) 
{
  ASimNetworkSessionLogs  | where not(disabled)
    | project-rename
        EventUid = _ItemId
    | extend          
        EventSchema = "NetworkSession",
        DvcScopeId = iff(isempty(DvcSubscriptionId), _SubscriptionId, DvcSubscriptionId)
    //  -- Aliases
    | extend
        EventEndTime = iff (isnull(EventEndTime), TimeGenerated, EventEndTime),
        EventStartTime = iff (isnull(EventEndTime), TimeGenerated, EventStartTime),
        Dvc = case(EventType == 'L2NetworkSession',
              coalesce (DvcFQDN, DvcHostname, DvcId, _ResourceId, strcat (EventVendor,'/', EventProduct)),
              coalesce (DvcFQDN, DvcHostname, DvcIpAddr, DvcId, _ResourceId, strcat (EventVendor,'/', EventProduct))
        ),
        Dst = coalesce (DstFQDN, DstHostname, DstIpAddr, DstDvcId),
        Src = coalesce (SrcFQDN, SrcHostname, SrcIpAddr, SrcDvcId),
        DvcInterface = iff(isempty(DvcInterface), coalesce(DvcInboundInterface, DvcOutboundInterface), DvcInterface),
        Hostname = iff  (EventType == "EndpointNetworkSession" and NetworkDirection == ("Inbound"), SrcHostname, DstHostname),
        IpAddr = iff  (EventType == "EndpointNetworkSession" and NetworkDirection == ("Inbound"), DstIpAddr, SrcIpAddr),
        Rule = coalesce(NetworkRuleName, tostring(NetworkRuleNumber)),
        Duration = NetworkDuration,
        SessionId = NetworkSessionId,
        User = DstUsername,
        InnerVlanId = SrcVlanId,
        OuterVlanId = DstVlanId
    | project-away
        TenantId, SourceSystem, DvcSubscriptionId, _SubscriptionId, _ResourceId
  };
parser (disabled=disabled)
}



//
// Function Name: ASimNetworkSessionPaloAltoCEF
// Description: This ASIM parser supports normalizing Palo Alto PanOS logs produced by the Microsoft Sentinel Palo Alto Networks connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionPaloAltoCEF(    ['disabled']:bool=false)
{
let Actions=datatable(DeviceAction:string,DvcAction:string)
[ "reset client","Reset Source"
, "reset server","Reset Destination"
, "reset both", "Reset"
, "allow","Allow"
, "deny","Deny"
, "drop", "Drop"
, "drop ICMP", "Drop ICMP"
, "reset-client","Reset Source"
, "reset-server","Reset Destination"
, "reset-both", "Reset"
, "drop-icmp", "Drop ICMP"];
let NWParser=(disabled:bool=false){
CommonSecurityLog | where not(disabled)
| where DeviceVendor == "Palo Alto Networks" and DeviceProduct == "PAN-OS" and Activity == "TRAFFIC"
| parse AdditionalExtensions with "PanOSPacketsReceived=" DstPackets:long * "PanOSPacketsSent=" SrcPackets:long *
  // -- Adjustment to support both old and new CSL fields.
| extend 
  EventStartTime =  coalesce(
    todatetime(StartTime), 
    extract(@'start=(.*?)(?:;|$)',1, AdditionalExtensions,typeof(datetime)),
    datetime(null)
  ),
  EventOriginalResultDetails = coalesce(
    column_ifexists("Reason", ""),
    extract(@'reason=(.*?)(?:;|$)',1, AdditionalExtensions, typeof(string)),
    ""
  )
| project-rename 
    EventProductVersion=DeviceVersion // Not Documented
  , Dvc=DeviceName   
  , NetworkApplicationProtocol=ApplicationProtocol
  , SrcZone=DeviceCustomString4 
  , DstZone=DeviceCustomString5
  , NetworkRuleName=DeviceCustomString1
  , SrcUsername=SourceUserName 
  , DstUsername=DestinationUserName 
  , EventOriginalSeverity=LogSeverity // not documented
  , SrcNatIpAddr=SourceTranslatedAddress
  , DstNatIpAddr=DestinationTranslatedAddress
  , PaloAltoFlags=FlexString1 // Flags
| extend
EventVendor="Palo Alto"
  ,EventProduct="PanOS" // Not Documented
  , SrcBytes=tolong(SentBytes)
  , DstBytes=tolong(ReceivedBytes) 
  , NetworkProtocol=toupper(Protocol)
  , NetworkBytes=tolong(FlexNumber1)
  , SrcUsernameType=case(isempty(SrcUsername), "", SrcUsername contains "@", "UPN", "Simple")
  , DstUsernameType=case(isempty(DstUsername), "", DstUsername contains "@", "UPN", "Simple")
  , EventType="NetworkSession"
  , EventCount=toint(1)
  , EventResult=case(DeviceAction=="allow","Success","Failure")
  // -- Adjustment to support both old and new CSL fields.
  , NetworkPackets = coalesce(
      tolong(column_ifexists("FieldDeviceCustomNumber2", long(null))),
      tolong(column_ifexists("DeviceCustomNumber2",long(null)))
    )
  , NetworkSessionId = coalesce(
      tostring(column_ifexists("FieldDeviceCustomNumber1", long(null))),
      tostring(column_ifexists("DeviceCustomNumber1",long(null)))
    )
  , NetworkDuration= coalesce(
      toint(1000*column_ifexists("FieldDeviceCustomNumber3", 0)),
      toint(1000*column_ifexists("DeviceCustomNumber3",0)),
      int(null)
    )
  , EventSchemaVersion="0.2.1"
  , EventSchema="NetworkSession"
  , EventSeverity = "Informational"
| extend hostelements=split(Dvc,'.')
| extend DvcHostname=tostring(hostelements[0])
       , DvcDomain=strcat_array( array_slice(hostelements,1,-1), '.')
| extend DvcFQDN = iff(Dvc contains ".",Dvc,"" )
      , DvcDomainType=iff(Dvc contains ".","FQDN","" )
| project-away hostelements
| lookup Actions on DeviceAction
| project-rename
  DstMacAddr=DestinationMACAddress
  , SrcMacAddr=SourceMACAddress
  , DstIpAddr=DestinationIP
  , DstPortNumber=DestinationPort
  , DstNatPortNumber=DestinationTranslatedPort
  , SrcPortNumber=SourcePort
  , SrcIpAddr=SourceIP
  , SrcNatPortNumber=SourceTranslatedPort
  , DvcOutboundInterface=DeviceOutboundInterface
  , DvcInboundInterface=DeviceInboundInterface
  , EventMessage=Message
  , DvcOriginalAction=DeviceAction
// -- Aliases
| extend
IpAddr = SrcIpAddr,
Rule=NetworkRuleName,
Dst=DstIpAddr,
// Host=DstHostname, 
User=DstUsername,
Duration=NetworkDuration,
SessionId=NetworkSessionId,
EventEndTime =EventStartTime,
Src=SrcIpAddr
| project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, Process*, ReceiptTime, ReceivedBytes, Remote*, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, EventOutcome, FieldDevice*, ExtID, Reason, ReportReferenceLink, Activity, Computer, OriginalLogSeverity, PaloAltoFlags, Protocol
};
NWParser (disabled)
}



//
// Function Name: ASimNetworkSessionPaloAltoCortexDataLake
// Description: This ASIM parser supports normalizing NetworkSession logs from Palo Alto Cortex Data Lake to the ASIM NetworkSession normalized schema. These events are captured through the Palo Alto Networks CDL data connector that ingests CDL logs into Microsoft Sentinel.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionPaloAltoCortexDataLake(    ['disabled']:bool=false)
{
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
[
    "0", "Low",
    "1", "Low",
    "2", "Low",
    "3", "Low",
    "4", "Low",
    "5", "Low",
    "6", "Medium",
    "7", "Medium",
    "8", "Medium",
    "9", "High",
    "10", "High"
];
let EventResultDvcActionLookup = datatable (
    DeviceAction: string,
    DvcAction: string,
    EventResult: string
)
    [
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "reset client", "Reset Source", "Failure",
    "reset server", "Reset Destination", "Failure",
    "reset both", "Reset", "Failure",
    "drop", "Drop", "Failure",
    "drop ICMP", "Drop ICMP", "Failure",
    "reset-both", "Reset", "Failure"
];
let EventResultDetailsLookup = datatable(Reason: string, EventResultDetails: string)[
    "threat", "Reset",
    "policy-deny", "Unknown",
    "decrypt-cert-validation", "Terminated",
    "decrypt-unsupport-param", "Terminated",
    "decrypt-error", "Terminated",
    "tcp-rst-from-client", "Reset",
    "tcp-rst-from-server", "Reset",
    "resources-unavailable", "Unknown",
    "tcp-fin", "Unknown",
    "tcp-reuse", "Unknown",
    "decoder", "Unknown",
    "aged-out", "Unknown",
    "unknown", "Unknown",
    "n/a", "NA",
];
let ThreatRiskLevelLookup = datatable(PanOSApplicationRisk: string, ThreatRiskLevel: int)
    [
    "1", 20,
    "2", 40,
    "3", 60,
    "4", 80,
    "5", 100
];
let parser = (disabled: bool=false) {
    CommonSecurityLog
    | where not(disabled)
        and DeviceVendor == "Palo Alto Networks" and DeviceProduct == "LF"
        and DeviceEventClassID == "TRAFFIC"
    | parse-kv AdditionalExtensions as (PanOSSessionStartTime: string, PanOSDestinationDeviceHost: string, PanOSSourceDeviceHost: string, PanOSDestinationUUID: string, PanOSDestinationLocation: string, PanOSSourceUUID: string, PanOSDestinationDeviceMac: string, PanOsBytes: long, PanOSIsClienttoServer: string, PanOSSourceLocation: string, PanOSSourceDeviceMac: string, PanOSPacketsReceived: long, PanOSPacketsSent: long, PanOSRuleUUID: int, PanOSApplicationCategory: string, PanOSApplicationSubcategory: string, PanOSChunksReceived: string, PanOSChunksSent: string, PanOSChunksTotal: string, PanOSApplicationContainer: string, PanOSDestinationDeviceCategory: string, PanOSLinkChangeCount: string, PanOSLinkSwitches: string, PanOSLogSource: string, PanOSNSSAINetworkSliceDifferentiator: string, PanOSNSSAINetworkSliceType: string, PanOSOutboundInterfaceDetailsPort: string, PanOSOutboundInterfaceDetailsSlot: string, PanOSOutboundInterfaceDetailsType: string, PanOSOutboundInterfaceDetailsUnit: string, PanOSParentSessionID: string, PanOsRuleUUID: string, PanOSSourceDeviceOS: string, PanOSSourceDeviceOSFamily: string, PanOSSourceDeviceOSVersion: string, PanOSSourceDeviceCategory: string, PanOSVirtualSystemID: string, PanOSVirtualSystemName: string, PanOSCortexDataLakeTenantID: string, PanOSApplicationRisk: string, PanOSIsSaaSApplication: string) with (pair_delimiter=";", kv_delimiter="=")
    | invoke _ASIM_ResolveDvcFQDN('DeviceName')
    | invoke _ASIM_ResolveDstFQDN('PanOSDestinationDeviceHost')
    | invoke _ASIM_ResolveSrcFQDN('PanOSSourceDeviceHost')
    | lookup EventResultDvcActionLookup on DeviceAction
    | lookup EventSeverityLookup on LogSeverity
    | lookup EventResultDetailsLookup on Reason
    | lookup ThreatRiskLevelLookup on PanOSApplicationRisk
    | extend
        EventStartTime = todatetime(PanOSSessionStartTime),
        SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
        DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
        NetworkSessionId = tostring(FieldDeviceCustomNumber1),
        NetworkDuration = toint(FieldDeviceCustomNumber3),
        DstBytes = tolong(ReceivedBytes),
        SrcBytes = tolong(SentBytes),
        SrcDomain = coalesce(SourceNTDomain, SrcDomain),
        DstDomain = coalesce(DestinationNTDomain, DstDomain),
        AdditionalFields = bag_pack(
                      "urlcategory",
                      DeviceCustomString2,
                      "virtualLocation",
                      DeviceCustomString3,
                      "PanOSApplicationCategory",
                      PanOSApplicationCategory,
                      "PanOSApplicationSubcategory",
                      PanOSApplicationSubcategory,
                      "PanOSChunksReceived",
                      PanOSChunksReceived,
                      "PanOSChunksSent",
                      PanOSChunksSent,
                      "PanOSChunksTotal",
                      PanOSChunksTotal,
                      "PanOSApplicationContainer",
                      PanOSApplicationContainer,
                      "PanOSDestinationDeviceCategory",
                      PanOSDestinationDeviceCategory,
                      "PanOSIsClienttoServer",
                      PanOSIsClienttoServer,
                      "PanOSLinkChangeCount",
                      PanOSLinkChangeCount,
                      "PanOSLinkSwitches",
                      PanOSLinkSwitches,
                      "PanOSLogSource",
                      PanOSLogSource,
                      "PanOSNSSAINetworkSliceDifferentiator",
                      PanOSNSSAINetworkSliceDifferentiator,
                      "PanOSNSSAINetworkSliceType",
                      PanOSNSSAINetworkSliceType,
                      "PanOSOutboundInterfaceDetailsPort",
                      PanOSOutboundInterfaceDetailsPort,
                      "PanOSOutboundInterfaceDetailsSlot",
                      PanOSOutboundInterfaceDetailsSlot,
                      "PanOSOutboundInterfaceDetailsType",
                      PanOSOutboundInterfaceDetailsType,
                      "PanOSOutboundInterfaceDetailsUnit",
                      PanOSOutboundInterfaceDetailsUnit,
                      "PanOSParentSessionID",
                      PanOSParentSessionID,
                      "PanOsRuleUUID",
                      PanOsRuleUUID,
                      "PanOSSourceDeviceOS",
                      PanOSSourceDeviceOS,
                      "PanOSSourceDeviceOSFamily",
                      PanOSSourceDeviceOSFamily,
                      "PanOSSourceDeviceOSVersion",
                      PanOSSourceDeviceOSVersion,
                      "PanOSSourceDeviceCategory",
                      PanOSSourceDeviceCategory,
                      "PanOSVirtualSystemID",
                      PanOSVirtualSystemID,
                      "PanOSVirtualSystemName",
                      PanOSVirtualSystemName
                  )
    | project-rename
        DvcIpAddr = Computer,
        EventUid = _ItemId,
        DstDvcId = PanOSDestinationUUID,
        DstGeoCountry = PanOSDestinationLocation,
        DstMacAddr = PanOSDestinationDeviceMac,
        DstNatIpAddr = DestinationTranslatedAddress,
        DstNatPortNumber = DestinationTranslatedPort,
        DstPackets = PanOSPacketsReceived,
        DstPortNumber = DestinationPort,
        DstUsername = DestinationUserName,
        DvcId = DeviceExternalID,
        DvcOriginalAction = DeviceAction,
        EventOriginalSeverity = LogSeverity,
        DstZone = DeviceCustomString5,
        EventOriginalType = DeviceEventClassID,
        EventOriginalUid = ExtID,
        EventProductVersion = DeviceVersion,
        NetworkPackets = FieldDeviceCustomNumber2,
        NetworkRuleName = DeviceCustomString1,
        SrcDvcId = PanOSSourceUUID,
        SrcGeoCountry = PanOSSourceLocation,
        SrcMacAddr = PanOSSourceDeviceMac,
        SrcNatIpAddr = SourceTranslatedAddress,
        SrcNatPortNumber = SourceTranslatedPort,
        SrcPackets = PanOSPacketsSent,
        SrcPortNumber = SourcePort,
        SrcUsername = SourceUserName,
        SrcZone = DeviceCustomString4,
        DvcScopeId = PanOSCortexDataLakeTenantID,
        EventOriginalSubType = Activity,
        DstUserId = DestinationUserID,
        EventOriginalResultDetails = Reason,
        SrcUserId = SourceUserID,
        DvcInboundInterface = DeviceInboundInterface,
        DvcOutboundInterface = DeviceOutboundInterface,
        SrcAppName = ApplicationProtocol,
        ThreatOriginalRiskLevel = PanOSApplicationRisk
    | extend
        Dvc = coalesce(DvcFQDN, DvcId, DvcHostname, DvcIpAddr),
        EventEndTime = EventStartTime,
        Dst = coalesce(DstDvcId, DstHostname, DstIpAddr),
        Src = coalesce(SrcDvcId, SrcHostname, SrcIpAddr),
        DstUserType = _ASIM_GetUserType(DstUsername, ""),
        NetworkProtocol = toupper(Protocol),
        NetworkBytes = SrcBytes + DstBytes,
        NetworkProtocolVersion = case(
                            DstIpAddr contains ".",
                            "IPv4",       
                            DstIpAddr contains ":",
                            "IPv6", 
                            ""
                        ),
        NetworkDirection = iff(PanOSIsClienttoServer == "true", "Outbound", "Inbound"),
        Rule = NetworkRuleName,
        SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
        DstUsernameType = _ASIM_GetUsernameType(DstUsername),
        DvcIdType = iff(isnotempty(DvcId), "Other", ""),
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        SessionId = NetworkSessionId,
        User = DstUsername,
        Hostname = DstHostname,
        SrcDvcIdType = iff(isnotempty(SrcDvcId), "Other", ""),
        DstDvcIdType = iff(isnotempty(DstDvcId), "Other", ""),
        SrcDomainType = iff(isnotempty(SourceNTDomain), "Windows", SrcDomainType),
        DstDomainType = iff(isnotempty(DestinationNTDomain), "Windows", DstDomainType),
        DstUserIdType = iff(isnotempty(DstUserId), "UID", ""),
        SrcUserIdType = iff(isnotempty(SrcUserId), "UID", ""),
        SrcAppType = case(
                isnotempty(SrcAppName) and PanOSIsSaaSApplication == "true",
                "SaaS Application",
                isnotempty(SrcAppName) and PanOSIsSaaSApplication == "false",
                "Other",
                ""
            )
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventProduct = "Cortex Data Lake",
        EventVendor = "Palo Alto"
    | project-away
        Source*,
        Destination*,
        Device*,
        AdditionalExtensions,
        CommunicationDirection,
        EventOutcome,
        PanOS*,
        PanOs*,
        Protocol,
        SimplifiedDeviceAction,
        ExternalID,
        Message,
        EndTime,
        FieldDevice*,
        Flex*,
        File*,
        Old*,
        MaliciousIP*,
        OriginalLogSeverity,
        Process*,
        ReceivedBytes,
        SentBytes,
        Remote*,
        Request*,
        StartTime,
        TenantId,
        ReportReferenceLink,
        ReceiptTime,
        Indicator*,
        _ResourceId,
        ThreatConfidence,
        ThreatDescription,
        ThreatSeverity
};
parser(disabled=disabled)
}



//
// Function Name: ASimNetworkSessionSentinelOne
// Description: This ASIM parser supports normalizing SentinelOne logs to the ASIM Network Session normalized schema. SentinelOne events are captured through SentinelOne data connector which ingests SentinelOne server objects such as Threats, Agents, Applications, Activities, Policies, Groups, and more events into Microsoft Sentinel through the REST API.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionSentinelOne(    ['disabled']:bool=false)
{
let NetworkDirectionLookup = datatable (
    alertInfo_netEventDirection_s: string, 
    NetworkDirection: string
)[
    "OUTGOING", "Outbound",
    "INCOMING", "Inbound",
];
let DeviceTypeLookup = datatable (
    agentDetectionInfo_machineType_s: string,
    SrcDeviceType: string
)
    [
    "desktop", "Computer",
    "server", "Computer",
    "laptop", "Computer",
    "kubernetes node", "Other",
    "unknown", "Other"
];
let ThreatConfidenceLookup_undefined = datatable(
    alertInfo_analystVerdict_s: string,
    ThreatConfidence_undefined: int
)
    [
    "FALSE_POSITIVE", 5,
    "Undefined", 15,
    "SUSPICIOUS", 25,
    "TRUE_POSITIVE", 33 
];
let ThreatConfidenceLookup_suspicious = datatable(
    alertInfo_analystVerdict_s: string,
    ThreatConfidence_suspicious: int
)
    [
    "FALSE_POSITIVE", 40,
    "Undefined", 50,
    "SUSPICIOUS", 60,
    "TRUE_POSITIVE", 67 
];
let ThreatConfidenceLookup_malicious = datatable(
    alertInfo_analystVerdict_s: string,
    ThreatConfidence_malicious: int
)
    [
    "FALSE_POSITIVE", 75,
    "Undefined", 80,
    "SUSPICIOUS", 90,
    "TRUE_POSITIVE", 100 
];
let parser = (disabled: bool=false) {
    let alldata = SentinelOne_CL
        | where not(disabled) 
            and event_name_s == "Alerts." 
            and alertInfo_eventType_s == "TCPV4"
        | lookup NetworkDirectionLookup on alertInfo_netEventDirection_s
        | lookup DeviceTypeLookup on agentDetectionInfo_machineType_s;
    let undefineddata = alldata
        | where ruleInfo_treatAsThreat_s == "UNDEFINED"
        | lookup ThreatConfidenceLookup_undefined on alertInfo_analystVerdict_s;
    let suspiciousdata = alldata
        | where ruleInfo_treatAsThreat_s == "Suspicious"
        | lookup ThreatConfidenceLookup_suspicious on alertInfo_analystVerdict_s;
    let maliciousdata = alldata
        | where ruleInfo_treatAsThreat_s == "Malicious"
        | lookup ThreatConfidenceLookup_malicious on alertInfo_analystVerdict_s;
    union undefineddata, suspiciousdata, maliciousdata
    | invoke _ASIM_ResolveDvcFQDN('agentDetectionInfo_name_s')
    | extend 
        DstPortNumber = toint(alertInfo_dstPort_s),
        SrcPortNumber = toint(alertInfo_srcPort_s),
        ThreatConfidence = coalesce(ThreatConfidence_undefined, ThreatConfidence_suspicious, ThreatConfidence_malicious)
    | project-rename
        EventStartTime = sourceProcessInfo_pidStarttime_t,
        DstIpAddr = alertInfo_dstIp_s,
        EventUid = _ItemId,
        SrcIpAddr = alertInfo_srcIp_s,
        DvcId = agentDetectionInfo_uuid_g,
        DvcOs = agentDetectionInfo_osName_s,
        DvcOsVersion = agentDetectionInfo_osRevision_s,
        EventOriginalSeverity = ruleInfo_severity_s,
        EventOriginalUid = alertInfo_dvEventId_s,
        SrcProcessName = sourceProcessInfo_name_s,
        SrcProcessId = sourceProcessInfo_pid_s,
        SrcUsername = sourceProcessInfo_user_s,
        ThreatOriginalConfidence = ruleInfo_treatAsThreat_s
    | extend
        EventEndTime = EventStartTime,
        Dst = DstIpAddr,
        DvcIpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        SrcHostname = DvcHostname,
        SrcDvcId = DvcId,
        IpAddr = SrcIpAddr,
        EventSeverity = iff(EventOriginalSeverity == "Critical", "High", EventOriginalSeverity),
        SrcDvcIdType = iff(isnotempty(DvcId), "Other", ""),
        DvcIdType = iff(isnotempty(DvcId), "Other", ""),
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        SrcUserType = _ASIM_GetUserType(SrcUsername, "")
    | extend
        Dvc = coalesce(DvcId, DvcHostname, DvcIpAddr),
        Hostname = SrcHostname
    | extend
        EventCount = int(1),
        EventProduct = "SentinelOne",
        EventResult = "Success",
        DvcAction = "Allow",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventResultDetails = "NA",
        EventType = "EndpointNetworkSession",
        EventVendor = "SentinelOne",
        NetworkProtocol = "TCP",
        NetworkProtocolVersion = "IPv4"
    | project-away
        *_d,
        *_s,
        *_g,
        *_t,
        *_b,
        _ResourceId,
        TenantId,
        RawData,
        Computer,
        MG,
        ManagementGroupName,
        SourceSystem,
        ThreatConfidence_*
};
parser(disabled = disabled)
}



//
// Function Name: ASimNetworkSessionSonicWallFirewall
// Description: This ASIM parser supports normalizing SonicWall SonicOS ArcSight-formatted Syslog data ingested by Microsoft Sentinel into CommonSecurityLogs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionSonicWallFirewall(    ['disabled']:bool=false)
{
let Actions=datatable(fw_action:string,DvcAction:string)
[ "reset client","Reset Source"
, "reset server","Reset Destination"
, "reset both", "Reset" 
, "allow","Allow"
, "\"forward\"","Allow"
, "\"mgmt\"","Other"
, "\"NA\"","Other"
, "deny","Deny"
, "\"drop\"", "Drop"
, "drop ICMP", "Drop ICMP"];
let Parser=(disabled:bool=false){
CommonSecurityLog
| where not(disabled)
| where DeviceVendor == "SonicWall"
| where DeviceEventClassID !in (14, 97, 1382, 440, 441, 442, 646, 647, 734, 735)
| parse-kv AdditionalExtensions as (['gcat']:string, ['app']:string, ['arg']:string, ['dstV6']:string, ['srcV6']:string, ['snpt']:string, ['dnpt']:string, ['susr']:string,['appName']:string, ['appcat']:string, ['appid']:string, ['sid']:string, ['catid']:string, ['ipscat']:string, ['ipspri']:string, ['spycat']:string, ['spypri']:string, ['fw_action']:string, ['dpi']:string, ['bid']:string, ['af_action']:string, ['af_polid']:string, ['af_policy']:string, ['af_type']:string, ['af_service']:string, ['af_object']:string, ['contentObject']:string, ['fileid']:string, ['uuid']:string) with (pair_delimiter=";", kv_delimiter="=")
| extend
  SourceIP = coalesce(SourceIP, srcV6)
  , DestinationIP = coalesce(DestinationIP, dstV6)
| where ( isnotempty(SourceIP) and isnotempty(DestinationIP) )
| where gcat in (3, 5, 6, 10) // Include only these event categories.
| lookup Actions on fw_action
// Sets the mandatory EventResult based on the DvcAction.
| extend EventResult = case(DvcAction == "Allow", "Success",
                          DvcAction == "Management", "NA",
                          DvcAction == "NA", "NA",
                          DvcAction == "Other", "NA",
                          "Failure"
                          )
| extend sosLogMsgSeverity = case(LogSeverity == 10, "Emergency (0)",
                                            LogSeverity == 9, "Alert (1)",
                                            LogSeverity == 8, "Critical (2)",
                                            LogSeverity == 7, "Error (3)",
                                            LogSeverity == 6, "Warning (4)",
                                            LogSeverity == 5, "Notice (5)",
                                            LogSeverity == 4, "Info (6)/Debug (7)",
                                            LogSeverity == 3, "Not Mapped (3)",
                                            LogSeverity == 2, "Not Mapped (2)",
                                            LogSeverity == 1, "Not Mapped (1)",
                                            "Not Mapped"
                                            )
| extend EventSeverity = case(tolong(LogSeverity) <= 4, "Informational"
                              , tolong(LogSeverity) <= 6, "Low"
                              , tolong(LogSeverity) <= 8, "Medium"
                              , tolong(LogSeverity) > 8, "High"
                              , ""
                              )
| extend NetworkProtocolVersion = case(DestinationIP has ".", "IPv4"
                                      , DestinationIP has ":", "IPv6"
                                      , ""
                                      )
  , NetworkProtocol = toupper(iff(Protocol contains "-" and Protocol !contains "/", toupper(trim_start(@".*-", Protocol)), toupper(trim_end(@"/.*", Protocol))))
  , NetworkApplicationProtocol = tostring(toupper(trim_start(@".*/", Protocol)))
  , EventOriginalType = DeviceEventClassID
| project-rename
  DstMacAddr = DestinationMACAddress
  , SrcMacAddr = SourceMACAddress
  , DstIpAddr = DestinationIP
  , SrcIpAddr = SourceIP
  , DstPortNumber = DestinationPort
  , SrcPortNumber = SourcePort
  , EventMessage = Activity
  , sosEventMessageDetail = Message
  , EventProductVersion = DeviceVersion
  , sosSerialNumber = Computer
  , DvcOutboundInterface = DeviceOutboundInterface
  , DvcInboundInterface = DeviceInboundInterface
  , sosApplicationID = ApplicationProtocol // Application ID number (when Flow Reporting is enabled).
  , sosCFSFullString = Reason // CFS Category ID and Name
  , NetworkRuleName = DeviceCustomString1 // Rule ID. Identify a policy or rule associated with an event.
  , sosSourceVPNPolicyName = DeviceCustomString2 // Displays the source VPN policy name associated with the event.
  , sosDestinationVPNPolicyName = DeviceCustomString3 // Displays the destination VPN policy name associated with the event.
  , sosLogMsgNote = DeviceCustomString6 // "Note" field. Additional information that is application-dependent.
  , SrcNatIpAddr = DeviceCustomString1Label // NAT'ed source IP4/IPv6 address.
  , DstNatIpAddr = DeviceCustomString2Label // NAT'ed destination IPv4/IPv6 address.
  , sosSourceZone = DeviceCustomString3Label // Source Zone on Gen7. Src Zone Type on Gen6.
  , sosDestinationZone = DeviceCustomString4Label // Destination Zone on Gen7. Dest Zone Type (Trusted/Untrusted, etc.) on Gen6.
  , sosUserSessionType = DeviceCustomString5Label // String indicating the user session type, determined by the auth mechanism.
  , sosUserSessionDuration = DeviceCustomString6Label // User session duration in seconds.
  , NetworkIcmpType = FieldDeviceCustomNumber1 // ICMP Type
  , NetworkIcmpCode = FieldDeviceCustomNumber2 // ICMP Code
  , SrcUsername = SourceUserName
  , ThreatOriginalConfidence = ThreatConfidence
| extend sosLogMsgCategory = case(gcat == 1, "System (1)",
                                              gcat == 2, "Log (2)",
                                              gcat == 3, "Security Services (3)",
                                              gcat == 4, "Users (4)",
                                              gcat == 5, "Firewall Settings (5)",
                                              gcat == 6, "Network (6)",
                                              gcat == 7, "VPN (7)",
                                              gcat == 8, "High Availability (8)",
                                              gcat == 9, "3G/4G, Modem, and Module (9)",
                                              gcat == 10, "Firewall (10)",
                                              gcat == 11, "Wireless (11)",
                                              gcat == 12, "VoIP (12)",
                                              gcat == 13, "SSL VPN (13)",
                                              gcat == 14, "Anti-Spam (14)",
                                              gcat == 15, "WAN Acceleration (15)",
                                              gcat == 16, "Object (16)",
                                              gcat == 17, "SD-WAN (17)",
                                              gcat == 18, "Multi-Instance (18)",
                                              gcat == 19, "Unified Policy Engine (19)",
                                              "Log Category Not Mapped"
                                              )
| extend sosLegacyMessageCategory = case(DeviceEventCategory == 0, "None (0)",
                                            DeviceEventCategory == 1, "System Maintenance (1)",
                                            DeviceEventCategory == 2, "System Errors (2)",
                                            DeviceEventCategory == 4, "Blocked Web Sites (4)",
                                            DeviceEventCategory == 8, "Blocked Java Etc. (8)",
                                            DeviceEventCategory == 16, "User Activity (16)",
                                            DeviceEventCategory == 32, "Attacks (32)",
                                            DeviceEventCategory == 64, "Dropped TCP (64)",
                                            DeviceEventCategory == 128, "Dropped UDP (128)",
                                            DeviceEventCategory == 256, "Dropped ICMP (256)",
                                            DeviceEventCategory == 512, "Network Debug (512)",
                                            DeviceEventCategory == 1024, "Connection Closed (1024)",
                                            DeviceEventCategory == 2048, "Dropped LAN TCP (2048)",
                                            DeviceEventCategory == 4096, "Dropped LAN UDP (4096)",
                                            DeviceEventCategory == 8192, "Dropped LAN ICMP (8192)",
                                            DeviceEventCategory == 32768, "Modem Debug (32768)",
                                            DeviceEventCategory == 65536, "VPN Tunnel Status (65536)",
                                            DeviceEventCategory == 131072, "IEEE 802.11 Management (131072)",
                                            DeviceEventCategory == 262144, "Connection Opened (262144)",
                                            DeviceEventCategory == 524288, "System Environment (524288)",
                                            DeviceEventCategory == 1048576, "Expanded - VoIP Activity (1048576)",
                                            DeviceEventCategory == 2097152, "Expanded - WLAN IDS Activity (2097152)",
                                            DeviceEventCategory == 4194304, "Expanded - SonicPoint Activity (4194304)",
                                            DeviceEventCategory == 8388608, "Expanded - Unified Policy Engine (8388608)",
                                            "Legacy Category Not Mapped"
                                            )
| extend sosIPSPriority = case(ipspri == 1, "High (1)",
                                            ipspri == 2, "Medium (2)",
                                            ipspri == 3, "Low (3)",
                                            ""
                                            )
| extend sosAntiSpywarePriority = case(spypri == 1, "High (1)",
                                            spypri == 2, "Medium (2)",
                                            spypri == 3, "Low (3)",
                                            ""
                                            )
| extend
    EventVendor = "SonicWall"
  , EventProduct = "Firewall"
  , DvcOs = "SonicOS"
  , DvcOsVersion = EventProductVersion
  , DvcIdType = "Other"
  , Dvc = sosSerialNumber
  , DvcDescription = DeviceProduct
  , ASimMatchingHostname = "-"
  , ASimMatchingIpAddr = "-"
  , NetworkIcmpType = tostring(NetworkIcmpType)
  , NetworkIcmpCode = toint(NetworkIcmpCode)
  , Rule = NetworkRuleName
  , NetworkBytes = tolong(coalesce(toint(ReceivedBytes), 0) + coalesce(toint(SentBytes), 0))
  , sosIPSFullString = ipscat
  , ipscat = extract(@'^"?([a-zA-Z-\/]+)', 1, ipscat) // IPS Category/Signature
  , sosIPSSignatureName = extract(@'[ ](.*)\S', 1, ipscat) // IPS Signature name
  , FileSize = tolong(coalesce(FileSize, long(null)))
  , sosAppControlFileName = extract(@'.*Filename: (.*)\"', 1, sosEventMessageDetail) // App Control Filename Logging
  , sosCaptureATPVerdict = extract(@'Gateway Anti-Virus Status: (.*)\. ', 1, sosEventMessageDetail)
  , sosGAVSignatureName = extract(@'Gateway Anti-Virus Alert: (.*) blocked\.', 1, sosEventMessageDetail)
  , sosASWSignatureName = extract(@'Anti-Spyware Detection Alert: (.*)\. ', 1, sosEventMessageDetail)
  , sosCountry = extract(@'Country Name:(.*)\"$', 1, sosEventMessageDetail)
  , SrcZone = sosSourceZone
  , DstZone = sosDestinationZone
  , EventOriginalSeverity = LogSeverity
  , Dst = DstIpAddr
  , Src = SrcIpAddr
  , IpAddr = SrcIpAddr
  , sosCFSCategoryID = extract(@'(\d+)\s', 1, coalesce(sosCFSFullString, "")) // Application Name from App Control
  , sosCFSCategoryName = extract(@'.*-("(.*))', 1, coalesce(sosCFSFullString, "")) // Application Name from App Control
  , sosCFSPolicyName = extract(@'Policy: (.*), Info:', 1, coalesce(sosLogMsgNote, ""))
  , EventStartTime = TimeGenerated
  , EventEndTime = TimeGenerated
  , EventType = "NetworkSession"
  , EventSchemaVersion = "0.2.6"
  , EventSchema = "NetworkSession"
  , EventCount = toint(1)
  , EventUid = _ItemId
  , EventResultDetails = "NA"
  , ThreatConfidence = coalesce(toint(ThreatOriginalConfidence), int(null))
| extend
    SrcUsername = coalesce(susr, SrcUsername)
    , FileName = coalesce(FileName, sosAppControlFileName)
    , NetworkDirection = case(SrcZone == "" and DstZone == "", "NA"
                              , SrcZone == "WAN" and (DstZone == "WAN" and DstIpAddr !has ".255"), "Inbound"
                              , SrcZone == "WAN" and DstZone == "WAN", "External"
                              , SrcZone == "WAN" and DstZone != "WAN", "Inbound"
                              , SrcZone == "VPN" and DstZone == "WAN", "Outbound"
                              , SrcZone == "VPN" and DstZone != "WAN", "Inbound"
                              , DstZone == "MULTICAST", "NA"
                              , DstZone == "WAN", "Outbound"
                              , "Local"
                              )
| extend
    SrcUsernameType = case(SrcUsername has "=", "DN",
                                  SrcUsername has "\\", "Windows",
                                  SrcUsername has "@", "UPN",
                                  SrcUsername == "Unknown (external IP)", "",
                                  SrcUsername == "Unknown (SSO bypassed)", "",
                                  isnotempty(SrcUsername), "Simple",
                                  ""
                                  )
    , ThreatField = case(isnotempty(ThreatOriginalConfidence) and NetworkDirection == "Outbound", "SrcIpAddr"
                        , isnotempty(ThreatOriginalConfidence) and NetworkDirection == "Inbound", "DstIpAddr"
                        , ""
                        )
| extend
    ThreatIpAddr = case(ThreatField == "SrcIpAddr", SrcIpAddr
                        , ThreatField == "DstIpAddr", DstIpAddr
                        , ""
                        )
| extend
  SrcGeoCountry = iff(NetworkDirection == "Inbound", sosCountry, "")
  , DstGeoCountry = iff(NetworkDirection == "Outbound", sosCountry, "")
  , SrcAppName = iff(NetworkDirection in ("Inbound", "Local", "NA"), coalesce(appcat, appName), "")
  , DstAppName = iff(NetworkDirection in ("Outbound", "Local", "NA"), coalesce(appcat, appName), "")
  , SrcAppId = iff(NetworkDirection in ("Inbound", "Local", "NA"), sid, "")
  , DstAppId = iff(NetworkDirection in ("Outbound", "Local", "NA"), sid, "")
| extend
  SrcAppType = case(isempty(SrcAppName), ""
                    , SrcAppName contains "\'General " or SrcAppName contains "\'Service ", "Service", "Other")
  , DstAppType = case(isempty(DstAppName), ""
                    , DstAppName contains "\'General " or DstAppName contains "\'Service ", "Service", "Other")
| project-rename
    sosReceivedPackets = DeviceCustomNumber1Label // DeviceCustomNumberXLabel (cnXLabel=)
  , sosSentPackets = DeviceCustomNumber2Label // DeviceCustomNumberXLabel (cnXLabel=)
| extend
    DstPackets = case(NetworkDirection == "Outbound", tolong(sosReceivedPackets)
                  , NetworkDirection == "Inbound", tolong(sosSentPackets)
                  , tolong(long(null))
                  )
  , SrcPackets = case(NetworkDirection == "Outbound", tolong(sosSentPackets)
                  , NetworkDirection == "Inbound", tolong(sosReceivedPackets)
                  , tolong(long(null))
                  )
| project-rename
    sosConnectionDuration = DeviceCustomNumber3Label // Applies to "Connection Closed"
  , sosUser = susr // Logged-in username associated with the log event.
  , sosAppRulePolicyId = af_polid // App Rule Policy ID.
  , sosAppRulePolicyName = af_policy // App Rule Policy Name.
  , sosAppRuleService = af_service // App Rule Service Name.
  , sosAppRuleType = af_type // App Rule Policy Type.
  , sosAppRuleObject = af_object // App Rule Object Name.
  , sosAppRuleObjectContent = contentObject // App Rule Object Content.
  , sosAppRuleAction = af_action
  , sosSourceIPv6Address = srcV6
  , sosDestinationIPv6Address = dstV6
  , sosAppFullString = appcat // The full "<CATEGORY> <APPNAME> -- <SIGNAME>" string.
  , sosAppIDNumber = app // Numeric Application ID. Not the same as "ApplicationProtocol".
  , sosAppID = appid // Application ID from App Control
  , sosAppCategoryID = catid // Application Category ID
  , sosAppSignatureID = sid // Application Signature ID
  , sosIPSCategoryName = ipscat // IPS Category Name
  , sosAntiSpywareCategory = spycat // Anti-Spyware Category
  , sosURLPathName = arg // URL. Represents the URL path name.
  , sosFileIdentifier = fileid // File hash or URL
  , sosDPIInspectedFlow = dpi // Indicates a flow was inspected by DPI. Applies only to Connection Closed messages.
  , DstNatPortNumber = dnpt
  , SrcNatPortNumber = snpt
  , sosBladeID = bid // Blade ID
  , sosUUID = uuid
  , sosFileName = FileName
  , DvcOriginalAction = fw_action
| extend
  ThreatName = coalesce(sosASWSignatureName, sosGAVSignatureName, sosIPSSignatureName, "")
  , ThreatId = coalesce(sosAppSignatureID, "")
  , ThreatCategory = coalesce(sosIPSCategoryName, sosAntiSpywareCategory, "")
  , DstNatPortNumber = toint(DstNatPortNumber)
  , SrcNatPortNumber = toint(SrcNatPortNumber)
| extend AdditionalFields = bag_pack(
  "AppRulePolicyId", sosAppRulePolicyId
  , "AppRulePolicyName", sosAppRulePolicyName
  , "AppRuleService", sosAppRuleService
  , "AppRuleType", sosAppRuleType
  , "AppRuleObject", sosAppRuleObject
  , "AppRuleObjectContent", sosAppRuleObjectContent
  , "AppRuleAction", sosAppRuleAction
  , "AppID", sosAppID
  , "AppCategoryID", sosAppCategoryID
  , "IPSCategoryName", sosIPSCategoryName
  , "AntiSpywareCategory", sosAntiSpywareCategory
  , "FileIdentifier", sosFileIdentifier
  , "DPIInspectedFlow", sosDPIInspectedFlow
  , "BladeID", sosBladeID
  , "UUID", sosUUID
  , "FileName", sosFileName
  , "FileSize", FileSize
  , "CaptureATPVerdict", sosCaptureATPVerdict
  , "CFSCategoryID", sosCFSCategoryID
  , "CFSCategoryName", sosCFSCategoryName
  , "CFSPolicyName", sosCFSPolicyName
  , "AppControlFileName", sosAppControlFileName
  , "IPSFullString", sosIPSFullString
  , "IPSSignatureName", sosIPSSignatureName
  , "LegacyMessageCategory", sosLegacyMessageCategory
  , "LogMsgCategory", sosLogMsgCategory
  , "LogMsgNote", sosLogMsgNote
  , "LogMsgSeverity", sosLogMsgSeverity
  , "SourceVPNPolicyName", sosSourceVPNPolicyName
  , "DestinationVPNPolicyName", sosDestinationVPNPolicyName
  , "EventMessageDetail", sosEventMessageDetail
  , "UserSessionType", sosUserSessionType
  )
| project-away
    DeviceEventCategory
  , gcat
  , RequestMethod
  , ipspri
  , spypri
  , sos*
  , RequestURL
  , Protocol
  , appName
  , AdditionalExtensions
  , Flex*
  , Indicator*
  , Malicious*
  , Field*
  , DeviceCustom*
  , Old*
  , File*
  , Source*
  , Destination*
  , Device*
  , SimplifiedDeviceAction
  , ExternalID
  , ExtID
  , TenantId
  , ProcessName
  , ProcessID
  , ExtID
  , OriginalLogSeverity
  , LogSeverity
  , EventOutcome
  , StartTime
  , EndTime
  , ReceiptTime
  , Remote*
  , ThreatDescription
  , ThreatSeverity
  , RequestContext
  , RequestCookies
  , CommunicationDirection
  , ReportReferenceLink
  , ReceivedBytes
  , SentBytes
  , _ResourceId
  , _ItemId
| project-reorder
    TimeGenerated
  , EventVendor
  , EventProduct
  , DvcDescription
  , Dvc
  , DvcOs
  , DvcOsVersion
};
Parser (disabled=disabled)
}



//
// Function Name: ASimNetworkSessionVectraAI
// Description: This ASIM parser supports normalizing Vectra AI Streams logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionVectraAI(    ['disabled']:bool=false,
    ['pack']:bool=false)
{
let parser = (disabled:bool=false, pack:bool=false) 
{
  let NetworkDirectionLookup = datatable(local_orig_b:bool, local_resp_b:bool, NetworkDirection:string)[
    false, true, 'Inbound',
    true, false, 'Outbound',
    true, true, 'Local',
    false, false, 'External'];
  let EventSubTypeLookup = datatable(conn_state_s:string, EventSubType:string)[
    "S1", 'Start',
    "SF", 'End'];
  let HostnameRegex = @'^[a-zA-Z0-9-]{1,61}$';
  VectraStream_CL
  | where metadata_type_s == 'metadata_isession'
  | project-away MG, ManagementGroupName, RawData, SourceSystem, TenantId
  | project-rename
      DstIpAddr = id_resp_h_s,
      DvcDescription = hostname_s,
      DstDescription = resp_hostname_s,
      SrcDescription = orig_hostname_s,
      // -- huid does not seem to be unique per device and not mapped for now
      // DstDvcId = resp_huid_s, 
      // SrcDvcId = orig_huid_s,
      DvcId = sensor_uid_s,
      // -- community id is just a hash of addresses and ports, and not unique for the session
      // NetworkSessionId = community_id_s,
      SrcIpAddr = id_orig_h_s,
      EventUid = _ItemId
  // -- the domain field may have invalid values. Most of them are IP addresses filtered out, but a small fraction are not filtered.
  | extend resp_domain_s = iff (ipv4_is_match(resp_domain_s, "0.0.0.0",0), "", resp_domain_s)
  | extend SplitRespDomain = split(resp_domain_s,".")
  | extend 
      DstDomain = tostring(strcat_array(array_slice(SplitRespDomain, 1, -1), '.')),
      DstFQDN = iif (array_length(SplitRespDomain) > 1, resp_domain_s, ''),
      DstDomainType = iif (array_length(SplitRespDomain) > 1, 'FQDN', '')
  | extend
      DstHostname = case (
          resp_domain_s != "", tostring(SplitRespDomain[0]),
          DstDescription startswith "IP-" or not(DstDescription matches regex HostnameRegex), "",
          DstDescription)
  | project-away SplitRespDomain
  | extend
      SrcHostname = iff (SrcDescription startswith "IP-" or not(SrcDescription matches regex HostnameRegex), "", SrcDescription),
      DvcHostname = iff (DvcDescription startswith "IP-" or not(DvcDescription matches regex HostnameRegex), "", DvcDescription),
      NetworkApplicationProtocol = toupper(service_s),
      NetworkProtocol = toupper(protoName_s),
      NetworkProtocolVersion = toupper(id_ip_ver_s),
      Dst = DstIpAddr,
      DstBytes = tolong(resp_ip_bytes_d),
      DstPackets = tolong(resp_pkts_d),
      DstPortNumber = toint(id_resp_p_d),
      DstVlanId = tostring(toint(resp_vlan_id_d)),
      EventCount = toint(1),
      EventEndTime = unixtime_milliseconds_todatetime(ts_d),
      EventOriginalSubType = tostring(split(metadata_type_s, '_')[1]),
      EventProduct = 'Vectra Stream',
      EventResult = 'Success',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.2',
      EventSeverity = 'Informational',
      EventStartTime = unixtime_milliseconds_todatetime(session_start_time_d),
      EventType = 'NetworkSession',
      EventVendor = 'Vectra AI',
      SrcBytes = tolong(orig_ip_bytes_d),
      SrcPackets = tolong(orig_pkts_d),
      SrcPortNumber = toint(id_orig_p_d),
      SrcVlanId = tostring(toint(orig_vlan_id_d)),
      // -- No ID mapped, since huid found not to be unique
      // SrcDvcIdType = 'VectraId',
      // DstDvcIdType = 'VectraId',
      DvcIdType = 'VectraId',
      NetworkDuration = toint(duration_d)
  | extend 
      Hostname = DstHostname,
      IpAddr = SrcIpAddr,
      // SessionId = NetworkSessionId,
      Src = SrcIpAddr,
      Dvc = DvcId,
      Duration = NetworkDuration,
      InnerVlanId = SrcVlanId,
      NetworkBytes = SrcBytes + DstBytes,
      NetworkPackets = SrcPackets + DstPackets,
      OuterVlanId = DstVlanId
  | lookup NetworkDirectionLookup on local_orig_b, local_resp_b
  | lookup EventSubTypeLookup on conn_state_s
  // -- preserving non-normalized important fields
  | extend AdditionalFields = iff (
      pack, 
      bag_pack (
        "first_orig_resp_data_pkt", first_orig_resp_data_pkt_s,
        "first_resp_orig_data_pkt", first_resp_orig_data_pkt_s,
        "orig_sluid", orig_sluid_s, 
        "resp_sluid", resp_sluid_s,
        "orig_huid", orig_huid_s,
        "resp_huid", resp_huid_s,
        "community_id", community_id_s,
        "resp_multihome", resp_multihomed_b,
        "host_multihomed", host_multihomed_b,
        "first_orig_resp_data_pkt_time", unixtime_milliseconds_todatetime(first_orig_resp_data_pkt_time_d),
        "first_orig_resp_pkt_time", unixtime_milliseconds_todatetime(first_orig_resp_pkt_time_d),
        "first_resp_orig_data_pkt_time", unixtime_milliseconds_todatetime(first_resp_orig_data_pkt_time_d),
        "first_resp_orig_pkt_time", unixtime_milliseconds_todatetime(first_resp_orig_pkt_time_d)
      ),
      dynamic([])
    )
  | project-away
      *_d, *_s, *_b, *_g, Computer
};
parser (disabled=disabled, pack=pack)
}



//
// Function Name: ASimNetworkSessionVMConnection
// Description: This ASIM parser supports normalizing VM connection logs collected using the Log Analytics agent to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionVMConnection(    ['disabled']:bool=false)
{
let SeverityLookup = datatable (EventOriginalSeverity: string, EventSeverity:string) [
  '', 'Informational', 
  '0', 'Informational',
  '1', 'Low',
  '2', 'Medium',
  '3', 'High'
];
let VMConnectionProjected = VMConnection | project-away AdditionalInformation, AgentId, TenantId, TLPLevel, SourceSystem, IsActive, *ReportedDateTime, LinksFailed, LinksLive, LinksTerminated, Description, Responses, ResponseTimeMin, ResponseTimeMax, RemoteClassification, RemoteDnsQuestions;
let outbound = (disabled:bool=false) {
  VMConnectionProjected
  | where not (disabled)
  | where Direction == "outbound"
  | extend
      SrcAppType = "Process",
      SrcDvcIdType = "VMConnectionId",
      SrcHostnameType = "Simple",
      DstGeoCountry = RemoteCountry,
      DstGeoLongitude = RemoteLongitude,
      DstGeoLatitude = RemoteLatitude,
      SrcAppId = Process,
      SrcAppName = ProcessName,
      SrcDvcId = Machine,
      ThreatField = iff (MaliciousIp != "", "DstIpAddr", "")
  | invoke _ASIM_ResolveSrcFQDN ("Computer")
  | extend FQDN = iff(RemoteDnsCanonicalNames == "", "", todynamic(RemoteDnsCanonicalNames)[0])
  | invoke _ASIM_ResolveDstFQDN("FQDN")
  | project-away Computer, RemoteDnsCanonicalNames
  | extend
      RemoteFQDN = DstFQDN,
      RemoteHostname = DstHostname,
      RemoteDomain = DstDomain,
      RemoteDomainType = DstDomainType,
      LocalFQDN = SrcFQDN,
      LocalHostname = SrcHostname,
      LocalDomain = SrcDomain,
      LocalDomainType = SrcDomainType,
      LocalIpAddr = SourceIp
};
let inbound = (disabled:bool=false) {
  VMConnectionProjected
  | where not (disabled)
  | where Direction == "inbound"
  | extend
      DstAppType = "Process",
      DstDvcIdType = "VMConnectionId",
      SrcGeoCountry = RemoteCountry,
      SrcGeoLongitude = RemoteLongitude,
      SrcGeoLatitude = RemoteLatitude,
      DstAppId = Process,
      DstAppName = ProcessName,
      DstDvcId = Machine,
      ThreatField = iff (MaliciousIp != "", "SrcIpAddr", "")
  | invoke _ASIM_ResolveDstFQDN ("Computer")
  | extend FQDN = iff(RemoteDnsCanonicalNames == "", "", todynamic(RemoteDnsCanonicalNames)[0])
  | invoke _ASIM_ResolveSrcFQDN("FQDN")
  | project-away Computer, RemoteDnsCanonicalNames
  | extend
      RemoteFQDN = SrcFQDN,
      RemoteHostname = SrcHostname,
      RemoteDomain = SrcDomain,
      RemoteDomainType = SrcDomainType,
      LocalFQDN = DstFQDN,
      LocalHostname = DstHostname,
      LocalDomain = DstDomain,
      LocalDomainType = DstDomainType,
      LocalIpAddr = DestinationIp
};
let parser=(disabled:bool=false){
  union outbound(disabled), inbound(disabled)
  // Event fields
  | extend 
    EventCount = toint(LinksEstablished), // -- prioritized over LinksLive and LinksTerminated
    EventStartTime = TimeGenerated,
    EventVendor = "Microsoft",
    EventProduct = "VMConnection",
    EventSchema = "NetworkSession",
    EventSchemaVersion = "0.2.2",
    EventType = "EndpointNetworkSession",
    DvcIdType = "VMConnectionId",
    NetworkDirection = iff(Direction=="inbound", "Inbound", "Outbound"),
    EventEndTime = TimeGenerated
  | project-rename
    DstIpAddr = DestinationIp,
    DstPortNumber = DestinationPort, 
    SrcIpAddr = SourceIp, 
    NetworkSessionId = ConnectionId,
    ThreatName = IndicatorThreatType,
    RemoteGeoCountry = RemoteCountry,
    RemoteGeoLatitude = RemoteLatitude, 
    RemoteGeoLongitude = RemoteLongitude,
    LocalAppId = Process,
    LocalAppName = ProcessName,
    DvcId = Machine,
    RemoteIpAddr = RemoteIp,
    EventReportUrl = ReportReferenceLink,
    ThreatIpAddr = MaliciousIp
  // -- Calculated fields
  | extend EventOriginalSeverity = tostring(Severity)
  | lookup SeverityLookup on EventOriginalSeverity
  | extend
    EventResult = "Success",
    LocalAppType = "Process",
    NetworkDuration = toint(ResponseTimeSum/LinksEstablished) ,
    ThreatRiskLevel = toint(Confidence),
    NetworkProtocol = toupper(Protocol),
    SrcBytes = tolong(BytesSent),
    DstBytes = tolong(BytesReceived)
  | project-away BytesSent, BytesReceived, Confidence, ResponseTimeSum, Protocol, Direction, Severity, LinksEstablished
  // -- Aliases
  | extend
    IpAddr = RemoteIpAddr,
    Src = SrcIpAddr,
    Local = LocalIpAddr,
    DvcIpAddr = LocalIpAddr,
    Dst = DstIpAddr,
    Remote = RemoteIpAddr,
    Dvc = LocalHostname,
    DvcHostname = LocalHostname,
    DvcDomain = LocalDomain,
    DvcDomainType = LocalDomainType,
    DvcFQDN = LocalFQDN,
    Hostname = RemoteHostname,
    Duration = NetworkDuration,
    SessionId = NetworkSessionId
};
parser (disabled)
}



//
// Function Name: ASimNetworkSessionVMwareCarbonBlackCloud
// Description: This ASIM parser supports normalizing VMware Carbon Black Cloud logs to the ASIM NetworkSession normalized schema. VMware Carbon Black Cloud events are captured through VMware Carbon Black Cloud data connector which ingests Carbon Black Audit, Notification and Event data into Microsoft Sentinel through the REST API.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionVMwareCarbonBlackCloud(    ['disabled']:bool=false)
{
let NetworkProtocolLookup = datatable (netconn_protocol_s: string, NetworkProtocol: string)
  [
  "PROTO_TCP", "TCP",
  "PROTO_UDP", "UDP"
  ];
  let DvcActionLookup = datatable (sensor_action_s: string, DvcAction: string)
      [
      "ACTION_ALLOW", "Allow",
      "ACTION_SUSPEND", "Drop",
      "ACTION_TERMINATE", "Drop",
      "ACTION_BREAK", "Drop",
      "ACTION_BLOCK", "Deny"
  ];
  let EventSeverityLookup = datatable (DvcAction: string, EventSeverity: string)
      [
      "Allow", "Informational",
      "Drop", "Low",
      "Deny", "Low"
  ];
  let ThreatConfidenceLookup = datatable (ThreatOriginalConfidence: string, ThreatConfidence: int)
      [
      "1", 10,
      "2", 20,
      "3", 30,
      "4", 40,
      "5", 50,
      "6", 60,
      "7", 70,
      "8", 80,
      "9", 90,
      "10", 100
  ];
  let parser=(disabled: bool=false) {
      let CarbonBlackEventsSchema = datatable ( 
      eventType_s: string,
      netconn_protocol_s: string,
      sensor_action_s: string,
      alert_id_g: string,
      device_name_s: string,
      action_s: string,
      createTime_s: string,
      netconn_domain_s: string,
      remote_ip_s: string,
      netconn_inbound_b: bool,
      process_guid_s: string,
      remote_port_d: real,
      local_port_d: real,
      process_pid_d: real,
      device_external_ip_s: string,
      local_ip_s: string,
      device_id_s: string,
      device_os_s: string,
      event_description_s: string,
      event_id_g: string,
      event_origin_s: string,
      process_path_s: string,
      process_username_s: string,
      org_key_s: string,
  )[];
      let CarbonBlackNotificationsSchema = datatable (
      type_s: string,
      threatInfo_incidentId_g: string,
      threatInfo_score_d: real,
      threatInfo_summary_s: string,
      threatInfo_time_d: real,
      threatInfo_threatCause_threatCategory_s: string,
      threatInfo_threatCause_causeEventId_g: string,
      ruleName_s: string,
      deviceInfo_deviceVersion_s: string,
      threatInfo_threatCause_originSourceType_s: string,
      threatInfo_threatCause_reputation_s: string,
      threatInfo_threatCause_reason_s: string,
      id_g: string,
      primary_event_id_g: string,
      threat_id_g: string
  )[];
      let alldata = union (CarbonBlackEventsSchema), (CarbonBlackEvents_CL)
          | where not(disabled)
          | where eventType_s == "endpoint.event.netconn"
          | lookup NetworkProtocolLookup on netconn_protocol_s
          | lookup DvcActionLookup on sensor_action_s
          | lookup EventSeverityLookup on DvcAction;
      let alldatawiththreat = alldata 
          | where isnotempty(alert_id_g)
          | join kind=leftouter(union (CarbonBlackNotifications_CL), (CarbonBlackNotificationsSchema)
              | where type_s == "THREAT"
              | project
                  threatInfo_incidentId_g,
                  threatInfo_score_d,
                  threatInfo_summary_s,
                  threatInfo_time_d,
                  threatInfo_threatCause_threatCategory_s,
                  threatInfo_threatCause_causeEventId_g,
                  ruleName_s,
                  deviceInfo_deviceVersion_s,
                  threatInfo_threatCause_originSourceType_s,
                  threatInfo_threatCause_reputation_s,
                  threatInfo_threatCause_reason_s)
              on $left.alert_id_g == $right.threatInfo_incidentId_g
          | join kind=leftouter(union (CarbonBlackNotifications_CL), (CarbonBlackNotificationsSchema)
              | where type_s == "CB_ANALYTICS"
              | project
                  id_g,
                  deviceInfo_deviceVersion_s,
                  threat_id_g,
                  threatInfo_score_d,
                  threatInfo_summary_s,
                  threatInfo_threatCause_reason_s)
              on $left.alert_id_g == $right.id_g
          | extend 
              ThreatCategory = threatInfo_threatCause_threatCategory_s,
              ThreatFirstReportedTime = unixtime_milliseconds_todatetime(threatInfo_time_d),
              RuleName = ruleName_s,
              AdditionalFields_threat = bag_pack(
                              "threatInfo_threatCause_reason",
                              coalesce(threatInfo_threatCause_reason_s, threatInfo_threatCause_reason_s1),
                              "threatInfo_threatCause_reputation",
                              threatInfo_threatCause_reputation_s,
                              "threatInfo_threatCause_originSourceType",
                              threatInfo_threatCause_originSourceType_s,
                              "threatInfo_summary",
                              coalesce(threatInfo_summary_s, threatInfo_summary_s1)
                          ),
              ThreatId = threat_id_g,
              ThreatOriginalConfidence = tostring(toint(coalesce(threatInfo_score_d, threatInfo_score_d1))),
              DvcOsVersion = coalesce(deviceInfo_deviceVersion_s, deviceInfo_deviceVersion_s1)
          | lookup ThreatConfidenceLookup on ThreatOriginalConfidence;
      let alldatawithoutthreat = alldata
          | where isempty(alert_id_g);
      union alldatawiththreat, alldatawithoutthreat
      | invoke _ASIM_ResolveDvcFQDN('device_name_s')
      | extend temp_action = tostring(split(action_s, "|")[0])
      | extend
          EventStartTime = todatetime(split(createTime_s, '+')[0]),
          SrcDomain = case(
                  netconn_domain_s == remote_ip_s or netconn_domain_s has ":" or netconn_domain_s !has ".",
                  "",
                  netconn_inbound_b,
                  netconn_domain_s,
                  ""
              ),
          AdditionalFields_Common = bag_pack(
                              "Process Guid",
                              process_guid_s
                          ),
          DstPortNumber = toint(remote_port_d),
          NetworkDirection = case(
                      temp_action == "ACTION_CONNECTION_LISTEN",
                      "Listen",
                      netconn_inbound_b == true,
                      "Inbound",
                      "Unknown"
                  ),
          SrcPortNumber = toint(local_port_d),
          SrcProcessId = tostring(toint(process_pid_d))
      | project-rename
          DstIpAddr = remote_ip_s,
          DvcIpAddr = device_external_ip_s,
          EventUid = _ItemId,
          SrcIpAddr = local_ip_s,
          DvcId = device_id_s,
          DvcOriginalAction = sensor_action_s,
          DvcOs = device_os_s,
          EventMessage = event_description_s,
          EventOriginalType = action_s,
          EventOriginalUid = event_id_g,
          EventOwner = event_origin_s,
          SrcProcessName = process_path_s,
          SrcUsername = process_username_s,
          DvcScopeId = org_key_s
      | extend
          EventCount = int(1),
          EventProduct = "Carbon Black Cloud",
          EventSchema = "NetworkSession",
          EventSchemaVersion = "0.2.6",
          EventType = "EndpointNetworkSession",
          EventVendor = "VMware",
          SrcHostname = SrcIpAddr,
          DstHostname = iff(NetworkDirection == "Inbound", coalesce(DvcHostname, DstIpAddr), DstIpAddr),
          EventResult = case(
                  temp_action == "ACTION_CONNECTION_CREATE_FAILED",
                  "Failure",
                  DvcOriginalAction == "ACTION_ALLOW" or isempty(DvcOriginalAction),
                  "Success",
                  "Failure"
              ),
          NetworkProtocolVersion = case(
                              DstIpAddr contains ".",
                              "IPv4",       
                              DstIpAddr contains ":",
                              "IPv6", 
                              ""
                          )
      | extend
          Dvc = coalesce(DvcFQDN, DvcId, DvcHostname, DvcIpAddr),
          EventEndTime = EventStartTime,
          Dst = coalesce(DstHostname, DstIpAddr),
          Src = coalesce(SrcHostname, SrcIpAddr),
          IpAddr = SrcIpAddr,
          SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
          SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
          SrcDomainType = iff(isnotempty(SrcDomain), "FQDN", ""),
          DvcIdType = iff(isnotempty(DvcId), "Other", ""),
          AdditionalFields = bag_merge(AdditionalFields_threat, AdditionalFields_Common),
          SrcAppName = SrcProcessName,
          SrcAppId = SrcProcessId,
          SrcAppType = "Process",
          Hostname = DstHostname
      | project-away
          *_d,
          *_s,
          *_g,
          *_b,
          temp_action,
          _ResourceId,
          Computer,
          MG,
          ManagementGroupName,
          RawData,
          SourceSystem,
          TenantId,
          AdditionalFields_*
  };
  parser(disabled = disabled)
}



//
// Function Name: ASimNetworkSessionWatchGuardFirewareOS
// Description: This ASIM parser supports normalizing WatchGuard Fireware OS logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionWatchGuardFirewareOS(    ['disabled']:bool=false)
{
let Parser=(disabled:bool=false){
  let EventLookup=datatable(DvcAction:string,EventResult:string,EventSeverity:string)
  [
      "Allow","Success","Informational"
      , "Deny","Failure","Low"
  ];
  let SyslogParser = (T:(SyslogMessage:string)) {
      T
      | parse-kv SyslogMessage as (geo_src:string
      , geo_dst:string
      , src_user:string
      , dst_user:string
      , duration:int
      , sent_bytes:long
      , rcvd_bytes:long
      , fqdn_src_match:string
      , fqdn_dst_match:string) with (pair_delimiter=' ', kv_delimiter='=', quote='"')
      | project-rename SrcGeoCountry = geo_src
      , DstGeoCountry = geo_dst
      , SrcUsername = src_user
      , DstUsername = dst_user
      , NetworkDuration = duration
      , SrcBytes = sent_bytes
      , DstBytes = rcvd_bytes
      , DstDomain = fqdn_dst_match
      , SrcDomain = fqdn_src_match
      | extend DvcAction = extract(@'" (Allow|Deny) ', 1, SyslogMessage)
      | lookup EventLookup on DvcAction
      | extend DstDomainType = iif(isnotempty(DstDomain),"FQDN","")
      | extend SrcDomainType = iif(isnotempty(SrcDomain),"FQDN","")
      | extend NetworkProtocol = extract(@" (tcp|udp|icmp|igmp) ", 1, SyslogMessage)
      | extend SrcUsernameType = case(isempty(SrcUsername), ""
        , countof(SrcUsername, "@") == 1, "UPN"
        , "Simple"
      )
      | extend DstUsernameType = case(isempty(DstUsername), ""
        , countof(DstUsername, "@") == 1, "UPN"
        , "Simple"
      )
      | parse SyslogMessage with * "repeated " EventCount:int " times" *
      | extend EventCount = iif(isnotempty(EventCount), EventCount, toint(1))
      | project-away SyslogMessage
  };
  let AllSyslog = 
  Syslog
  | where not(disabled)
  | where SyslogMessage has_any('msg_id="3000-0148"' 
      , 'msg_id="3000-0149"' 
      , 'msg_id="3000-0150"'
      , 'msg_id="3000-0151"'
      , 'msg_id="3000-0173"'
  ) and SyslogMessage !has 'msg="DNS Forwarding" '
  | project TimeGenerated, SyslogMessage, HostName
  ;
  let Parse1 = 
  AllSyslog
  | where SyslogMessage !has "icmp" and SyslogMessage !has "igmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} (tcp|udp) \d{2,5} \d{2,5} " SrcIpAddr " " DstIpAddr " " SrcPortNumber:int @" " DstPortNumber:int @" " *
  | invoke SyslogParser()
  ;
  let Parse2 = 
  AllSyslog
  | where SyslogMessage !has "icmp" and SyslogMessage !has "igmp" and SyslogMessage has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" (tcp|udp) " SrcIpAddr " " DstIpAddr " " SrcPortNumber:int @" " DstPortNumber:int @" " *
  | invoke SyslogParser()
  ;
  let Parse3 = 
  AllSyslog
  | where SyslogMessage has "icmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} icmp \d{2,5} \d{1,5} " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  ;
  let Parse4 = 
  AllSyslog
  | where SyslogMessage has "icmp" and SyslogMessage has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" icmp " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  ;
  let Parse5 = 
  AllSyslog
  | where SyslogMessage has "igmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} igmp \d{2,5} \d{1,5} " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  ;
  union isfuzzy=false Parse1, Parse2, Parse3, Parse4, Parse5
  | extend EventSchema = "NetworkSession"
      , EventSchemaVersion = "0.2.4"
      , EventVendor = "WatchGuard"
      , EventProduct = "Fireware"
      , EventType = "NetworkSession"
      , DvcHostname = HostName
      , NetworkProtocolVersion = case(DstIpAddr contains ".", "IPv4"
          , DstIpAddr contains ":", "IPv6"
          , "")
      , NetworkProtocol = toupper(NetworkProtocol)
      , NetworkDuration = toint(NetworkDuration * toint(1000))
      , NetworkBytes = SrcBytes + DstBytes
      , EventEndTime = TimeGenerated
      , EventStartTime = TimeGenerated
      , Src = SrcIpAddr
      , Dst = DstIpAddr
      , Duration = NetworkDuration
      , User = DstUsername
      , IpAddr = SrcIpAddr
  | project-rename Dvc = HostName
};
Parser (disabled)
}



//
// Function Name: ASimNetworkSessionZscalerZIA
// Description: This ASIM parser supports normalizing Zscaler ZIA proxy logs produced by the Microsoft Sentinel Zscaler connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionZscalerZIA(    ['disabled']:bool=false)
{
let ActionLookup = datatable (DvcOriginalAction: string, DvcAction:string) [
  // See https://help.zscaler.com/zia/firewall-insights-logs-filters
  'Allow','Allow',
  'Allow due to insufficient app data','Allow',
  'Block/Drop','Drop',
  'Block/ICMP','Drop ICMP',
  'Block/Reset', 'Reset',
  'IPS Drop', 'Drop',
  'IPS Reset', 'Reset',
  // Observed in real world events
  'Block ICMP', 'Drop ICMP',
  'Drop', 'Drop'
];
let parser=(disabled:bool=false){
CommonSecurityLog | where not(disabled)
| where DeviceVendor == "Zscaler"
| where DeviceProduct == "NSSFWlog"
// Event fields
| extend 
  EventStartTime=TimeGenerated, 
  EventVendor = "Zscaler", 
  EventProduct = "ZIA Firewall", 
  EventSchema = "NetworkSession", 
  EventSchemaVersion="0.2.1", 
  EventType = 'NetworkSession', 
  EventSeverity = 'Informational',
  EventEndTime=TimeGenerated 
| project-rename
  DvcOriginalAction = DeviceAction, 
  DvcHostname = Computer, 
  EventProductVersion = DeviceVersion, 
  NetworkProtocol = Protocol, 
  DstIpAddr = DestinationIP, 
  DstPortNumber = DestinationPort, 
  DstNatIpAddr = DestinationTranslatedAddress, 
  DstNatPortNumber = DestinationTranslatedPort,
  DstAppName = DeviceCustomString3, 
  NetworkApplicationProtocol = DeviceCustomString2, 
  SrcIpAddr = SourceIP, 
  SrcPortNumber = SourcePort, 
  SrcUsername = SourceUserName,
  SrcNatIpAddr= SourceTranslatedAddress, 
  SrcNatPortNumber = SourceTranslatedPort, 
  SrcUserDepartment = DeviceCustomString1,  // Not in standard schema
  SrcUserLocation = SourceUserPrivileges,  // Not in standard schema
  ThreatName = DeviceCustomString6, 
  ThreatCategory = DeviceCustomString5, 
  NetworkRuleName = Activity,
  EventOriginalSeverity = LogSeverity,
  EventMessage = Message
// -- Calculated fields
| lookup ActionLookup on DvcOriginalAction 
| extend
  // -- Adjustment to support both old and new CSL fields.
  EventCount=coalesce(
    toint(column_ifexists("FieldDeviceCustomNumber2", int(null))), 
    toint(column_ifexists("DeviceCustomNumber2",int(null)))
  ),
  NetworkDuration = coalesce(
    toint(column_ifexists("FieldDeviceCustomNumber1", int(null))),
    toint(column_ifexists("DeviceCustomNumber1",int(null)))
  ),
  ThreatCategory = iff(DeviceCustomString4 == "None", "", ThreatCategory),
  SrcUsername = iff (SrcUsername == SrcUserLocation, "", SrcUsername),
  DstBytes = tolong(ReceivedBytes), 
  SrcBytes = tolong(SentBytes)
// -- Enrichment
| extend
  EventResult = iff (DvcOriginalAction == "Allow", "Success", "Failure"),
  DstAppType = "Service", 
  SrcUsernameType = "UPN" 
// -- Aliases
| extend
  Dvc = DvcHostname,
  User = SrcUsername,
  IpAddr = SrcIpAddr,
  Src = SrcIpAddr,
  Dst = DstIpAddr,
  Rule = NetworkRuleName,
  Duration = NetworkDuration
| project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, ReceiptTime, ReceivedBytes, Remote*, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, EventOutcome, FieldDevice*, ExtID, Reason, ApplicationProtocol, ReportReferenceLink
};
parser (disabled)
}



//
// Function Name: imNetworkSession
// Description: This ASIM parser supports filtering and normalizing Network Session logs from all supported sources to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) imNetworkSession(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['pack']:bool=false)
{
let DisabledParsers=materialize(_GetWatchlist('ASimDisabledParsers') | where SearchKey in ('Any', 'ExcludevimNetworkSession') | extend SourceSpecificParser=column_ifexists('SourceSpecificParser','') | distinct SourceSpecificParser | where isnotempty(SourceSpecificParser));
let ASimBuiltInDisabled=toscalar('ExcludevimNetworkSession' in (DisabledParsers) or 'Any' in (DisabledParsers)); 
let NetworkSessionsGeneric=(
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null),
  srcipaddr_has_any_prefix:dynamic=dynamic([]),
  dstipaddr_has_any_prefix:dynamic=dynamic([]),
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null),
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]),
  eventresult:string='*',
  pack:bool=false)
{
union isfuzzy=true
  vimNetworkSessionEmpty
  , vimNetworkSessionLinuxSysmon                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionLinuxSysmon'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoft365Defender            (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoft365Defender'      in (DisabledParsers) ))
  , vimNetworkSessionMD4IoTAgent                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMD4IoTAgent'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftWindowsEventFirewall   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftWindowsEventFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftSecurityEventFirewall   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftSecurityEventFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionPaloAltoCEF                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionPaloAltoCEF'      in (DisabledParsers) ))
  , vimNetworkSessionVMConnection                    (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionVMConnection'      in (DisabledParsers) ))
  , vimNetworkSessionAWSVPC                          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAWSVPC'      in (DisabledParsers) ))
  , vimNetworkSessionAzureFirewall                   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAzureFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionAzureNSG                        (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAzureNSG'      in (DisabledParsers) ))
  , vimNetworkSessionVectraAI                        (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, pack=pack, disabled=(ASimBuiltInDisabled or ('ExcludevimNetworkSessionVectraAI' in (DisabledParsers) )))
  , vimNetworkSessionCiscoMeraki                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoMeraki'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoMerakiSyslog                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoMerakiSyslog'      in (DisabledParsers) ))
  , vimNetworkSessionAppGateSDP                      (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAppGateSDP'      in (DisabledParsers) ))
  , vimNetworkSessionFortinetFortiGate               (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionFortinetFortiGate'      in (DisabledParsers) ))
  , vimNetworkSessionCorelightZeek                   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCorelightZeek'      in (DisabledParsers) ))
  , vimNetworkSessionCheckPointFirewall              (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCheckPointFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionWatchGuardFirewareOS            (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionWatchGuardFirewareOS'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoASA                        (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoASA'      in (DisabledParsers) ))
  , vimNetworkSessionForcePointFirewall              (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionForcePointFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionNative                          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionNative'      in (DisabledParsers) ))
  , vimNetworkSessionSentinelOne                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionSentinelOne'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoMeraki                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoMeraki'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoISE                        (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoISE'      in (DisabledParsers) ))
  , vimNetworkSessionBarracudaWAF                    (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionBarracudaWAF'      in (DisabledParsers) ))
  , vimNetworkSessionBarracudaCEF                  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionBarracudaCEF'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoFirepower                  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoFirepower'      in (DisabledParsers) ))
  , vimNetworkSessionCrowdStrikeFalconHost           (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCrowdStrikeFalconHost'      in (DisabledParsers) ))
  , vimNetworkSessionVMwareCarbonBlackCloud          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionVMwareCarbonBlackCloud'      in (DisabledParsers) ))
  , vimNetworkSessionPaloAltoCortexDataLake          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionPaloAltoCortexDataLake'      in (DisabledParsers) ))
  , vimNetworkSessionSonicWallFirewall               (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionSonicWallFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftSysmon                 (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftSysmon'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftSysmonWindowsEvent     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftSysmonWindowsEvent'      in (DisabledParsers) ))
};
NetworkSessionsGeneric(starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, pack=pack)
}



//
// Function Name: vimNetworkSessionAppGateSDP
// Description: This ASIM parser supports filtering and normalizing AppGate SDP with event type 'ip-access' logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAppGateSDP(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null), 
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]), 
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false
) 
{
  let DirectionLookup = datatable (direction:string, NetworkDirection:string) 
  [
    'up', 'Inbound',
    'down', 'Outbound'
  ];
  let ActionLookup = datatable (DvcOriginalAction:string, DvcAction:string, EventSeverity:string, EventResult:string)
  [
    'allow', 'Allow', 'Informational', 'Success',
    'drop', 'Drop', 'Low', 'Failure',
    'reject', 'Deny', 'Low', 'Failure',
    'block', 'Deny', 'Low', 'Failure',
    'block_report', 'Deny', 'Low', 'Failure',
    'allow_report', 'Allow', 'Informational', 'Success'
  ];
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);    
  let ip_access_events = 
    Syslog
    | where (isnull(starttime) or TimeGenerated>=starttime) 
      and (isnull(endtime) or TimeGenerated<=endtime) 
      and not(disabled)
      and (array_length(hostname_has_any) == 0)
      and ProcessName in ("cz-sessiond", "cz-vpnd")
      and SyslogMessage has_all ("[AUDIT]",'"event_type":"ip_access"')
    | project TimeGenerated, SyslogMessage, Computer
  ;
  let tcpupd_success = 
    ip_access_events
    | where 
      SyslogMessage has '"rule_name"'
      and SyslogMessage has_any ('"protocol":"UDP"','"protocol":"TCP"') 
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any)) 
      and (isnull(dstportnumber) or SyslogMessage has (strcat('"destination_port":', tostring(dstportnumber)))) 
      and (eventresult=='*' or iff(eventresult=='Success', SyslogMessage has 'allow', SyslogMessage has_any('drop', 'reject','block')))
    | parse SyslogMessage with * '"action":"' DvcOriginalAction:string '",' * 
    | lookup ActionLookup on DvcOriginalAction
    | where 
      (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
      and (eventresult=='*' or EventResult == eventresult)
    | parse-where SyslogMessage with 
        *
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"destination_port":' DstPortNumber:int ',' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *          
        '"rule_name":"' NetworkRuleName:string '",' *  
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"source_port":' SrcNatPortNumber:int ',' * 
        '"version":' EventProductVersion:string '}' *
    ;
  let tcpupd_fail = 
    ip_access_events
    | where 
      SyslogMessage has'"drop-reason"'
      and SyslogMessage has_any ('"protocol":"UDP"','"protocol":"TCP"') 
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any)) 
      and (isnull(dstportnumber) or SyslogMessage has (strcat('"destination_port":', tostring(dstportnumber)))) 
      and (eventresult=='*' or iff(eventresult=='Success', SyslogMessage has 'allow', SyslogMessage has_any('drop', 'reject','block')))
    | parse SyslogMessage with * '"action":"' DvcOriginalAction:string '",' * 
    | lookup ActionLookup on DvcOriginalAction
    | where 
      (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
      and (eventresult=='*' or EventResult == eventresult)
    | parse-where SyslogMessage with 
        *
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"destination_port":' DstPortNumber:int ',' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"drop-reason":"' EventOriginalResultDetails:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"source_port":' SrcNatPortNumber:int ',' * 
        '"version":' EventProductVersion:string '}' *
      ;
  let icmp_success = 
    ip_access_events
    | where 
      SyslogMessage has '"ICMP"'
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any)) 
      and (isnull(dstportnumber)) 
      and (eventresult=='*' or iff(eventresult=='Success', SyslogMessage has 'allow', SyslogMessage has_any('drop', 'reject','block')))
    | parse SyslogMessage with * '"action":"' DvcOriginalAction:string '",' * 
    | lookup ActionLookup on DvcOriginalAction
    | where 
      (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
      and (eventresult=='*' or EventResult == eventresult)
    | parse-where SyslogMessage with 
        *
        '"action":"' DvcOriginalAction:string '",' * 
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"icmp_code":' NetworkIcmpSubCode:int ',' *
        '"icmp_type":' NetworkIcmpCode:int ',' *  
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *          
        '"rule_name":"' NetworkRuleName:string '",' *  
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"version":' EventProductVersion:string '}' *
    ;
  union  tcpupd_success, tcpupd_fail, icmp_success 
  | extend 
    temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
    temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | project-away temp*
  | where ASimMatchingIpAddr != "No match"
  | parse SyslogMessage with 
      *
      '"country_name":"' SrcGeoCountry:string '",' *
      '"lat":' SrcGeoLatitude:real ',' *        
      '"lon":' SrcGeoLongitude:real '}' *
  | parse SyslogMessage with 
       *
      '"city_name":"' SrcGeoCity:string '",' *
      '"region_name":"' SrcGeoRegion:string '",' *
  | extend 
      SrcDvcIdType = 'AppGateId',
      SrcUsernameType = 'UPN'
  // -- Event fields
  | project-rename 
      DvcHostname = Computer
  | extend 
      EventCount = int(1),
      EventEndTime = TimeGenerated,
      EventStartTime = TimeGenerated,
      EventSchema = 'NetworkSession',
      EventSchemaVersion = '0.2.3',
      EventVendor = 'AppGate',
      EventProduct = 'SDP',
      EventType = 'NetworkSession'
  | lookup DirectionLookup on direction
  // -- Aliases
  | extend 
      Src = SrcIpAddr,
      Dst = DstIpAddr,
      Dvc = DvcHostname,
      SessionId = NetworkSessionId,
      IpAddr = SrcIpAddr,
      Rule = NetworkRuleName,
  // -- Entity identifier explicit aliases
      SrcUserUpn = SrcUsername
  | project-away 
      SyslogMessage, direction
};
parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionAWSVPC
// Description: This ASIM parser supports normalizing and filtering AWS VPC logs produced by the Microsoft Sentinel AWS S3 connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAWSVPC(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ProtocolLookup = datatable(Protocol:int, NetworkProtocol:string) [
    0,"HOPOPT",
    1,"ICMP",
    2,"IGMP",
    3,"GGP",
    4,"IPv4",
    5,"ST",
    6,"TCP",
    7,"CBT",
    8,"EGP",
    9,"IGP",
    10,"BBN-RCC-MON",
    11,"NVP-II",
    12,"PUP",
    13,"ARGUS (deprecated)",
    14,"EMCON",
    15,"XNET",
    16,"CHAOS",
    17,"UDP",
    18,"MUX",
    19,"DCN-MEAS",
    20,"HMP",
    21,"PRM",
    22,"XNS-IDP",
    23,"TRUNK-1",
    24,"TRUNK-2",
    25,"LEAF-1",
    26,"LEAF-2",
    27,"RDP",
    28,"IRTP",
    29,"ISO-TP4",
    30,"NETBLT",
    31,"MFE-NSP",
    32,"MERIT-INP",
    33,"DCCP",
    34,"3PC",
    35,"IDPR",
    36,"XTP",
    37,"DDP",
    38,"IDPR-CMTP",
    39,"TP++",
    40,"IL",
    41,"IPv6",
    42,"SDRP",
    43,"IPv6-Route",
    44,"IPv6-Frag",
    45,"IDRP",
    46,"RSVP",
    47,"GRE",
    48,"DSR",
    49,"BNA",
    50,"ESP",
    51,"AH",
    52,"I-NLSP",
    53,"SWIPE (deprecated)",
    54,"NARP",
    55,"MOBILE",
    56,"TLSP",
    57,"SKIP",
    58,"IPv6-ICMP",
    59,"IPv6-NoNxt",
    60,"IPv6-Opts",
    61,"",
    62,"CFTP",
    63,"",
    64,"SAT-EXPAK",
    65,"KRYPTOLAN",
    66,"RVD",
    67,"IPPC",
    68,"",
    69,"SAT-MON",
    70,"VISA",
    71,"IPCV",
    72,"CPNX",
    73,"CPHB",
    74,"WSN",
    75,"PVP",
    76,"BR-SAT-MON",
    77,"SUN-ND",
    78,"WB-MON",
    79,"WB-EXPAK",
    80,"ISO-IP",
    81,"VMTP",
    82,"SECURE-VMTP",
    83,"VINES",
    84,"TTP",
    84,"IPTM",
    85,"NSFNET-IGP",
    86,"DGP",
    87,"TCF",
    88,"EIGRP",
    89,"OSPFIGP",
    90,"Sprite-RPC",
    91,"LARP",
    92,"MTP",
    93,"AX.25",
    94,"IPIP",
    95,"MICP (deprecated)",
    96,"SCC-SP",
    97,"ETHERIP",
    98,"ENCAP",
    99,"",
    100,"GMTP",
    101,"IFMP",
    102,"PNNI",
    103,"PIM",
    104,"ARIS",
    105,"SCPS",
    106,"QNX",
    107,"A/N",
    108,"IPComp",
    109,"SNP",
    110,"Compaq-Peer",
    111,"IPX-in-IP",
    112,"VRRP",
    113,"PGM",
    114,"",
    115,"L2TP",
    116,"DDX",
    117,"IATP",
    118,"STP",
    119,"SRP",
    120,"UTI",
    121,"SMP",
    122,"SM (deprecated)",
    123,"PTP",
    124,"ISIS over IPv4",
    125,"FIRE",
    126,"CRTP",
    127,"CRUDP",
    128,"SSCOPMCE",
    129,"IPLT",
    130,"SPS",
    131,"PIPE",
    132,"SCTP",
    133,"FC",
    134,"RSVP-E2E-IGNORE",
    135,"Mobility Header",
    136,"UDPLite",
    137,"MPLS-in-IP",
    138,"manet",
    139,"HIP",
    140,"Shim6",
    141,"WESP",
    142,"ROHC",
    143,"Ethernet",
    253,"",
    254,"",
    255,"Reserved"
  ];
  let DirectionLookup = datatable (FlowDirection:string, NetworkDirection:string)  [
    'ingress', 'Inbound',
    'egress', 'Outbound'
  ];
  let ActionLookup = datatable (Action:string, DvcAction:string)  [
    'ACCEPT', 'Allow',
    'REJECT', 'Deny'
  ];
  let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null), 
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false
      )
  {
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
  AWSVPCFlow 
  | where(isnull(starttime) or TimeGenerated >= starttime)
    and (isnull(endtime)   or TimeGenerated <= endtime)
  | where not(disabled)
  | where LogStatus == "OK"
  // -- Pre-filtering:
  | where
         (isnull(dstportnumber) or (DstPort == dstportnumber))
    and (array_length(hostname_has_any) == 0)
  | extend EventResult = iff (Action=="ACCEPT","Success","Failure")
  | where (eventresult == "*" or eventresult == EventResult) 
  | lookup ActionLookup on Action
  | where  (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
  | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcAddr,src_or_any)
         , temp_isDstMatch=has_any_ipv4_prefix(DstAddr,dst_or_any)
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | project-away temp_*
  | where ASimMatchingIpAddr != "No match"
  // -- End pre-filtering
  | extend
      EventVendor="AWS", 
      EventProduct="VPC",
      NetworkBytes = tolong(Bytes),
      NetworkPackets = tolong(Packets),
      EventProductVersion = tostring(Version),
      EventType="NetworkSession",
      EventCount=toint(1),
      EventSeverity = iff (Action=="ACCEPT","Informational","Low"),
      EventSchemaVersion="0.2.3",
      EventSchema="NetworkSession",
      SrcAppType = iff (PktSrcAwsService != "", "CloudService", ""),
      DstAppType = iff (PktDstAwsService != "", "CloudService", ""),
      DvcIdType = "AwsVpcId"
  | lookup ProtocolLookup on Protocol
  | lookup DirectionLookup on FlowDirection
  | project-rename
      DstIpAddr = DstAddr,  
      DstPortNumber = DstPort, 
      SrcNatIpAddr=PktSrcAddr, 
      DstNatIpAddr=PktDstAddr, 
      SrcPortNumber = SrcPort,  
      SrcIpAddr = SrcAddr, 
      EventEndTime = End, 
      DvcInboundInterface = InterfaceId,
      DvcSubscriptionId = AccountId,
      DvcId = VpcId,
      NetworkProtocolVersion = TrafficType,
      EventOriginalResultDetails = LogStatus,
      SrcAppName = PktSrcAwsService,
      DstAppName = PktDstAwsService
  // -- Aliases
  | extend
      IpAddr = SrcIpAddr,
      Src = SrcIpAddr,
      Dst = DstIpAddr,
      Dvc = DvcId,
      EventStartTime = TimeGenerated,
      DvcInterface = DvcInboundInterface
  | project-away Action, AzId, Bytes, FlowDirection, InstanceId, Packets, Protocol, Region, SourceSystem, SublocationId, SublocationType, SubnetId, TcpFlags, TenantId, TrafficPath, Version
  };
  parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix,dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionAzureFirewall
// Description: This ASIM parser supports filtering and normalizing Azure Firewall logs to the ASIM Network Session normalized schema. This parser is partially based on a work by [Koos Goossens](https://github.com/TheCloudScout).

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAzureFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null), 
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false)
{
    let ip_any=set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let AzureFirewallNetworkRuleLogs = 
        AzureDiagnostics
        | where (isnull(starttime) or TimeGenerated >= starttime) 
          and (isnull(endtime)   or TimeGenerated <= endtime) 
          and not(disabled)
        | where Category == "AzureFirewallNetworkRule"
        | where isnotempty(msg_s)
        | project msg_s, OperationName, SubscriptionId, ResourceId, TimeGenerated, Type, _ResourceId;
    let prefilter = (T: (msg_s:string, TimeGenerated:datetime, OperationName:string)) {
      T | where  
      //(isnull(starttime) or TimeGenerated >= starttime) 
       // and (isnull(endtime)   or TimeGenerated <= endtime) 
       (array_length(hostname_has_any) == 0)
       and (isnull(dstportnumber) or msg_s has (tostring(dstportnumber)))
       and (array_length(ip_any)==0 
          or has_any_ipv4_prefix(msg_s,ip_any)
        ) 
    };
    let AzureFirewallSessionLogs = 
        AzureFirewallNetworkRuleLogs
        | where OperationName in ("AzureFirewallNetworkRuleLog","AzureFirewallThreatIntelLog")
        // -- pre-filter
        | where (array_length(dvcaction) == 0) or (msg_s has_any (dvcaction))
        | where (eventresult == "*") or ((eventresult == "Success") and (msg_s has "Allow")) or ((eventresult == "Failure") and (msg_s has "Deny"))
        | invoke prefilter()
        // -- end pre-filter
        | parse-where
            msg_s with           NetworkProtocol:string 
            " request from "     SrcIpAddr:string
            ":"                  SrcPortNumber:int
            " to "               DstIpAddr:string
            ":"                  DstPortNumber:int
            ". Action: "         DvcAction:string
            "."                  *
        | project-away msg_s
        | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
               , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
         | extend ASimMatchingIpAddr = case(
              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" 
              , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
              , temp_isSrcMatch, "SrcIpAddr"
              , temp_isDstMatch, "DstIpAddr"
              , "No match"
           )
        | project-away temp_*
        | where ASimMatchingIpAddr != "No match"
        | extend NetworkIcmpCode = iff(NetworkProtocol startswith "ICMP", toint(extract ("type=(\\d+)",1,NetworkProtocol)), int(null))
        | extend NetworkIcmpType = iff(isnotnull(NetworkIcmpCode), _ASIM_LookupICMPType(NetworkIcmpCode), "")
        | extend NetworkProtocol = iff(NetworkProtocol startswith "ICMP", "ICMP", NetworkProtocol)
        | extend EventSeverity = case (
            OperationName  == "AzureFirewallThreatIntelLog", "Medium",
            DvcAction == "Deny", "Low",
            "Informational")
        | extend EventResult = iff(DvcAction == "Allow", "Success", "Failure")
        ;
    let AzureFirewallNATLogs = 
        AzureFirewallNetworkRuleLogs
        | where OperationName == "AzureFirewallNatRuleLog"
        // -- pre-filter
        | where (array_length(dvcaction) == 0) or ("Allow" in (dvcaction))
        | where eventresult in ("*", "Success")
        | invoke prefilter()
        // -- end pre-filter
        | parse-where
            msg_s with           NetworkProtocol:string 
            " request from "     SrcIpAddr:string
            ":"                  SrcPortNumber:int
            " to "               DstIpAddr:string
            ":"                  DstPortNumber:int
            " was DNAT'ed to "   DstNatIpAddr:string
            ":"                  DstNatPortNumber:int
        | project-away msg_s
        | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
               , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
         | extend ASimMatchingIpAddr = case(
              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" 
              , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
              , temp_isSrcMatch, "SrcIpAddr"
              , temp_isDstMatch, "DstIpAddr"
              , "No match"
           )
        | project-away temp_*
        | where ASimMatchingIpAddr != "No match"
        | extend EventSeverity = "Informational"
        | extend EventResult = "Success"
        | extend DvcAction = "Allow"
        ;
    union AzureFirewallSessionLogs, AzureFirewallNATLogs
    | where 
        (isnull(dstportnumber) or DstPortNumber ==dstportnumber)
    // -- end post-filtering
    | extend
        EventVendor="Microsoft",
        EventProduct="Azure Firewall",
        EventType="NetworkSession",
        EventCount=toint(1),
        EventSchemaVersion="0.2.3",
        EventSchema="NetworkSession",
        DvcIdType = "AzureResourceId"
    | project-rename
        DvcSubscriptionId = SubscriptionId,
        DvcId = ResourceId
    // -- Aliases
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Dvc = DvcId,
        EventStartTime = TimeGenerated,
        EventEndTime = TimeGenerated // ??
    | project-keep
        ASim*,
        Src*,
        Dst*,
        Event*,
        Dvc*,
        IpAddr,
        NetworkIcmpCode,
        NetworkIcmpType,
        NetworkProtocol,
        Type,
        _ResourceId,
        TimeGenerated
};
parser  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionAzureNSG
// Description: This ASIM parser supports normalizing and filtering Azure Azure Network Security Groups (NSG) flows to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAzureNSG(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let DvcActionLookup = datatable(FlowStatus_s:string, DvcAction:string, EventResult:string) [
    'A', 'Allow', 'Success',
    'D', 'Deny', 'Failure',
];
let NetworkDirectionLookup = datatable(FlowDirection_s:string, NetworkDirection:string, isOutBound:bool) [
    'I', 'Inbound', false,
    'O', 'Outbound', true
];
let NetworkProtocolLookup = datatable(L4Protocol_s:string, NetworkProtocol:string)[
    'T', 'TCP',
    'U', 'UDP'
];
let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null),
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false)
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let prefilter = (T:(TimeGenerated:datetime, SrcIP_s:string, SrcPublicIPs_s:string, DestIP_s:string, DestPublicIPs_s:string, DestPort_d:real, FlowStatus_s:string, VM1_s:string, VM2_s:string)) { 
    T
    | where
      (isnull(dstportnumber) or dstportnumber == toint(DestPort_d)) 
    | extend dataSrcIPs = strcat(SrcIP_s," ",SrcPublicIPs_s),
             dataDstIPs = strcat(DestIP_s," ",DestPublicIPs_s)
    | extend temp_isSrcMatch=has_any_ipv4_prefix(dataSrcIPs,src_or_any)
           , temp_isDstMatch=has_any_ipv4_prefix(dataDstIPs,dst_or_any)
    | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
        )
    | where ASimMatchingIpAddr != "No match"
    | extend temp_is_MatchSrcHostname = VM1_s has_any (hostname_has_any)
            , temp_is_MatchDstHostname = VM2_s has_any (hostname_has_any)
    | extend ASimMatchingHostname = case(array_length(hostname_has_any) == 0 ,"-",
                                temp_is_MatchSrcHostname and temp_is_MatchDstHostname, "Both",
                                temp_is_MatchSrcHostname, "SrcHostname",
                                temp_is_MatchDstHostname, "DstHostname",
                                "No match"
                              )
    | where ASimMatchingHostname != "No match"
    | project-away temp_*
    | lookup DvcActionLookup on FlowStatus_s
    | where array_length(dvcaction) == 0 or DvcAction in (dvcaction)
    | where (eventresult=='*' or EventResult == eventresult)
  }; // prefilter ends
  let AzureNetworkAnalytics = 
    AzureNetworkAnalytics_CL
    | where
     (isnull(starttime) or TimeGenerated >= starttime)
      and  (isnull(endtime) or TimeGenerated <= endtime)
    | where not(disabled) and isnotempty(FlowType_s)
    | lookup NetworkDirectionLookup on FlowDirection_s
  ;
  let AzureNetworkAnalyticsInbound =
    AzureNetworkAnalytics
    | where not(isOutBound)
    | invoke prefilter()
    | project-rename
        DstMacAddr = MACAddress_s
    | extend
        DstBytes = tolong(OutboundBytes_d), // -- size fields seem not to be populated for inbound
        DstPackets = tolong(OutboundPackets_d),
        SrcBytes = tolong(InboundBytes_d),
        SrcPackets = tolong(InboundPackets_d),
        SrcInterfaceName = tostring(split(NIC_s, '/')[1]),
        SrcGeoCountry = toupper(Country_s)
    | extend hostelements=split(VM2_s,'/')
    | extend 
        DstFQDN = strcat(hostelements[0], @"\", hostelements[1]),
        DstHostname = tostring(hostelements[1]),
        DstDomain = tostring(hostelements[0]),
        DstDomainType = "ResourceGroup"
    | extend Hostname = DstHostname
    | project-away hostelements, isOutBound
  ;  
  let AzureNetworkAnalyticsOutbound =
    AzureNetworkAnalytics
    | where isOutBound
    | invoke prefilter()
    | project-rename
        SrcMacAddr = MACAddress_s
    | extend
        SrcBytes   = tolong(OutboundBytes_d), 
        SrcPackets = tolong(OutboundPackets_d),
        DstBytes   = tolong(InboundBytes_d),
        DstPackets = tolong(InboundPackets_d),
        DstInterfaceName = tostring(split(NIC_s, '/')[1]),
        DstGeoCountry = toupper(Country_s)
    | extend hostelements=split(VM1_s,'/')
    | extend 
        SrcFQDN = strcat(hostelements[0], @"\", hostelements[1]),
        SrcHostname = tostring(hostelements[1]),
        SrcDomain = tostring(hostelements[0]),
        SrcDomainType = "ResourceGroup"
    | extend Hostname = SrcHostname
    | project-away hostelements, isOutBound
  ;
  union AzureNetworkAnalyticsInbound, AzureNetworkAnalyticsOutbound
  | project-rename
      Dvc = NSGList_s,
      DvcSubscriptionId = Subscription_g,
      EventEndTime = FlowEndTime_t,
      EventStartTime = FlowStartTime_t,
      NetworkApplicationProtocol = L7Protocol_s,
      NetworkRuleName = NSGRule_s,
      NetworkSessionId = ConnectionName_s,
      EventOriginalSubType = FlowType_s
  | extend
      DstPortNumber = toint(DestPort_d),
      EventProduct = 'NSGFlow',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.3',
      EventSeverity = 'Informational', //??
      EventType = 'Flow',
      EventVendor = 'Microsoft',
      EventCount = toint(AllowedInFlows_d+DeniedInFlows_d+AllowedOutFlows_d+DeniedOutFlows_d),
      NetworkDuration = toint((((EventEndTime - datetime(1970-01-01)) / 1s) - ((EventStartTime - datetime(1970-01-01)) / 1s )) * 1000),
      Rule = NetworkRuleName,
      SessionId = NetworkSessionId
  | extend 
      DstIpAddr = iff(isnotempty(DestIP_s),
                      DestIP_s,
                      split(DestPublicIPs_s, '|')[0]),
      Duration = NetworkDuration,
      NetworkBytes = tolong(DstBytes + SrcBytes),
      NetworkPackets = tolong(DstPackets + SrcPackets),
      SrcIpAddr = iff(isnotempty(SrcIP_s),
                      SrcIP_s,
                      split(SrcPublicIPs_s, '|')[0])
  | extend
      Dst = DstIpAddr,
      IpAddr = SrcIpAddr,
      Src = SrcIpAddr
  | lookup NetworkProtocolLookup on L4Protocol_s
  | project-keep
      Src*,
      Dst*,
      Event*,
      Dvc*,
      Network*,
      IpAddr,
      Hostname,
      Type,
      Duration,
      SessionId,
      _ResourceId,
      TimeGenerated,
      ASim*
  | project-away *_s
};
parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionBarracudaCEF
// Description: This ASIM parser supports normalizing Barracuda WAF logs ingested in 'CommonSecurityLog' table to the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionBarracudaCEF(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ProtocolLookup = datatable(
    Protocol_s: string,
    NetworkProtocol: string,
    NetworkProtocolVersion: string
)[
    "TCP", "TCP", "",
    "TCP/ip", "TCP", "",
    "UDP", "UDP", "",
    "UDP/ip", "UDP", "",
    "ICMP", "ICMP", "IPV4",
    "ICMPv6", "ICMP", "IPV6",
];
let SeverityLookup = datatable (severity: int, EventSeverity: string)
    [
    0, "High", 
    1, "High", 
    2, "High", 
    3, "Medium",
    4, "Low",
    5, "Low", 
    6, "Informational",
    7, "Informational" 
];
let EventResultLookup = datatable (
    ActionID_s: string,
    EventResult: string,
    DvcAction: string
)
    [
    "ALLOW", "Success", "Allow",
    "DENY", "Failure", "Deny"
];
let parser = (
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]),
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false){
let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
let BarracudaCEF = 
    CommonSecurityLog
    | where not(disabled) and DeviceVendor startswith "Barracuda" and (DeviceProduct == "WAF" or DeviceProduct == "WAAS")
    | where DeviceEventCategory == "NF"
    | where (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DestinationIP, dst_or_any)
    | extend ASimMatchingIpAddr = case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
        and (array_length(hostname_has_any) == 0 or DeviceName has_any (hostname_has_any))
    | where (isnull(dstportnumber) or (DestinationPort == dstportnumber))
    | lookup EventResultLookup on $left.DeviceAction == $right.ActionID_s
    | where (array_length(dvcaction) == 0 or DvcAction has_any(dvcaction))
    | where (eventresult == '*' or EventResult =~ eventresult)
    | extend 
        severity = toint(LogSeverity)
    | lookup SeverityLookup on severity
    | lookup ProtocolLookup on $left.Protocol == $right.Protocol_s
    | extend
        EventCount = toint(1),
        EventProduct = "WAF",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventVendor = "Barracuda"
    | extend
        Dvc = DeviceName,
        DstIpAddr = DestinationIP,
        SrcIpAddr = SourceIP,
        DvcHostname = DeviceName,
        DvcIpAddr = DestinationIP,                            
        DstPortNumber = toint(DestinationPort),
        SrcPortNumber = toint(SourcePort),
        EventProductVersion = DeviceVersion,
        EventUid = _ItemId,
        EventStartTime = iff(isnotempty(FlexNumber2), unixtime_milliseconds_todatetime(tolong(ReceiptTime)-tolong(FlexNumber2)), unixtime_milliseconds_todatetime(tolong(ReceiptTime)))
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst=DstIpAddr,
        EventEndTime = EventStartTime
    | project-away
        ThreatConfidence,
        CommunicationDirection,
        AdditionalExtensions,
        Device*,
        Source*,
        Destination*,
        Activity,
        LogSeverity,
        ApplicationProtocol,
        ProcessID,
        ExtID,
        Protocol,
        Reason,
        ReceiptTime,
        SimplifiedDeviceAction,
        OriginalLogSeverity,
        ProcessName,
        EndTime,
        ExternalID,
        File*,
        ReceivedBytes,
        Message,
        Old*,
        EventOutcome,
        Request*,
        StartTime,
        Field*,
        Flex*,
        Remote*,
        Malicious*,
        severity,
        ThreatSeverity,
        IndicatorThreatType,
        ThreatDescription,
        _ResourceId,
        SentBytes,
        ReportReferenceLink,
        Computer,
        temp_*,
        TenantId,CollectorHostName;
BarracudaCEF
};
parser(
    starttime=starttime, 
    endtime=endtime, 
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber,
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction,
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionBarracudaWAF
// Description: This ASIM parser supports normalizing Barracuda WAF logs ingested in 'barracuda_CL' tablet o the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionBarracudaWAF(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let barracudaSchema = datatable(
    UnitName_s: string,
    DeviceReceiptTime_s: string,
    ActionID_s: string,
    DestinationIP_s: string,
    SourceIP: string,
    host_s: string,
    HostIP_s: string,
    Severity_s: string,
    LogType_s: string,
    DestinationPort_d: real,
    SourcePort_d: real,
    Protocol_s: string,
    DeviceVersion_s: string,
    TimeTaken_d: real,
    _ResourceId: string,
    RawData: string,
    Message: string,
    Computer: string,
    MG: string,
    ManagementGroupName: string,
    TenantId: string,
    SourceSystem: string,
    TimeGenerated: datetime
)[];
let ProtocolLookup = datatable(
    Protocol_s: string,
    NetworkProtocol: string,
    NetworkProtocolVersion: string
)[
    "TCP", "TCP", "",
    "TCP/ip", "TCP", "",
    "UDP", "UDP", "",
    "UDP/ip", "UDP", "",
    "ICMP", "ICMP", "IPV4",
    "ICMPv6", "ICMP", "IPV6",
];
let SeverityLookup = datatable (severity: int, EventSeverity: string)
    [
    0, "High", 
    1, "High", 
    2, "High", 
    3, "Medium",
    4, "Low",
    5, "Low", 
    6, "Informational",
    7, "Informational" 
];
let EventResultLookup = datatable (
    ActionID_s: string,
    EventResult: string,
    DvcAction: string
)
    [
    "ALLOW", "Success", "Allow",
    "DENY", "Failure", "Deny"
];
let parser = (
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]),
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false){
let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
let BarracudaCustom =  union isfuzzy=true
        barracudaSchema,
        barracuda_CL
    | where not(disabled)
        and LogType_s == "NF"
    | where (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DestinationIP_s, dst_or_any)
    | extend ASimMatchingIpAddr = case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
        and (array_length(hostname_has_any) == 0 or host_s has_any (hostname_has_any))
    | where (isnull(dstportnumber) or (DestinationPort_d == dstportnumber))
    | lookup EventResultLookup on ActionID_s
    | where (array_length(dvcaction) == 0 or DvcAction has_any(dvcaction))
    | where (eventresult == '*' or EventResult =~ eventresult)
    | extend 
        severity = toint(Severity_s)
    | lookup SeverityLookup on severity
    | lookup ProtocolLookup on Protocol_s
    | extend
        EventCount = toint(1),
        EventProduct = "WAF",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventVendor = "Barracuda"
    | extend
        Dvc = UnitName_s,
        DstIpAddr = DestinationIP_s,
        SrcIpAddr = SourceIP,
        DvcHostname = host_s,
        DvcIpAddr = HostIP_s,                            
        DstPortNumber = toint(DestinationPort_d),
        SrcPortNumber = toint(SourcePort_d),
        EventProductVersion = DeviceVersion_s,
        EventUid = _ItemId,
        EventStartTime = iff(isnotempty(TimeTaken_d), unixtime_milliseconds_todatetime(tolong(DeviceReceiptTime_s)-tolong(TimeTaken_d)), unixtime_milliseconds_todatetime(tolong(DeviceReceiptTime_s)))
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        EventEndTime = EventStartTime
    | project-away
        *_d,
        *_s,
        _ResourceId,
        severity,
        RawData,
        Message,
        Computer,
        MG,
        ManagementGroupName,
        TenantId,
        SourceSystem,
        temp_SrcMatch,
        temp_DstMatch,
        SourceIP;
BarracudaCustom
};parser(
    starttime=starttime, 
    endtime=endtime, 
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber,
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction,
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionCheckPointFirewall
// Description: This ASIM parser supports normalizing Check Point VPN-1 & Firewall-1 logs coming from CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCheckPointFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ProtocolLookup=datatable(Protocol:string,NetworkProtocol:string)
    [
        "0","HOPOPT"
        , "1","ICMP"
        , "2","IGMP"
        , "3","GGP"
        , "4","IPv4"
        , "5","ST"
        , "6","TCP"
        , "7","CBT"
        , "8","EGP"
        , "9","IGP"
        , "10","BBN-RCC-MON"
        , "11","NVP-II"
        , "12","PUP"
        , "13","ARGUS (deprecated)"
        , "14","EMCON"
        , "15","XNET"
        , "16","CHAOS"
        , "17","UDP"
        , "18","MUX"
        , "19","DCN-MEAS"
        , "20","HMP"
        , "21","PRM"
        , "22","XNS-IDP"
        , "23","TRUNK-1"
        , "24","TRUNK-2"
        , "25","LEAF-1"
        , "26","LEAF-2"
        , "27","RDP"
        , "28","IRTP"
        , "29","ISO-TP4"
        , "30","NETBLT"
        , "31","MFE-NSP"
        , "32","MERIT-INP"
        , "33","DCCP"
        , "34","3PC"
        , "35","IDPR"
        , "36","XTP"
        , "37","DDP"
        , "38","IDPR-CMTP"
        , "39","TP++"
        , "40","IL"
        , "41","IPv6"
        , "42","SDRP"
        , "43","IPv6-Route"
        , "44","IPv6-Frag"
        , "45","IDRP"
        , "46","RSVP"
        , "47","GRE"
        , "48","DSR"
        , "49","BNA"
        , "50","ESP"
        , "51","AH"
        , "52","I-NLSP"
        , "53","SWIPE (deprecated)"
        , "54","NARP"
        , "55","MOBILE"
        , "56","TLSP"
        , "57","SKIP"
        , "58","IPv6-ICMP"
        , "59","IPv6-NoNxt"
        , "60","IPv6-Opts"
        , "61",""
        , "62","CFTP"
        , "63",""
        , "64","SAT-EXPAK"
        , "65","KRYPTOLAN"
        , "66","RVD"
        , "67","IPPC"
        , "68",""
        , "69","SAT-MON"
        , "70","VISA"
        , "71","IPCV"
        , "72","CPNX"
        , "73","CPHB"
        , "74","WSN"
        , "75","PVP"
        , "76","BR-SAT-MON"
        , "77","SUN-ND"
        , "78","WB-MON"
        , "79","WB-EXPAK"
        , "80","ISO-IP"
        , "81","VMTP"
        , "82","SECURE-VMTP"
        , "83","VINES"
        , "84","TTP"
        , "84","IPTM"
        , "85","NSFNET-IGP"
        , "86","DGP"
        , "87","TCF"
        , "88","EIGRP"
        , "89","OSPFIGP"
        , "90","Sprite-RPC"
        , "91","LARP"
        , "92","MTP"
        , "93","AX.25"
        , "94","IPIP"
        , "95","MICP (deprecated)"
        , "96","SCC-SP"
        , "97","ETHERIP"
        , "98","ENCAP"
        , "99",""
        , "100","GMTP"
        , "101","IFMP"
        , "102","PNNI"
        , "103","PIM"
        , "104","ARIS"
        , "105","SCPS"
        , "106","QNX"
        , "107","A/N"
        , "108","IPComp"
        , "109","SNP"
        , "110","Compaq-Peer"
        , "111","IPX-in-IP"
        , "112","VRRP"
        , "113","PGM"
        , "114",""
        , "115","L2TP"
        , "116","DDX"
        , "117","IATP"
        , "118","STP"
        , "119","SRP"
        , "120","UTI"
        , "121","SMP"
        , "122","SM (deprecated)"
        , "123","PTP"
        , "124","ISIS over IPv4"
        , "125","FIRE"
        , "126","CRTP"
        , "127","CRUDP"
        , "128","SSCOPMCE"
        , "129","IPLT"
        , "130","SPS"
        , "131","PIPE"
        , "132","SCTP"
        , "133","FC"
        , "134","RSVP-E2E-IGNORE"
        , "135","Mobility Header"
        , "136","UDPLite"
        , "137","MPLS-in-IP"
        , "138","manet"
        , "139","HIP"
        , "140","Shim6"
        , "141","WESP"
        , "142","ROHC"
        , "143","Ethernet"
        , "253",""
        , "254",""
        , "255","Reserved"];
    let DirectionLookup=datatable(conn_direction:string,NetworkDirection:string)
    [
        "Incoming","Inbound", 
        "Outgoing","Outbound", 
        "Internal","Local"];
    let ActionLookup=datatable(DeviceAction:string,DvcAction:string,EventResult:string,EventSeverity:string)
    [
        "Accept","Allow","Success","Informational",
        "Allow","Allow","Success","Informational",
        "Drop","Drop","Failure","Low",
        "Reject","Deny","Failure","Low",
        "Encrypt","Encrypt","Success","Informational",
        "Decrypt","Decrypt","Success","Informational",
        "Bypass","Allow","Success","Informational",
        "Block","Deny","Failure","Low",
        "","","NA","Informational"
     ];
      let NWParser=(
          starttime:datetime=datetime(null), 
          endtime:datetime=datetime(null),
          srcipaddr_has_any_prefix:dynamic=dynamic([]), 
          dstipaddr_has_any_prefix:dynamic=dynamic([]), 
          ipaddr_has_any_prefix:dynamic=dynamic([]),
          dstportnumber:int=int(null), 
          hostname_has_any:dynamic=dynamic([]), 
          dvcaction:dynamic=dynamic([]), 
          eventresult:string='*', 
          disabled:bool=false)
      {
      let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
      let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
      CommonSecurityLog
      | where not(disabled)
      | where
                      (isnull(starttime) or TimeGenerated >= starttime) 
                      and (isnull(endtime) or TimeGenerated <= endtime)
      | where 
                      array_length(hostname_has_any) == 0
      | where DeviceVendor=="Check Point" and DeviceProduct=="VPN-1 & FireWall-1"
      | where (isnull(dstportnumber) or (DestinationPort == dstportnumber))
      | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), 
               temp_isDstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
      | extend ASimMatchingIpAddr = case(
                          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                          (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                          temp_isSrcMatch, "SrcIpAddr",
                          temp_isDstMatch, "DstIpAddr",
                          "No match"
                      )
      | where ASimMatchingIpAddr != "No match"
      | lookup ActionLookup on DeviceAction
      | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
      | where ((eventresult == "*") or (EventResult == eventresult))
      | lookup ProtocolLookup on Protocol
      | extend 
              EventProduct = "Firewall",
              EventCount = toint(1),
              EventType = "NetworkSession",
              EventSchema = "NetworkSession",
              EventSchemaVersion = "0.2.4"
      | parse-kv AdditionalExtensions as (
                  rule_uid:string,
                  loguid:string,
                  origin:string,
                  originsicname:string,
                  inzone:string,
                  outzone:string,
                  conn_direction:string,
                  alert:string,
                  inspection_category:string,
                  inspection_item:string
              ) with (pair_delimiter=';', kv_delimiter='=')
      | extend
              ThreatCategory = coalesce(alert, inspection_category),
              NetworkRuleName = coalesce(DeviceCustomString2, rule_uid, Activity),
              EventStartTime = TimeGenerated
      | parse originsicname with "CN\\=" DvcHostname "," *
      | project-rename
              Dvc = origin,                
              EventOriginalUid = loguid,
              ThreatName = inspection_item,
              EventVendor = DeviceVendor,
              DstPortNumber = DestinationPort,
              DstIpAddr = DestinationIP,
              SrcPortNumber = SourcePort,
              SrcIpAddr = SourceIP,
              DstNatIpAddr = DestinationTranslatedAddress,
              DstNatPortNumber = DestinationTranslatedPort,
              SrcNatIpAddr = SourceTranslatedAddress,
              SrcNatPortNumber = SourceTranslatedPort,
              EventProductVersion = DeviceVersion,
              EventOriginalSeverity = LogSeverity,
              Rule = NetworkRuleName,
              DvcOriginalAction = DeviceAction,
              DstAppName = Activity,
              EventMessage = Message
      | lookup DirectionLookup on conn_direction
      | extend 
              EventEndTime = EventStartTime,
              IpAddr = SrcIpAddr,
              Dst = DstIpAddr,
              Src = SrcIpAddr,
              NetworkDirection = case(
                                  isnotempty(NetworkDirection), NetworkDirection,
                                  inzone == "Internal" and (outzone == "Internal" or outzone == "Local"), "Local",
                                  (inzone == "Internal" or inzone == "Local") and outzone == "External", "Outbound",
                                  inzone == "External" and (outzone == "Internal" or outzone == "Local"), "Inbound",
                                  CommunicationDirection == "0", "Inbound",
                                  CommunicationDirection == "1", "Outbound",
                                  ""
                                  ),
              EventSeverity = iif(isnotempty(ThreatCategory),"High",EventSeverity),
              NetworkIcmpType = coalesce(
                                      tostring(column_ifexists("FieldDeviceCustomNumber2", long(null))),
                                      tostring(column_ifexists("DeviceCustomNumber2",long(null)))
                                      ),
              NetworkIcmpCode = coalesce(
                                      toint(column_ifexists("FieldDeviceCustomNumber3", long(null))),
                                      toint(column_ifexists("DeviceCustomNumber3",long(null)))
                                      )
      | project-away ApplicationProtocol, AdditionalExtensions, CommunicationDirection, Computer, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, ReceivedBytes, Remote*, ReportReferenceLink, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, rule_uid, originsicname, inzone, outzone, alert, conn_direction, inspection_category, temp_isDstMatch, temp_isSrcMatch, ExtID, EventOutcome, FieldDevice*, Reason
    };
    NWParser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionCiscoASA
// Description: This ASIM parser supports normalizing commonly used Cisco ASA messages collected using the CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoASA(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventResultMapping = datatable (Reason:string, DvcAction:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string)  [
    'Conn-timeout', '', 'Success', 'Timeout', 'The connection ended when a flow is closed because of the expiration of its inactivity timer.',
    'Deny Terminate', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by application inspection.',
    'Failover primary closed', '', 'Success', 'Failover', 'The standby unit in a failover pair deleted a connection because of a message received from the active unit.',
    'FIN Timeout', '', 'Success', 'Timeout', 'Force termination after 10 minutes awaiting the last ACK or after half-closed timeout.',  
    'Flow closed by inspection', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by the inspection feature.',
    'Flow terminated by IPS', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by IPS.',
    'Flow reset by IPS', 'Reset', 'Failure', 'Terminated', 'Flow was reset by IPS.',     
    'Flow terminated by TCP Intercept', 'TCP Intercept', 'Failure', 'Terminated', 'Flow was terminated by TCP Intercept.',
    'Flow timed out', '', 'Success', 'Timeout', 'Flow has timed out.',
    'Flow timed out with reset', 'Reset', 'Failure', 'Timeout', 'Flow has timed out, but was reset.',
    'Free the flow created as result of packet injection', '', 'Success', 'Simulation', 'The connection was built because the packet tracer feature sent a simulated packet through the Secure Firewall ASA.',
    'Invalid SYN', '', 'Failure', 'Invalid TCP', 'The SYN packet was not valid.',
    'IPS fail-close', 'Deny', 'Failure', 'Terminated', 'Flow was terminated because the IPS card is down.',
    'No interfaces associated with zone', '', 'Failure', 'Routing issue', 'Flows were torn down after the "no nameif" or "no zone-member" leaves a zone with no interface members.',
    'No valid adjacency', 'Drop', 'Failure', 'Routing issue', 'This counter is incremented when the Secure Firewall ASA tried to obtain an adjacency and could not obtain the MAC address for the next hop. The packet is dropped.',
    'Pinhole Timeout', '', 'Failure', 'Timeout', 'The counter is incremented to report that the Secure Firewall ASA opened a secondary flow, but no packets passed through this flow within the timeout interval, and so it was removed. An example of a secondary flow is the FTP data channel that is created after successful negotiation on the FTP control channel.',
    'Probe maximum retries of retransmission exceeded', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the TCP packet exceeded maximum probe retries of retransmission.',
    'Probe maximum retransmission time elapsed', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the maximum probing time for TCP packet had elapsed.',
    'Probe received RST', '', 'Failure', 'Reset', 'The connection was torn down because probe connection received RST from server.',
    'Probe received FIN', '', 'Success', '', 'The connection was torn down because probe connection received FIN from server and complete FIN closure process was completed.',
    'Probe completed', '', 'Success', '', 'The probe connection was successful.', 
    'Route change', '', 'Success', '', 'When the Secure Firewall ASA adds a lower cost (better metric) route, packets arriving that match the new route cause their existing connection to be torn down after the user-configured timeout (floating-conn) value. Subsequent packets rebuild the connection out of the interface with the better metric. To prevent the addition of lower cost routes from affecting active flows, you can set the floating-conn configuration timeout value to 0:0:0.', 
    'SYN Control', '', 'Failure', 'Invalid TCP', 'A back channel initiation occurred from the wrong side.',
    'SYN Timeout', '', 'Failure', 'Timeout', 'Force termination after 30 seconds, awaiting three-way handshake completion.',
    'TCP bad retransmission', '', 'Success', 'Invalid TCP', 'The connection was terminated because of a bad TCP retransmission.',
    'TCP FINs', '', 'Success', '', 'A normal close-down sequence occurred.',
    'TCP Invalid SYN', '', 'Failure', 'Invalid TCP', 'Invalid TCP SYN packet.',              
    'TCP Reset-APPLIANCE', '', 'Failure', 'Reset', 'The flow is closed when a TCP reset is generated by the Secure Firewall ASA.',
    'TCP Reset-I', '', 'Failure', 'Reset', 'Reset was from the inside.',
    'TCP Reset-O', '', 'Failure', 'Reset', 'Reset was from the outside.',
    'TCP segment partial overlap', '', 'Failure', 'Invalid TCP', 'A partially overlapping segment was detected.',
    'TCP unexpected window size variation', '', 'Failure', 'Invalid TCP', 'A connection was terminated due to variation in the TCP window size.',  
    'Tunnel has been torn down', '', 'Failure', 'Invalid Tunnel', 'Flow was terminated because the tunnel is down.',
    'Unknown', 'Deny', 'Failure', 'Terminated', 'An authorization was denied by a URL filter.', 'Unauth Deny', '', 'Failure', 'Unknown', 'An unknown error has occurred.',               
    'Xlate Clear', '', '', '', 'A command line was removed.',
];
let ProtocolLookup=datatable(Protocol:string,NetworkProtocol:string)[
      "0","HOPOPT"
      , "1","ICMP"
      , "2","IGMP"
      , "3","GGP"
      , "4","IPv4"
      , "5","ST"
      , "6","TCP"
      , "7","CBT"
      , "8","EGP"
      , "9","IGP"
      , "10","BBN-RCC-MON"
      , "11","NVP-II"
      , "12","PUP"
      , "13","ARGUS (deprecated)"
      , "14","EMCON"
      , "15","XNET"
      , "16","CHAOS"
      , "17","UDP"
      , "18","MUX"
      , "19","DCN-MEAS"
      , "20","HMP"
      , "21","PRM"
      , "22","XNS-IDP"
      , "23","TRUNK-1"
      , "24","TRUNK-2"
      , "25","LEAF-1"
      , "26","LEAF-2"
      , "27","RDP"
      , "28","IRTP"
      , "29","ISO-TP4"
      , "30","NETBLT"
      , "31","MFE-NSP"
      , "32","MERIT-INP"
      , "33","DCCP"
      , "34","3PC"
      , "35","IDPR"
      , "36","XTP"
      , "37","DDP"
      , "38","IDPR-CMTP"
      , "39","TP++"
      , "40","IL"
      , "41","IPv6"
      , "42","SDRP"
      , "43","IPv6-Route"
      , "44","IPv6-Frag"
      , "45","IDRP"
      , "46","RSVP"
      , "47","GRE"
      , "48","DSR"
      , "49","BNA"
      , "50","ESP"
      , "51","AH"
      , "52","I-NLSP"
      , "53","SWIPE (deprecated)"
      , "54","NARP"
      , "55","MOBILE"
      , "56","TLSP"
      , "57","SKIP"
      , "58","IPv6-ICMP"
      , "59","IPv6-NoNxt"
      , "60","IPv6-Opts"
      , "61",""
      , "62","CFTP"
      , "63",""
      , "64","SAT-EXPAK"
      , "65","KRYPTOLAN"
      , "66","RVD"
      , "67","IPPC"
      , "68",""
      , "69","SAT-MON"
      , "70","VISA"
      , "71","IPCV"
      , "72","CPNX"
      , "73","CPHB"
      , "74","WSN"
      , "75","PVP"
      , "76","BR-SAT-MON"
      , "77","SUN-ND"
      , "78","WB-MON"
      , "79","WB-EXPAK"
      , "80","ISO-IP"
      , "81","VMTP"
      , "82","SECURE-VMTP"
      , "83","VINES"
      , "84","TTP"
      , "84","IPTM"
      , "85","NSFNET-IGP"
      , "86","DGP"
      , "87","TCF"
      , "88","EIGRP"
      , "89","OSPFIGP"
      , "90","Sprite-RPC"
      , "91","LARP"
      , "92","MTP"
      , "93","AX.25"
      , "94","IPIP"
      , "95","MICP (deprecated)"
      , "96","SCC-SP"
      , "97","ETHERIP"
      , "98","ENCAP"
      , "99",""
      , "100","GMTP"
      , "101","IFMP"
      , "102","PNNI"
      , "103","PIM"
      , "104","ARIS"
      , "105","SCPS"
      , "106","QNX"
      , "107","A/N"
      , "108","IPComp"
      , "109","SNP"
      , "110","Compaq-Peer"
      , "111","IPX-in-IP"
      , "112","VRRP"
      , "113","PGM"
      , "114",""
      , "115","L2TP"
      , "116","DDX"
      , "117","IATP"
      , "118","STP"
      , "119","SRP"
      , "120","UTI"
      , "121","SMP"
      , "122","SM (deprecated)"
      , "123","PTP"
      , "124","ISIS over IPv4"
      , "125","FIRE"
      , "126","CRTP"
      , "127","CRUDP"
      , "128","SSCOPMCE"
      , "129","IPLT"
      , "130","SPS"
      , "131","PIPE"
      , "132","SCTP"
      , "133","FC"
      , "134","RSVP-E2E-IGNORE"
      , "135","Mobility Header"
      , "136","UDPLite"
      , "137","MPLS-in-IP"
      , "138","manet"
      , "139","HIP"
      , "140","Shim6"
      , "141","WESP"
      , "142","ROHC"
      , "143","Ethernet"
      , "253",""
      , "254",""
      , "255","Reserved"
  ];
  let ActionResultLookup = datatable (DeviceEventClassID:string, DvcAction:string, EventResult:string)[
        "106001", "Deny", "Failure",
        "106002", "Deny", "Failure",
        "106006", "Deny", "Failure",
        "106007", "Deny", "Failure",
        "106010", "Deny", "Failure",
        "106012", "Deny", "Failure",
        "106013", "Drop", "Failure",
        "106014", "Deny", "Failure",
        "106015", "Deny", "Failure",
        "106016", "Deny", "Failure",
        "106017", "Deny", "Failure",
        "106018", "Deny", "Failure",
        "106020", "Deny", "Failure",
        "106021", "Deny", "Failure",
        "106022", "Deny", "Failure",
        "106023", "Deny", "Failure",
        "106100", "", "",
        "302013", "Allow", "Success",
        "302014", "", "", 
        "302015", "Allow", "Success",
        "302016", "Allow", "Success",
        "302020", "Allow", "Success",
        "302021", "Allow", "Success",
        "710002", "Allow", "Success",
        "710003", "Deny", "Failure",
        "710004", "Drop", "Failure",
        "710005", "Drop", "Failure",
  ];
  let NWParser = (
        starttime:datetime=datetime(null), 
        endtime:datetime=datetime(null),
        srcipaddr_has_any_prefix:dynamic=dynamic([]), 
        dstipaddr_has_any_prefix:dynamic=dynamic([]), 
        ipaddr_has_any_prefix:dynamic=dynamic([]),
        dstportnumber:int=int(null), 
        hostname_has_any:dynamic=dynamic([]), 
        dvcaction:dynamic=dynamic([]), 
        eventresult:string='*', 
        disabled:bool=false)
    { 
  let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let allLogs = CommonSecurityLog
            | where not(disabled)
            | where (isnull(starttime) or TimeGenerated >= starttime) and (isnull(endtime) or TimeGenerated <= endtime)
            | where DeviceVendor == "Cisco" and DeviceProduct == "ASA"
            | where DeviceEventClassID in ("106001","106006","106015","106016","106021","106022","106010","106014","106018","106023","302013","302015","302014","302016","302020","302021","710002","710003","710004","710005","106007","106017","106100","106002","106012","106013","106020")
            | lookup ActionResultLookup on DeviceEventClassID
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction) or DvcAction == "")
            | where ((eventresult == "*") or EventResult == eventresult or EventResult == "")
            | project DeviceVendor, DeviceProduct, DeviceEventClassID, LogSeverity, OriginalLogSeverity, Computer, CommunicationDirection, DestinationIP, DestinationPort, DeviceAddress, DeviceName, Message, Protocol, SourceIP, SourcePort, DeviceVersion, DeviceCustomString2, DvcAction, EventResult, TimeGenerated, DeviceAction;
  let parsedData = allLogs
            | where isnotempty(SourceIP)
            | where (isnull(dstportnumber) or (DestinationPort == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | project-rename NetworkRuleName = DeviceCustomString2,
                             SrcIpAddr = SourceIP,
                             SrcPortNumber = SourcePort,
                             DstIpAddr = DestinationIP, 
                             DstPortNumber = DestinationPort;
  let unparsedData = allLogs
            | where isempty(SourceIP)
            | where Message has tostring(dstportnumber)
                    and ((array_length(src_or_any) == 0 or has_any_ipv4_prefix(Message,src_or_any)) 
                        or (array_length(dst_or_any) == 0 or has_any_ipv4_prefix(Message,dst_or_any)))
            | project DeviceVendor, DeviceProduct, DeviceEventClassID, LogSeverity, OriginalLogSeverity, Computer, DeviceAddress, DeviceName, Message, DeviceVersion, Protocol, DvcAction, EventResult, TimeGenerated, DeviceAction;
  let all_106001_alike = parsedData
            | where DeviceEventClassID in ("106001", "106006", "106015", "106016", "106021", "106022") 
            | parse Message with * " interface " DstInterfaceName;
  let all_106010_alike = parsedData
            | where DeviceEventClassID in ("106010", "106014")
            | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")";
  let all_106018 = parsedData
            | where DeviceEventClassID == "106018"
            | parse Message with * " packet type " NetworkIcmpType " " * "list " NetworkRuleName " " *;
  let all_106023 = parsedData
            | where DeviceEventClassID == "106023" and not(Message has "protocol 41")
            | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * ' by access-group "' NetworkRuleName '" '  *
            | parse Message with * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")" *;
  let all_106023_unparsed = unparsedData
            | where DeviceEventClassID == "106023" and not(Message has "protocol 41")
            | parse Message with * ":" DeviceAction " " Protocol " src " SrcInterfaceName ":" SrcIpAddrAndPort "(" SrcUsername ") dst " DstInterfaceName ":" DstIpAddrAndPort " " NetworkIcmpInfo 'by access-group "' NetworkRuleName '" [' * "]"
            | parse NetworkIcmpInfo with "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ") "
            | extend SrcIpAddrAndPort = split(SrcIpAddrAndPort,"/"), DstIpAddrAndPort = split(DstIpAddrAndPort,"/")
            | extend SrcIpAddr = tostring(SrcIpAddrAndPort[0]),
                    SrcPortNumber = toint(SrcIpAddrAndPort[1]),
                    DstIpAddr = tostring(DstIpAddrAndPort[0]),
                    DstPortNumber = toint(DstIpAddrAndPort[1])
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | project-away SrcIpAddrAndPort, DstIpAddrAndPort, NetworkIcmpInfo;
  let all_106023_41 = unparsedData
            | where DeviceEventClassID == "106023" and Message has "protocol 41"
            | parse Message with * ":" DeviceAction " " ProtocolFromLog " src " SrcInterfaceName ":" SrcIpAddr " dst " DstInterfaceName ":" DstIpAddr ' by access-group ' NetworkRuleName ' '  *
            | parse Message with * "(type " NetworkIcmpType ", code " NetworkIcmpCode:int ")" *
            | extend Protocol = case(isnotempty(Protocol), Protocol,
                                    ProtocolFromLog endswith "41", "41",
                                    ""),
                    NetworkRuleName = trim_start(@"\s*",NetworkRuleName)
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | project-away ProtocolFromLog;
  let all_302013_302015_parsed = parsedData
            | where DeviceEventClassID in ("302013","302015")
            | parse Message with * ":" * " " * " " * " connection " NetworkSessionId " for " SrcInterfaceName ":" * "/" * " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" * "/" * " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
            | extend SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                    DstUsername = trim(@"\s?\(?\)?\s?", DstUsername),
                    SessionId = NetworkSessionId,
                    EventSubType = "Start";
  let all_302013_302015_unparsed = unparsedData
            | where DeviceEventClassID in ("302013","302015")
            | parse Message with * ":" DeviceAction " " NetworkDirection " " Protocol " connection " NetworkSessionId " for " SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | extend SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                    DstUsername = trim(@"\s?\(?\)?\s?", DstUsername),
                    NetworkDirection = case(NetworkDirection == "inbound", "Inbound",
                                                NetworkDirection == "outbound", "Outbound",
                                                ""),
                    SessionId = NetworkSessionId,
                    EventSubType = "Start"; 
  let all_302014_unparsed = unparsedData
            | where DeviceEventClassID == "302014"
            | project-away DvcAction, EventResult
            | parse Message with * ":" DeviceAction " " Protocol " connection " NetworkSessionId " for " SrcInfoString " to " DstInfoString " duration " NetworkDuration " bytes " NetworkBytes:long *
            // SrcInfoString is extracted from the Message and not the direct values of IP, Port, Interface and User because Username is optional here
            | parse kind=regex SrcInfoString with SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int @"\(?\s?" SrcUsername @"\)?\s?"
            // DstInfoString is extracted from the Message and not the direct values of IP, Port, Interface and User because Username is optional here
            | parse kind=regex DstInfoString with DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int @"\(?\s?" DstUsername @"\)?\s?"
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            // Remaining string can have multiple formats. Mapping of all of them is as follows:
            // 1. empty --> no mapping required, RemainingString will be empty                
            | parse Message with * " bytes " * " " RemainingString
            // 2. (domain\USER001) 3. TCP FINs from OUTSIDE (domain\USER001) 4. TCP FINs (domain\USER001) --> DstUsernameSimple will now contain the value of the Destination Username
            | parse RemainingString with ReasonString "(" DstUsernameSimple ")"
            // Now to cover case #3 and 5. TCP FINs from OUTSIDE, adding check for the word "from" 
            | extend ReasonString = case(RemainingString has "from" and RemainingString !has "(", RemainingString,
                                         ReasonString)
            // Finally extract the required Reason information from the string to be utilized later
            | parse ReasonString with Reason " from " *
            | extend Reason = case(isempty(Reason), ReasonString,
                                   Reason)
            | lookup EventResultMapping on Reason
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | extend 
                        SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                        DstUsername = case(isempty(DstUsername),DstUsernameSimple,
                                           trim(@"\s?\(?\)?\s?", DstUsername)),
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End",
                        EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
            | project-away DstUsernameSimple, *String, Reason;
  let all_302014_parsed = parsedData
            | where DeviceEventClassID == "302014"
            | project-away DvcAction, EventResult
            | parse Message with * " connection " NetworkSessionId " for " SrcInterfaceName ":" * " to " DstInterfaceName ":" * " duration " NetworkDuration " bytes " NetworkBytes:long *
            | parse Message with * " bytes " * " " ReasonString
            | parse ReasonString with Reason " from " *
            | extend Reason = case(isempty(Reason), ReasonString,
                                   Reason)
            | lookup EventResultMapping on Reason
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | extend 
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End",
                        EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
            | project-away Reason, ReasonString;
  let all_302016_parsed = parsedData
            | where DeviceEventClassID  == "302016"
            | parse Message with * " connection " NetworkSessionId " for " SrcInterfaceName ":" * " to " DstInterfaceName ":" * " duration " NetworkDuration " bytes " NetworkBytes:long *
            | extend NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                     SessionId = NetworkSessionId,
                     EventSubType = "End";
  let all_302016_unparsed = unparsedData
            | where DeviceEventClassID  == "302016"
            | parse Message with * ":" DeviceAction " " Protocol " connection " NetworkSessionId " for " SrcInfoString " to " DstInfoString " duration " NetworkDuration " bytes " NetworkBytes:long *
            | parse kind=regex SrcInfoString with SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int @"\(?\s?" SrcUsername @"\)?\s?"
            | parse kind=regex DstInfoString with DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int @"\(?\s?" DstUsername @"\)?\s?"
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match"
            | parse Message with * " bytes " * " (" DstUsernameSimple ")"
            | extend 
                        SrcUsername = trim(@"\s?\(?\)?\s?", SrcUsername),
                        DstUsername = case(isempty(DstUsername),DstUsernameSimple,
                                           trim(@"\s?\(?\)?\s?", DstUsername)),
                        NetworkDuration = toint(24 * 60 * totimespan(NetworkDuration) / time(1s)),
                        SessionId = NetworkSessionId,
                        EventSubType = "End"
            | project-away DstUsernameSimple, *InfoString;
  let all_302020_302021 = parsedData
            | where DeviceEventClassID in ("302020","302021")
            | parse Message with * "(" SrcUsername ")" *
            | parse Message with * "type " NetworkIcmpType " code " NetworkIcmpCode:int *
            | extend SrcUsernameType = iif(isnotempty(SrcUsername),"Windows",""),
                        EventSubType = case(DeviceEventClassID == "302020", "Start",
                                            "End");
  let all_7_series = parsedData
            | where DeviceEventClassID in ("710002","710003","710004","710005")
            | parse Message with * " to " DstInterfaceName ":" *;
  let all_106007 = parsedData
            | where DeviceEventClassID == "106007"
            | extend DstAppName = "DNS"
            | parse Message with * " due to " EventOriginalResultDetails;
  let all_106017 = parsedData
            | where DeviceEventClassID == "106017"
            | extend ThreatName = "Land Attack";
  let all_106100_parsed = parsedData
            | where DeviceEventClassID == "106100" and isnotempty(SrcIpAddr)
            | extend DvcAction = case(Message has "denied", "Deny",
                                      "Allow")
            | extend EventResult = case(DvcAction == "Deny", "Failure",
                                        "Success")
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | parse Message with * "access-list " * " " * " " * " " SrcInterfaceName "/" * ") -> " DstInterfaceName "/" * ") hit-cnt " EventCount:int *;
  let all_106100_unparsed = unparsedData
            | where DeviceEventClassID == "106100"
            | extend DvcAction = case(Message has "denied", "Deny",
                                      "Allow")
            | extend EventResult = case(DvcAction == "Deny", "Failure",
                                        "Success")
            | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
            | where ((eventresult == "*") or EventResult == eventresult)
            | parse Message with * "access-list " NetworkRuleName " " DeviceAction " " Protocol " " SrcInterfaceName "/" SrcIpAddr "(" SrcPortNumber:int ") -> " DstInterfaceName "/" DstIpAddr "(" DstPortNumber:int ") hit-cnt " EventCount:int * 
            | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
                            temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
                                            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                                            (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                                            temp_isSrcMatch, "SrcIpAddr",
                                            temp_isDstMatch, "DstIpAddr",
                                            "No match"
                                        )
            | where ASimMatchingIpAddr != "No match";
  let remainingLogs = parsedData
            | where DeviceEventClassID in ("106002", "106012", "106013", "106020");
  let networkaddressWatchlistData = materialize (_ASIM_GetWatchlistRaw("NetworkAddresses"));
  let internalInterface = networkaddressWatchlistData | where WatchlistItem.Tags has "Internal" | distinct tostring(WatchlistItem["Range Name"]);
  let externalInterface = networkaddressWatchlistData | where WatchlistItem.Tags has "External" | distinct tostring(WatchlistItem["Range Name"]);
  union isfuzzy=false all_106001_alike, all_106010_alike, all_106018, all_106023, all_106023_unparsed, all_106023_41,  all_302013_302015_unparsed, all_302013_302015_parsed, all_302014_parsed, all_302014_unparsed, all_302016_parsed, all_302016_unparsed, all_302020_302021, all_7_series, all_106007, all_106017, all_106100_parsed, all_106100_unparsed, remainingLogs
            | extend 
                    EventStartTime = TimeGenerated,
                    EventEndTime = TimeGenerated,
                    EventVendor = "Cisco",
                    EventProduct = "ASA",
                    EventCount = coalesce(EventCount,toint(1)),
                    EventType = "NetworkSession",
                    EventSchema = "NetworkSession",
                    EventSchemaVersion = "0.2.4",
                    SrcInterfaceName = tolower(SrcInterfaceName),
                    DstInterfaceName = tolower(SrcInterfaceName)
            | extend 
                    SrcUsernameType = case(isnotempty(SrcUsername) and SrcUsername has "@", "UPN",
                                           isnotempty(SrcUsername) and SrcUsername !has "@" and SrcUsername has "\\", "Windows",
                                           isnotempty(SrcUsername), "Simple",
                                           ""),
                    DstUsernameType = case(isnotempty(DstUsername) and DstUsername has "@", "UPN",
                                           isnotempty(DstUsername) and DstUsername !has "@" and DstUsername has "\\", "Windows",
                                           isnotempty(DstUsername), "Simple",
                                           "")
            | lookup ProtocolLookup on Protocol
            | project-rename 
                    EventProductVersion = DeviceVersion,
                    EventOriginalType = DeviceEventClassID,
                    EventOriginalSeverity = OriginalLogSeverity,
                    DvcOriginalAction = DeviceAction,
                    EventMessage = Message,
                    Dvc = Computer
            | extend
                    EventSeverity = iff(isempty(EventResult) or EventResult == "Success", "Informational", "Low"),
                    NetworkDirection = case(isnotempty(CommunicationDirection), CommunicationDirection,
                                SrcInterfaceName in (internalInterface) and DstInterfaceName in (internalInterface), "Local",
                                SrcInterfaceName in (externalInterface) and DstInterfaceName in (externalInterface), "External",
                                DstInterfaceName in (externalInterface), "Outbound",
                                SrcInterfaceName in (externalInterface), "Inbound",
                                ""),
                    NetworkProtocol = case(isempty(NetworkProtocol) and isnotempty(Protocol), toupper(Protocol),
                                            NetworkProtocol)
            | extend 
                    Src = SrcIpAddr,
                    Dst = DstIpAddr,
                    Duration = NetworkDuration,
                    IpAddr = SrcIpAddr,
                    Rule = NetworkRuleName,
                    User = DstUsername
            | project-away CommunicationDirection, LogSeverity, Protocol, temp_*, Device*
            };
  NWParser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionCiscoFirepower
// Description: This ASIM parser supports normalizing commonly used Cisco Firepower messages collected using the CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoFirepower(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ActionLookup = datatable(
    DeviceAction: string,
    DvcAction: string,
    EventResult: string
)
[
    "Blocked", "Deny", "Failure",
    "Alerted", "Allow", "Success",
    "Rewritten", "Allow", "Success",
    "Would be Rewritten", "Allow", "Partial",
    "Would be Blocked", "Deny", "Partial",
    "Would Be Blocked", "Deny", "Partial",
    "Dropped", "Drop", "Failure",
    "Would be Dropped", "Drop", "Partial",
    "Partially Dropped", "Drop", "Partial",
    "Would be Block", "Deny", "Partial",
    "Partial Blocked", "Deny", "Partial",
    "Rejected", "Deny", "Failure",
    "Would be Rejected", "Deny", "Partial",
    "Would Rejected", "Deny", "Partial",
    "Block", "Deny", "Failure",
    "Partial Block", "Deny", "Partial",
    "Drop", "Drop", "Failure",
    "Would Drop", "Drop", "Partial",
    "Reject", "Deny", "Failure",
    "Rewrite", "Allow", "Success",
    "Allow", "Allow", "Success",
    "Monitor", "Allow", "Success"
];
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
[
      "0", "Low",
      "1", "Low",
      "2", "Low",
      "3", "Low",
      "4", "Medium",
      "5", "Medium",
      "6", "Medium",
      "7", "High",
      "8", "High",
      "9", "High",
      "10", "High"
];
let EventResultDetailsLookup = datatable(Reason: string, EventResultDetails: string)
[
    "N/A", "NA",
    "IP Block", "Terminated",
    "IP Monitor", "Unknown",
    "User Bypass", "Unknown",
    "File Monitor", "Unknown",
    "File Block", "Terminated",
    "Intrusion Monitor", "Unknown",
    "Intrusion Block", "Terminated",
    "File Resume Block", "Terminated",
    "File Resume Allow", "Unknown",
    "File Custom Detection", "Unknown"
];
let parser = (starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]), 
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]), 
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let AllLogs = CommonSecurityLog
        | where not(disabled)
        | where (isnull(starttime) or TimeGenerated >= starttime) and (isnull(endtime) or TimeGenerated <= endtime)
            and DeviceVendor == "Cisco" and DeviceProduct == "Firepower"
            and DeviceEventClassID has_any("INTRUSION:400", "PV:112", "RNA:1003:1")
            and (array_length(hostname_has_any) == 0 or DestinationDnsDomain has_any (hostname_has_any)) 
            and (isnull(dstportnumber) or (DestinationPort == dstportnumber))
        | extend
            temp_isSrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any), 
            temp_isDstMatch = has_any_ipv4_prefix(DestinationIP, dst_or_any)
        | extend ASimMatchingIpAddr = case(
                                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", 
                                                (temp_isSrcMatch and temp_isDstMatch), "Both", 
                                                temp_isSrcMatch, "SrcIpAddr",
                                                temp_isDstMatch, "DstIpAddr",
                                                "No match" 
                                                )        
            | where ASimMatchingIpAddr != "No match"
        | invoke _ASIM_ResolveDstFQDN('DestinationDnsDomain')
        | extend temp_is_MatchDstHostname = DstHostname has_any (hostname_has_any)
        | extend ASimMatchingHostname = case(
                                    array_length(hostname_has_any) == 0,
                                    "-",
                                    temp_is_MatchDstHostname,
                                    "DstHostname",
                                    "No match"
                                )
        | where ASimMatchingHostname != "No match"
        | invoke _ASIM_ResolveNetworkProtocol('Protocol')
        | extend NetworkProtocol = iff(NetworkProtocol == "Unassigned" and Protocol !in (63, 68, 99, 114, 253, 254), Protocol, NetworkProtocol);
    let Connection_Statistics_Events = AllLogs
        | where DeviceEventClassID has "RNA:1003:1"
        | parse-kv AdditionalExtensions as (
            start: long,
            end: long,
            bytesIn: long,
            bytesOut: long,
            )
            with (pair_delimiter=';', kv_delimiter='=') 
        | lookup EventResultDetailsLookup on Reason
        | extend
            SrcBytes = bytesIn,
            DstBytes = bytesOut,
            EventOriginalResultDetails = Reason,
            AdditionalFields = bag_pack("policy", DeviceCustomString1,
                                                "instanceID", ProcessID,
                                                "clientApplicationID", RequestClientApplication,
                                                "clientUrl", RequestURL);
    let Intrusion_Events = AllLogs
        | where DeviceEventClassID has "INTRUSION:400"
        | parse-kv AdditionalExtensions as (
            start: long
            )
            with (pair_delimiter=';', kv_delimiter='=')
        | extend 
            EventMessage = Activity,
            ThreatCategory = DeviceEventCategory,
            AdditionalFields = bag_pack("policy", DeviceCustomString1,
                                                "ipspolicy", DeviceCustomString5,
                                                "clientApplicationID", RequestClientApplication,
                                                "clientUrl", RequestURL);
    let Policy_Violation_Events = AllLogs
        | where DeviceEventClassID has "PV:112"
        | extend
            EventMessage = Message,
            AdditionalFields = bag_pack("policy", DeviceCustomString1)
        | project-rename DstUsername = DestinationUserName
        | extend
            DstUsernameType = _ASIM_GetUsernameType(DstUsername),
            DstUserType = _ASIM_GetUserType(DstUsername, "");
    union Connection_Statistics_Events, Intrusion_Events, Policy_Violation_Events
    | extend
        SrcPortNumber = iff(NetworkProtocol == "ICMP", int(null), SourcePort),
        DstPortNumber = iff(NetworkProtocol == "ICMP", int(null), DestinationPort),
        NetworkIcmpCode = iff(NetworkProtocol == "ICMP", DestinationPort, int(null)),
        NetworkIcmpType = iff(NetworkProtocol == "ICMP", tostring(SourcePort), ""),
        SrcZone = DeviceCustomString3,
        DstZone = DeviceCustomString4
    | lookup ActionLookup on DeviceAction
    | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
    | where ((eventresult == "*") or EventResult == eventresult)
    | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
    | lookup EventSeverityLookup on LogSeverity
    | extend 
        EventStartTime = coalesce(unixtime_milliseconds_todatetime(start), unixtime_milliseconds_todatetime(tolong(ReceiptTime))),
        SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
        DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
        EventOriginalType = iff(DeviceEventClassID has "INTRUSION:400", "INTRUSION EVENT", Activity),
        SrcVlanId = tostring(DeviceCustomNumber1)
    | extend
        EventEndTime = coalesce(unixtime_milliseconds_todatetime(end), EventStartTime),
        NetworkProtocolVersion = case(
                            DstIpAddr contains ".",
                            "IPv4",
                            DstIpAddr contains ":",
                            "IPv6",
                            ""
                        )
    | extend Ip_device = iff(DeviceName matches regex "(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))", DeviceName, "")
    | extend
        DvcIpAddr = Ip_device,
        DeviceName = iff(isempty(Ip_device), DeviceName, "")
    | extend host = coalesce(DeviceName, Computer)
    | invoke _ASIM_ResolveDvcFQDN('host')
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventCount = int(1)
    | project-rename 
        EventProduct = DeviceProduct,
        EventVendor = DeviceVendor,
        SrcUsername = SourceUserName,
        DvcInboundInterface = DeviceInboundInterface,
        DvcOutboundInterface = DeviceOutboundInterface,
        EventOriginalSeverity = LogSeverity,
        DvcId = DeviceExternalID,
        NetworkApplicationProtocol = ApplicationProtocol,
        EventProductVersion = DeviceVersion,
        EventOriginalUid = ExtID,
        NetworkRuleName = DeviceCustomString2,
        EventUid = _ItemId,
        DvcOriginalAction = DeviceAction
    | extend
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
        DvcIdType = "Other"
    | extend 
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Dvc = coalesce(DvcIpAddr, DvcHostname),
        Rule = NetworkRuleName,
        User = SrcUsername,
        Hostname = DstHostname
    | project-away
        bytesIn,
        bytesOut,
        start,
        end,
        CommunicationDirection,
        AdditionalExtensions,
        Device*,
        Source*,
        Destination*,
        Activity,
        ProcessID,
        Protocol,
        Reason,
        ReceiptTime,
        SimplifiedDeviceAction,
        OriginalLogSeverity,
        ProcessName,
        EndTime,
        ExternalID,
        File*,
        ReceivedBytes,
        Message,
        Old*,
        EventOutcome,
        Request*,
        StartTime,
        Field*,
        Flex*,
        Remote*,
        Malicious*,
        ThreatConfidence,
        ThreatSeverity,
        IndicatorThreatType,
        ThreatDescription,
        _ResourceId,
        SentBytes,
        ReportReferenceLink,
        Computer,
        TenantId,
        Ip_*,
        host,
        NetworkProtocolNumber,
        temp*
};
parser(
    starttime=starttime, 
    endtime=endtime,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber, 
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction, 
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionCiscoISE
// Description: This ASIM parser supports normalizing Cisco ISE Events produced by the Microsoft Sentinel Cisco ISE connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoISE(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventFieldsLookup=datatable(
EventOriginalType: string,
EventResult: string,
DvcAction: string,
EventResultDetails: string,
EventSubType: string,
EventOriginalSeverity: string,
EventSeverity: string,
EventMessage: string,
EventOriginalResultDetails: string
)[
"25023", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAP connect to domain controller succeeded", "LDAP connect to domain controller succeeded",
"25024", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "LDAP connect to domain controller failed", "LDAP connect to domain controller failed",
"25025", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAP connect to global catalog succeeded", "LDAP connect to domain controller succeeded",
"25026", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "LDAP connect to global catalog failed", "LDAP connect to domain controller failed",
"25027", "Success", "Allow", "", "Start", "INFO", "Informational", "RPC connect to domain controller succeeded", "RPC connect to domain controller succeeded",
"25028", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "RPC connect to domain controller failed", "RPC connect to domain controller failed",
"25029", "Success", "Allow", "", "Start", "INFO", "Informational", "KDC connect to domain controller succeeded", "KDC connect to domain controller succeeded",
"25030", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "KDC connect to domain controller failed", "KDC connect to domain controller failed",
"25101", "Success", "Allow", "", "Start", "DEBUG", "Informational", "Successfully connected to external REST ID store server", "ISE successfully connect to external REST ID store server",
"25102", "Failure", "Drop", "Terminated", "End", "DEBUG", "Low", "Connection to external REST database failed", "ISE failed to establish a new connection to external REST database",
"60188", "Failure", "Drop", "Terminated", "End", "INFO", "Low", "An attempted SSH connection has failed", "An attempted SSH connection has failed",
"60234", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "The SXP connection has been disconnected", "The SXP connection has been disconnected",
"60235", "Success", "Allow", "", "Start", "INFO", "Informational", "SXP connection succeeded", "SXP connection succeeded",
"60236", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "SXP connection failed", "SXP connection failed",
"61010", "Success", "Allow", "", "Start", "INFO", "Informational", "ISE has established connection to APIC", "ISE has established connection to APIC",
"61011", "Success", "Allow", "", "End", "INFO", "Informational", "ISE was disconnected from APIC", "ISE was disconnected from APIC",
"61025", "Success", "Allow", "", "Start", "INFO", "Informational", "Open secure connection with TLS peer", "Secure connection established with TLS peer",
"61026", "Success", "Allow", "", "End", "INFO", "Informational", "Shutdown secure connection with TLS peer", "Secure connection with TLS peer shutdown",
"60509", "Failure", "Deny", "Maximum Retry", "End", "ERROR", "Low", "ERS request was denied as maximum possible connection was exceeded", "ERS request was denied as maximum possible connection was exceeded",
"61231", "Failure", "Drop", "Routing issue", "End", "WARN", "Low", "Kafka connection to ACI error while receiving message", "Kafka connection to ACI error while receiving message",
"61232", "Failure", "Drop", "Routing issue", "End", "WARN", "Low", "Kafka connection to ACI error while sending message", "Kafka connection to ACI error while sending message",
"89003", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "Failed to connect to MDM server", "Failed to connect to MDM server",
"24000", "Success", "Allow", "", "Start", "INFO", "Informational", "Connection established with LDAP server", "Connection established with LDAP server",
"24001", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Cannot establish connection with LDAP server", "Cannot establish connection with LDAP server",
"24019", "Failure", "Drop", "Unknown", "End", "ERROR", "Low", "LDAP connection error was encountered", "ISE cannot connect to LDAP external ID store",
"24030", "Failure", "Drop", "Unknown", "End", "ERROR", "Low", "SSL connection error was encountered", "SSL connection error was encountered",
"24400", "Success", "Allow", "", "Start", "INFO", "Informational", "Connection to ISE Active Directory agent established successfully", "Connection to ISE Active Directory agent established successfully",
"24401", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Could not establish connection with ISE Active Directory agent", "Could not establish connection with ISE Active Directory agent",
"24428", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Connection related error has occurred in either LRPC, LDAP or KERBEROS", "This RPC connection problem may be because the stub received incorrect data",
"24429", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Could not establish connection with Active Directory", "Could not establish connection with Active Directory",
"24850", "Success", "Allow", "", "Start", "DEBUG", "Informational", "Successfully connected to external ODBC database", "ISE successfully established a new connection to external ODBC database",
"24851", "Failure", "Drop", "Terminated", "End", "DEBUG", "Low", "Connection to external ODBC database failed", "ISE failed to establish a new connection to external ODBC database",
"34120", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Profiler failed to get the connection to NAC Manager", "Profiler sends a notification event to NAC Manager, but the notification fails because could not connect to NAC Manager",
"34147", "Failure", "Deny", "Terminated", "End", "WARN", "Low", "JGroups TLS Handshake Failed", "JGroups TLS Handshake Failed",
"34148", "Success", "Allow", "", "Start", "INFO", "Informational", "JGroups TLS Handshake Succeeded", "JGroups TLS Handshake Succeeded",
"34149", "Failure", "Deny", "Terminated", "End", "WARN", "Low", "HTTPS TLS Handshake Failed", "HTTPS TLS Handshake Failed",
"34150", "Success", "Allow", "", "Start", "INFO", "Informational", "HTTPS TLS Handshake Succeeded", "HTTPS TLS Handshake Succeeded",
"34159", "Success", "Allow", "", "Start", "INFO", "Informational", "LDAPS connection established successfully", "LDAPS connection established successfully",
"34160", "Success", "Allow", "", "End", "INFO", "Informational", "LDAPS connection terminated successfully", "LDAPS connection terminated successfully",
"34161", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection establishment failed with SSL error", "LDAPS connection establishment failed with SSL error",
"34162", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection terminated with SSL error", "LDAPS connection terminated with SSL error",
"34163", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection establishment failed with non-SSL error", "LDAPS connection establishment failed with non-SSL error",
"34164", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "LDAPS connection terminated with non-SSL error", "LDAPS connection terminated with non-SSL error",
"90062", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Cannot connect to Domain Controller", "Cannot connect to Domain Controller",
"90063", "Success", "Allow", "", "Start", "INFO", "Informational", "Successfully establish connection to Domain Controller", "Successfully establish connection to Domain Controller",
"90066", "Failure", "Drop", "Terminated", "End", "ERROR", "Low", "Lost connection with Domain Controller", "Lost connection with Domain Controller",
"90078", "Success", "Allow", "", "Start", "INFO", "Informational", "Closed connection to Domain Controller", "Closed connection to Domain Controller",
"91082", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "RADIUS DTLS: Connection to OCSP server failed", "RADIUS DTLS: Connection attempt to OCSP server failed.",
"11317", "Failure", "Drop", "Terminated", "End", "WARN", "Low", "TrustSec SSH connection failed", "ISE failed to establish SSH connection to a network device. Verify network device SSH credentials in the Network Device page are similar to the credentials configured on the network device. Check network device enabled ssh connections from ISE (ip address)",
"5405", "Failure", "Drop", "Terminated", "End", "NOTICE", "Low", "RADIUS Request dropped", "RADIUS request dropped",
"5406", "Failure", "Drop", "Terminated", "End", "NOTICE", "Low", "TACACS+ Request dropped", "TACACS+ request dropped"
];
let GetSrcIpAddr = (src_ip: string) {
    case ( 
    src_ip matches regex @"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}",
    src_ip,
    ""
    )
};
let GetMacAddr = (mac: string) {
    case ( 
    mac matches regex @"[a-fA-F0-9\-:]{17}",
    mac,
    ""
    )
};
let CiscoISENSParser = (
starttime: datetime=datetime(null), 
endtime: datetime=datetime(null),
srcipaddr_has_any_prefix: dynamic=dynamic([]), 
dstipaddr_has_any_prefix: dynamic=dynamic([]), 
ipaddr_has_any_prefix: dynamic=dynamic([]),
dstportnumber: int=int(null), 
hostname_has_any: dynamic=dynamic([]), 
dvcaction: dynamic=dynamic([]), 
eventresult: string='*', 
disabled: bool=false) {
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let EventOriginalTypeList = toscalar(EventFieldsLookup
      | where (eventresult == "*" or eventresult == EventResult) 
          and (array_length(dvcaction) == 0 or DvcAction in~ (dvcaction))
      | summarize make_set(EventOriginalType));
  Syslog
  | where not(disabled)
  | where (isnull(starttime) or TimeGenerated >= starttime) 
      and (isnull(endtime) or TimeGenerated <= endtime) 
  | where ProcessName has_any ("CISE", "CSCO")
  | parse kind = regex SyslogMessage with @"\d{10}\s" EventOriginalType @"\s(NOTICE|INFO|WARN|WARNING|ERROR|FATAL|DEBUG)"
  | where EventOriginalType in (EventOriginalTypeList)
      and (array_length(ip_any) == 0 or has_any_ipv4_prefix(SyslogMessage, ip_any)) 
      and (array_length(hostname_has_any) == 0 or SyslogMessage has_any(hostname_has_any)) 
      and (isnull(dstportnumber) or SyslogMessage has (strcat('DestinationPort=', tostring(dstportnumber))))
  | lookup EventFieldsLookup on EventOriginalType
  | parse-kv SyslogMessage as (FailureReason: string, NetworkDeviceName: string, DestinationIPAddress: string, DestinationPort: int, ['Remote-Address']: string, ['Device IP Address']: string, ['User-Name']: string, UserName: string, User: string, ['Device Port']: int, Protocol: string, ['Calling-Station-ID']: string, ['Called-Station-ID']: string) with (pair_delimiter=',', kv_delimiter='=')
  | project-rename
      DstIpAddr=DestinationIPAddress
      , DstPortNumber=DestinationPort
      , SrcPortNumber=['Device Port']
      , NetworkApplicationProtocol=Protocol
  | invoke _ASIM_ResolveSrcFQDN("['Calling-Station-ID']")
  | extend 
      EventVendor = "Cisco"
      , EventProduct = "ISE"
      , EventProductVersion = "3.2"
      , EventCount = int(1)
      , EventSchema = "NetworkSession"
      , EventSchemaVersion = "0.2.6"
      , EventStartTime = coalesce(EventTime, TimeGenerated)
      , EventEndTime = coalesce(EventTime, TimeGenerated)
      , EventType = "NetworkSession"
      , EventOriginalResultDetails = case(isnotempty(FailureReason), FailureReason, EventOriginalResultDetails)
      , DvcIpAddr = iif(isnotempty(HostIP) and HostIP != "Unknown IP", HostIP, extract(@"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", 1, Computer))
      , DstMacAddr = GetMacAddr(['Called-Station-ID'])
      , SrcMacAddr = GetMacAddr(['Calling-Station-ID'])
      , DstUsername = coalesce(UserName, ['User-Name'], User)
  | extend
      DstUsernameType = _ASIM_GetUsernameType(DstUsername)
      , DvcHostname = coalesce(NetworkDeviceName, Computer, HostName)
      , SrcIpAddr = coalesce(['Device IP Address'], ['Remote-Address'], GetSrcIpAddr(['Calling-Station-ID']))
  //********************** <Aliaces> ************************
  | extend 
      Dvc = coalesce(DvcHostname, DvcIpAddr)
      , IpAddr = SrcIpAddr
      , Dst = DstIpAddr
      , Src = SrcIpAddr
      , User = DstUsername
  //********************** </Aliases> ***********************
  | project-away
      TenantId,
      SourceSystem,
      MG,
      Computer,
      EventTime,
      Facility,
      HostName,
      SeverityLevel,
      SyslogMessage,
      HostIP,
      ProcessName,
      ProcessID,
      _ResourceId,
      FailureReason,
      NetworkDeviceName,
      ['User-Name'],
      UserName,
      ['Device IP Address'],
      ['Remote-Address'],
      ['Calling-Station-ID'],
      ['Called-Station-ID']
};
CiscoISENSParser(
starttime=starttime,
endtime=endtime, 
srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
ipaddr_has_any_prefix=ipaddr_has_any_prefix, 
dstportnumber=dstportnumber, 
hostname_has_any=hostname_has_any, 
dvcaction=dvcaction, 
eventresult=eventresult, 
disabled=disabled)
}



//
// Function Name: vimNetworkSessionCiscoMeraki
// Description: This ASIM parser supports normalizing Cisco Meraki logs ingested in 'meraki_CL' to the ASIM Network Session normalized schema. Cisco Meraki events are generated from network activity and security events from Meraki devices such as firewalls, switches, and access points. These logs are captured through the Cisco Meraki Sentinel connector which uses a Linux agent to collect logs in Syslog format.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoMeraki(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventResultDetailsLookup = datatable(reason: string, EventResultDetails: string)
  [
    "0", "Unknown",
    "1", "Unknown",
    "2", "Timeout",
    "3", "Terminated",
    "4", "Timeout",
    "5", "Transient error",
    "6", "Invalid Tunnel",
    "7", "Invalid Tunnel",
    "8", "Terminated",
    "9", "Invalid Tunnel",
    "10", "Unknown",
    "11", "Invalid TCP",
    "12", "Unknown",
    "13", "Invalid TCP",
    "14", "Invalid Tunnel",
    "15", "Invalid TCP",
    "16", "Timeout",
    "17", "Invalid Tunnel",
    "18", "Invalid TCP",
    "19", "Invalid TCP",
    "20", "Invalid TCP",
    "21", "Unknown",
    "22", "Invalid TCP",
    "23", "Invalid Tunnel",
    "24", "Invalid Tunnel",
    "32", "Unknown",
    "33", "Invalid TCP",
    "34", "Invalid TCP",
    "35", "Invalid TCP",
    "36", "Unknown",
    "37", "Unknown",
    "38", "Unknown",
    "39", "Timeout",
    "40", "Invalid TCP",
    "98", "Unknown",
    "99", "Unknown"
];
let NetworkIcmpTypeLookup = datatable(
    NetworkIcmpCode_lookup: int,
    NetworkIcmpType_lookup: string
)
    [
    0, "Reserved",
    1, "Destination Unreachable",
    2, "Packet Too Big",
    3, "Time Exceeded",
    4, "Parameter Problem",
    100, "Private experimentation",
    101, "Private experimentation",
    127, "Reserved for expansion of ICMPv6 error messages",
    128, "Echo Request",
    129, "Echo Reply",
    130, "Multicast Listener Query",
    131, "Multicast Listener Report",
    132, "Multicast Listener Done",
    133, "Router Solicitation",
    134, "Router Advertisement",
    135, "Neighbor Solicitation",
    136, "Neighbor Advertisement",
    137, "Redirect Message",
    138, "Router Renumbering",
    139, "ICMP Node Information Query",
    140, "ICMP Node Information Response",
    141, "Inverse Neighbor Discovery Solicitation Message",
    142, "Inverse Neighbor Discovery Advertisement Message",
    143, "Version 2 Multicast Listener Report",
    144, "Home Agent Address Discovery Request Message",
    145, "Home Agent Address Discovery Reply Message",
    146, "Mobile Prefix Solicitation",
    147, "Mobile Prefix Advertisement",
    148, "Certification Path Solicitation Message",
    149, "Certification Path Advertisement Message",
    150, "ICMP messages utilized by experimental mobility protocols such as Seamoby",
    151, "Multicast Router Advertisement",
    152, "Multicast Router Solicitation",
    153, "Multicast Router Termination",
    154, "FMIPv6 Messages",
    155, "RPL Control Message",
    156, "ILNPv6 Locator Update Message",
    157, "Duplicate Address Request",
    158, "Duplicate Address Confirmation",
    159, "MPL Control Message",
    160, "Extended Echo Request",
    161, "Extended Echo Reply",
    200, "Private experimentation",
    201, "Private experimentation",
    255, "Reserved for expansion of ICMPv6 informational messages"
];
let NetworkProtocolLookup = datatable(
    protocol: string,
    NetworkProtocol_lookup: string,
    NetworkProtocolVersion: string
)[
    "tcp", "TCP", "",
    "tcp/ip", "TCP", "",
    "udp", "UDP", "",
    "udp/ip", "UDP", "",
    "icmp", "ICMP", "IPV4",
    "icmp6", "ICMP", "IPV6",
];
let EventSeverityPriorityLookup = datatable(priority: string, EventSeverity: string)[
    "1", "High",
    "2", "Medium",
    "3", "Low",
    "4", "Informational"
];
let EventSeverityDvcActionLookup = datatable(DvcAction: string, EventSeverity: string)[
    "Allow", "Informational",
    "Deny", "Low"
];
let NetworkDirectionLookup = datatable(direction: string, NetworkDirection: string)[
    "ingress", "Inbound",
    "egress", "Outbound",
    "Unknown", "NA"
];
let DvcActionLookup = datatable(pattern: string, DvcAction: string, EventResult: string)[
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "0", "Allow", "Success",
    "1", "Deny", "Failure",
    "Blocked", "Deny", "Failure"
];
let EventResultLookup = datatable(LogSubType: string, EventResult_type: string)[
    "association", "Success",
    "disassociation", "Failure",
    "Virtual router collision", "Failure",
];
let parser=(disabled: bool=false, 
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null), 
    eventresult: string='*', 
    srcipaddr_has_any_prefix: dynamic=dynamic([]),
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]), 
    hostname_has_any: dynamic=dynamic([]),
    dstportnumber: int=int(null),
    dvcaction: dynamic=dynamic([])
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let allData = (
            meraki_CL
            | project-rename LogMessage =  Message
            );
    let PreFilteredData = allData
        | where not(disabled) and (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime) and (LogMessage has_any("flows", "firewall", "ids-alerts") or LogMessage has_all("security_event", "ids-alerted") or (LogMessage has "events" and (LogMessage has_any ("Blocked DHCP server response", "association") or (LogMessage has "VRRP packet" and not(LogMessage has_any ("VRRP passive", "VRRP active"))) or (LogMessage has "disassociation" and not(LogMessage has_any ("auth_neg_failed", "dhcp"))))) or (LogMessage has "airmarshal_events" and LogMessage has_any("ssid_spoofing_detected", "rogue_ssid_detected")))
        | extend Parser = extract_all(@"(\d+.\d+)\s([\w\-\_]+)\s([\w\-\_]+)\s([\S\s]+)$", dynamic([1, 2, 3, 4]), LogMessage)[0]
        | extend
            LogType = tostring(Parser[2]),
            Substring = tostring(Parser[3]),
            Device = tostring(Parser[1])
        | parse Substring with * "timestamp=" timestamp: string " " *
        | extend
            Epoch = iff(isnotempty(timestamp), timestamp, tostring(Parser[0]))
        | extend
            EpochTimestamp = split(Epoch, ".")
        | extend EventStartTime = unixtime_seconds_todatetime(tolong(EpochTimestamp[0]))
        | extend EventEndTime = EventStartTime
        | where (array_length(hostname_has_any) == 0)
            and ((isnull(dstportnumber)) or Substring has tostring(dstportnumber))
            and (array_length(dvcaction) == 0 or LogMessage has_any (dvcaction));
    let FlowsFirewallData = PreFilteredData
        | where LogType in ("flows", "firewall", "cellular_firewall", "vpn_firewall")
        | parse-kv Substring as(src: string, dst: string, mac: string, sport: string, dport: string, protocol: string, type: int) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | parse Substring with pattern1: string " src=" temp_restmessage: string
        | parse Substring with * "pattern: " pattern2: string " " temp_restmessage: string
        | extend NetworkIcmpCode_lookup = iff(protocol == 'icmp6', type, int(null))
        | extend type_icmp4 = iff(protocol == 'icmp', type, int(null))
        | lookup NetworkIcmpTypeLookup on NetworkIcmpCode_lookup
        | invoke _ASIM_ResolveICMPType('type_icmp4')
        | extend NetworkIcmpCode = coalesce(NetworkIcmpCode_lookup, NetworkIcmpCode)
        | extend NetworkIcmpType = iff(isnotempty(NetworkIcmpCode), coalesce(NetworkIcmpType_lookup, NetworkIcmpType), "")
        | extend pattern = coalesce(trim("'", pattern1), trim("'", pattern2))
        | extend pattern = trim('"', pattern)
        | extend direction = case(pattern has_any ('0','1'), 'ingress', pattern has_any ('allow','deny'), 'egress', 'unknown')
        | lookup NetworkDirectionLookup on direction
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | extend
            SrcMacAddr = trim('"', mac),
            EventType = "Flow";
    let IDSAlertData = PreFilteredData
        | where LogType in ("ids-alerts", "security_event")
        | parse LogMessage with * "security_event " LogSubType: string " " * "message: " message: string 
        | where LogType == "security_event" and LogSubType == "ids-alerted" or LogType == "ids-alerts"
        | parse-kv Substring as(priority: string, direction: string, protocol: string, src: string, dst: string, signature: string, dhost: string, shost: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend EventResult = "Success"
        | extend
            priority = trim('"', priority),
            direction = trim('"', direction)
        | lookup EventSeverityPriorityLookup on priority
        | lookup NetworkDirectionLookup on direction
        | extend AdditionalFields = bag_pack(
                                "signature", trim('"', signature)
                            )
        | extend
            SrcMacAddr = trim('"', shost),
            DstMacAddr = trim('"', dhost)
        | extend EventMessage = trim("'", message);
    let AirmarshalEvents = PreFilteredData
        | where LogType in ("airmarshal_events")
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType in ("ssid_spoofing_detected", "rogue_ssid_detected")
        | parse-kv temp_message as(src: string, dst: string, wired_mac: string, vlan_id: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend
            SrcMacAddr = trim('"', src),
            DstMacAddr = trim('"', dst),
            DvcMacAddr = trim('"', wired_mac)
        | extend
            EventResult = "Success",
            EventSeverity = "High";
    let EventsData = PreFilteredData
        | where LogType == "events";
    let EventsData_associ = EventsData
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType == "association" or (LogSubType == "disassociation" and not(Substring has_any ("auth_neg_failed", "dhcp")))
        | parse-kv Substring as (last_known_client_ip: string, client_mac: string, identity: string, aid: string, duration: string, ip_src: string, dns_server: string, reason: string, rssi: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend AdditionalFields = bag_pack(
                                "aid", aid,
                                "rssi", rssi
                            )
        | extend SrcMacAddr = trim('"', client_mac)
        | lookup EventResultLookup on LogSubType
        | extend EventResult = EventResult_type
        | lookup EventResultDetailsLookup on reason
        | extend EventResultDetails = iff((toint(reason) >= 25 and toint(reason) <= 31) or (toint(reason) >= 25 and toint(reason) <= 31), "Unknown", EventResultDetails);
    let EventsData_space = EventsData
        | where Substring has "Blocked DHCP server response" or (Substring has "VRRP packet" and not(Substring in~ ("VRRP passive", "VRRP active"))) 
        | parse Substring with LogSubType1: string " from" temp_addr1: string " on VLAN " vlan_id1: string " " restmessage
        | parse Substring with LogSubType2: string " from" temp_addr2: string " on VLAN " vlan_id2: string
        | extend LogSubType = coalesce(LogSubType1, LogSubType2)
        | extend LogSubType = iff(LogSubType has "VRRP Packet", "Virtual router collision", LogSubType)
        | extend pattern = iff(Substring has "Blocked", "Blocked", "")
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | lookup EventResultLookup on LogSubType
        | extend EventResult = coalesce(EventResult, EventResult_type)
        | extend temp_addr = coalesce(trim('"', temp_addr1), trim('"', temp_addr2))
        | extend vlan_id = coalesce(trim('"', vlan_id1), trim('"', vlan_id2))
        | extend SrcMacAddr = iff(temp_addr matches regex "(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))", temp_addr, "")
        | parse temp_addr with *  "[" temp_ip: string "]:" temp_port: string 
        | extend SrcIpAddr = case(
                        temp_addr has ".",
                        split(temp_addr, ":")[0],
                        isnotempty(temp_ip),
                        temp_ip,
                        temp_addr
                    )
        | extend SrcPortNumber = toint(case(
                          isnotempty(temp_port),
                          temp_port,
                          temp_addr has ".",
                          split(temp_addr, ":")[1],
                          ""
                      )
                    )
        | extend
            SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr),
            EventMessage = Substring;
    union
        FlowsFirewallData,
        IDSAlertData,
        EventsData_associ,
        EventsData_space,
        AirmarshalEvents
    | where (array_length(dvcaction) == 0 or DvcAction has_any (dvcaction))
    | where (eventresult == "*" or EventResult =~ eventresult)
    | extend protocol = trim('"', protocol)
    | lookup NetworkProtocolLookup on protocol
    | invoke _ASIM_ResolveNetworkProtocol('protocol')
    | extend NetworkProtocol = iff(isempty(NetworkProtocolNumber), NetworkProtocol_lookup, NetworkProtocol)
    | extend temp_srcipport = trim('"', coalesce(src, ip_src, last_known_client_ip))
    | parse temp_srcipport with *  "[" temp_srcip: string "]:" temp_srcport: string 
    | extend SrcIpAddr = case( 
                        isnotempty(SrcIpAddr),
                        SrcIpAddr,
                        temp_srcipport has ".",
                        split(temp_srcipport, ":")[0],
                        coalesce(temp_srcip, temp_srcipport)
                    )
    | extend SrcPortNumber = iff(isempty(SrcPortNumber), toint(coalesce(sport, temp_srcport)), SrcPortNumber)
    | extend SrcPortNumber = toint(iff(isempty(SrcPortNumber) and SrcIpAddr has ".", split(temp_srcipport, ":")[1], SrcPortNumber))
    | extend temp_dstipport = trim('"', coalesce(dst, dns_server))
    | parse temp_dstipport with * "[" temp_dstip "]:" temp_dstport
    | extend DstIpAddr = iff(temp_dstipport has ".", split(temp_dstipport, ":")[0], coalesce(temp_dstip, temp_dstipport))
    | extend DstPortNumber = toint(coalesce(dport, temp_dstport))
    | extend DstPortNumber = toint(iff(isempty(DstPortNumber) and DstIpAddr has ".", split(temp_dstipport, ":")[1], DstPortNumber))
    | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
    | extend DstIpAddr = iff(DstIpAddr == DstMacAddr, "", DstIpAddr)
    | where  (isnull(dstportnumber) or dstportnumber == DstPortNumber)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SrcIpAddr, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DstIpAddr, dst_or_any)
    | extend ASimMatchingIpAddr=case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
    | extend
        SrcUsername = trim('"', identity),
        SrcVlanId = trim('"', vlan_id)
    | invoke _ASIM_ResolveDvcFQDN('Device')
    | extend NetworkIcmpType = iff((protocol == 'icmp6' and isnotempty(NetworkIcmpCode)) and (NetworkIcmpCode between (5 .. 99) or NetworkIcmpCode between (102 .. 126) or NetworkIcmpCode between(162 .. 199) or NetworkIcmpCode between (202 .. 254)), "Unassigned", NetworkIcmpType)
    | extend
        EventSeverity = case(
                    isnotempty(EventSeverity),
                    EventSeverity,
                    EventResult == "Failure",
                    "Low",
                    "Informational"
                ),
        EventType = iff(isnotempty(EventType), EventType, "NetworkSession"),
        SrcUsernameType = iff(isnotempty(SrcUsername), "Simple", "")
    | extend
        Dvc = DvcHostname,
        Src = coalesce(SrcIpAddr, SrcMacAddr),
        Dst = coalesce(DstIpAddr, DstMacAddr),
        NetworkDuration = toint(todouble(trim('"', duration)) * 1000)
    | project-rename
        EventOriginalType = LogType,
        EventOriginalSubType = LogSubType
    | extend
        EventCount = int(1),
        EventProduct = "Meraki",
        EventVendor = "Cisco",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        EventUid = _ResourceId
    | project-away
        LogMessage,
        Parser,
        Epoch,
        EpochTimestamp,
        Device,
        Substring,
        protocol,
        priority,
        reason,
        direction,
        duration,
        src,
        dst,
        dns_server,
        sport,
        dport,
        *_lookup,
        type*,
        pattern*,
        last_known_client_ip,
        ip_src,
        client_mac,
        mac,
        shost,
        dhost,
        wired_mac,
        identity,
        temp*,
        vlan_id*,
        LogSubType1,
        LogSubType2,
        restmessage*,
        message,
        rssi,
        aid,
        signature,
        timestamp,
        EventResult_type,
        TenantId,
        SourceSystem,
        Computer,
        _ResourceId,
        MG,ManagementGroupName,NetworkProtocolNumber
};
parser(
    disabled=disabled,
    starttime=starttime, 
    endtime=endtime,
    eventresult=eventresult,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix,
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix,
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    hostname_has_any=hostname_has_any,
    dstportnumber=dstportnumber,
    dvcaction=dvcaction
)
}



//
// Function Name: vimNetworkSessionCiscoMerakiSyslog
// Description: This ASIM parser supports normalizing Cisco Meraki logs ingested in 'Syslog' to the ASIM Network Session normalized schema. Cisco Meraki events are generated from network activity and security events from Meraki devices such as firewalls, switches, and access points. These logs are captured through the Cisco Meraki Sentinel connector which uses a Linux agent to collect logs in Syslog format.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCiscoMerakiSyslog(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventResultDetailsLookup = datatable(reason: string, EventResultDetails: string)
  [
    "0", "Unknown",
    "1", "Unknown",
    "2", "Timeout",
    "3", "Terminated",
    "4", "Timeout",
    "5", "Transient error",
    "6", "Invalid Tunnel",
    "7", "Invalid Tunnel",
    "8", "Terminated",
    "9", "Invalid Tunnel",
    "10", "Unknown",
    "11", "Invalid TCP",
    "12", "Unknown",
    "13", "Invalid TCP",
    "14", "Invalid Tunnel",
    "15", "Invalid TCP",
    "16", "Timeout",
    "17", "Invalid Tunnel",
    "18", "Invalid TCP",
    "19", "Invalid TCP",
    "20", "Invalid TCP",
    "21", "Unknown",
    "22", "Invalid TCP",
    "23", "Invalid Tunnel",
    "24", "Invalid Tunnel",
    "32", "Unknown",
    "33", "Invalid TCP",
    "34", "Invalid TCP",
    "35", "Invalid TCP",
    "36", "Unknown",
    "37", "Unknown",
    "38", "Unknown",
    "39", "Timeout",
    "40", "Invalid TCP",
    "98", "Unknown",
    "99", "Unknown"
];
let NetworkIcmpTypeLookup = datatable(
    NetworkIcmpCode_lookup: int,
    NetworkIcmpType_lookup: string
)
    [
    0, "Reserved",
    1, "Destination Unreachable",
    2, "Packet Too Big",
    3, "Time Exceeded",
    4, "Parameter Problem",
    100, "Private experimentation",
    101, "Private experimentation",
    127, "Reserved for expansion of ICMPv6 error messages",
    128, "Echo Request",
    129, "Echo Reply",
    130, "Multicast Listener Query",
    131, "Multicast Listener Report",
    132, "Multicast Listener Done",
    133, "Router Solicitation",
    134, "Router Advertisement",
    135, "Neighbor Solicitation",
    136, "Neighbor Advertisement",
    137, "Redirect Message",
    138, "Router Renumbering",
    139, "ICMP Node Information Query",
    140, "ICMP Node Information Response",
    141, "Inverse Neighbor Discovery Solicitation Message",
    142, "Inverse Neighbor Discovery Advertisement Message",
    143, "Version 2 Multicast Listener Report",
    144, "Home Agent Address Discovery Request Message",
    145, "Home Agent Address Discovery Reply Message",
    146, "Mobile Prefix Solicitation",
    147, "Mobile Prefix Advertisement",
    148, "Certification Path Solicitation Message",
    149, "Certification Path Advertisement Message",
    150, "ICMP messages utilized by experimental mobility protocols such as Seamoby",
    151, "Multicast Router Advertisement",
    152, "Multicast Router Solicitation",
    153, "Multicast Router Termination",
    154, "FMIPv6 Messages",
    155, "RPL Control Message",
    156, "ILNPv6 Locator Update Message",
    157, "Duplicate Address Request",
    158, "Duplicate Address Confirmation",
    159, "MPL Control Message",
    160, "Extended Echo Request",
    161, "Extended Echo Reply",
    200, "Private experimentation",
    201, "Private experimentation",
    255, "Reserved for expansion of ICMPv6 informational messages"
];
let NetworkProtocolLookup = datatable(
    protocol: string,
    NetworkProtocol_lookup: string,
    NetworkProtocolVersion: string
)[
    "tcp", "TCP", "",
    "tcp/ip", "TCP", "",
    "udp", "UDP", "",
    "udp/ip", "UDP", "",
    "icmp", "ICMP", "IPV4",
    "icmp6", "ICMP", "IPV6",
];
let EventSeverityPriorityLookup = datatable(priority: string, EventSeverity: string)[
    "1", "High",
    "2", "Medium",
    "3", "Low",
    "4", "Informational"
];
let EventSeverityDvcActionLookup = datatable(DvcAction: string, EventSeverity: string)[
    "Allow", "Informational",
    "Deny", "Low"
];
let NetworkDirectionLookup = datatable(direction: string, NetworkDirection: string)[
    "ingress", "Inbound",
    "egress", "Outbound",
    "Unknown", "NA"
];
let DvcActionLookup = datatable(pattern: string, DvcAction: string, EventResult: string)[
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "Blocked", "Deny", "Failure"
];
let EventResultLookup = datatable(LogSubType: string, EventResult_type: string)[
    "association", "Success",
    "disassociation", "Failure",
    "Virtual router collision", "Failure",
];
let parser=(disabled: bool=false, 
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null), 
    eventresult: string='*', 
    srcipaddr_has_any_prefix: dynamic=dynamic([]),
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]), 
    hostname_has_any: dynamic=dynamic([]),
    dstportnumber: int=int(null),
    dvcaction: dynamic=dynamic([])
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let allData = (
            Syslog
            | where Computer in (_ASIM_GetSourceBySourceType('CiscoMeraki'))
            | project-rename LogMessage =  SyslogMessage
            );
    let PreFilteredData = allData
        | where not(disabled) and (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime) and (LogMessage has_any("flows", "firewall", "ids-alerts") or LogMessage has_all("security_event", "ids-alerted") or (LogMessage has "events" and (LogMessage has_any ("Blocked DHCP server response", "association") or (LogMessage has "VRRP packet" and not(LogMessage has_any ("VRRP passive", "VRRP active"))) or (LogMessage has "disassociation" and not(LogMessage has_any ("auth_neg_failed", "dhcp"))))) or (LogMessage has "airmarshal_events" and LogMessage has_any("ssid_spoofing_detected", "rogue_ssid_detected")))
        | extend Parser = extract_all(@"(\d+.\d+)\s([\w\-\_]+)\s([\w\-\_]+)\s([\S\s]+)$", dynamic([1, 2, 3, 4]), LogMessage)[0]
        | extend
            LogType = tostring(Parser[2]),
            Substring = tostring(Parser[3]),
            Device = tostring(Parser[1])
        | parse Substring with * "timestamp=" timestamp: string " " *
        | extend
            Epoch = iff(isnotempty(timestamp), timestamp, tostring(Parser[0]))
        | extend
            EpochTimestamp = split(Epoch, ".")
        | extend EventStartTime = unixtime_seconds_todatetime(tolong(EpochTimestamp[0]))
        | extend EventEndTime = EventStartTime
        | where (array_length(hostname_has_any) == 0)
            and ((isnull(dstportnumber)) or Substring has tostring(dstportnumber))
            and (array_length(dvcaction) == 0 or LogMessage has_any (dvcaction));
    let FlowsFirewallData = PreFilteredData
        | where LogType in ("flows", "firewall", "cellular_firewall", "vpn_firewall")
        | parse-kv Substring as(src: string, dst: string, mac: string, sport: string, dport: string, protocol: string, type: int) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | parse Substring with pattern1: string " src=" temp_restmessage: string
        | parse Substring with * "pattern: " pattern2: string " " temp_restmessage: string
        | extend NetworkIcmpCode_lookup = iff(protocol == 'icmp6', type, int(null))
        | extend type_icmp4 = iff(protocol == 'icmp', type, int(null))
        | lookup NetworkIcmpTypeLookup on NetworkIcmpCode_lookup
        | invoke _ASIM_ResolveICMPType('type_icmp4')
        | extend NetworkIcmpCode = coalesce(NetworkIcmpCode_lookup, NetworkIcmpCode)
        | extend NetworkIcmpType = iff(isnotempty(NetworkIcmpCode), coalesce(NetworkIcmpType_lookup, NetworkIcmpType), "")
        | extend pattern = coalesce(trim("'", pattern1), trim("'", pattern2))
        | extend pattern = trim('"', pattern)
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | extend
            SrcMacAddr = trim('"', mac),
            EventType = "Flow";
    let IDSAlertData = PreFilteredData
        | where LogType in ("ids-alerts", "security_event")
        | parse LogMessage with * "security_event " LogSubType: string " " * "message: " message: string 
        | where LogType == "security_event" and LogSubType == "ids-alerted" or LogType == "ids-alerts"
        | parse-kv Substring as(priority: string, direction: string, protocol: string, src: string, dst: string, signature: string, dhost: string, shost: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend EventResult = "Success"
        | extend
            priority = trim('"', priority),
            direction = trim('"', direction)
        | lookup EventSeverityPriorityLookup on priority
        | lookup NetworkDirectionLookup on direction
        | extend AdditionalFields = bag_pack(
                                "signature", trim('"', signature)
                            )
        | extend
            SrcMacAddr = trim('"', shost),
            DstMacAddr = trim('"', dhost)
        | extend EventMessage = trim("'", message);
    let AirmarshalEvents = PreFilteredData
        | where LogType in ("airmarshal_events")
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType in ("ssid_spoofing_detected", "rogue_ssid_detected")
        | parse-kv temp_message as(src: string, dst: string, wired_mac: string, vlan_id: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend
            SrcMacAddr = trim('"', src),
            DstMacAddr = trim('"', dst),
            DvcMacAddr = trim('"', wired_mac)
        | extend
            EventResult = "Success",
            EventSeverity = "High";
    let EventsData = PreFilteredData
        | where LogType == "events";
    let EventsData_associ = EventsData
        | parse Substring with * "type=" LogSubType: string " " temp_message: string
        | where LogSubType == "association" or (LogSubType == "disassociation" and not(Substring has_any ("auth_neg_failed", "dhcp")))
        | parse-kv Substring as (last_known_client_ip: string, client_mac: string, identity: string, aid: string, duration: string, ip_src: string, dns_server: string, reason: string, rssi: string) with (pair_delimiter=" ", kv_delimiter="=", quote="'")
        | extend AdditionalFields = bag_pack(
                                "aid", aid,
                                "rssi", rssi
                            )
        | extend SrcMacAddr = trim('"', client_mac)
        | lookup EventResultLookup on LogSubType
        | extend EventResult = EventResult_type
        | lookup EventResultDetailsLookup on reason
        | extend EventResultDetails = iff((toint(reason) >= 25 and toint(reason) <= 31) or (toint(reason) >= 25 and toint(reason) <= 31), "Unknown", EventResultDetails);
    let EventsData_space = EventsData
        | where Substring has "Blocked DHCP server response" or (Substring has "VRRP packet" and not(Substring in~ ("VRRP passive", "VRRP active"))) 
        | parse Substring with LogSubType1: string " from" temp_addr1: string " on VLAN " vlan_id1: string " " restmessage
        | parse Substring with LogSubType2: string " from" temp_addr2: string " on VLAN " vlan_id2: string
        | extend LogSubType = coalesce(LogSubType1, LogSubType2)
        | extend LogSubType = iff(LogSubType has "VRRP Packet", "Virtual router collision", LogSubType)
        | extend pattern = iff(Substring has "Blocked", "Blocked", "")
        | lookup DvcActionLookup on pattern
        | lookup EventSeverityDvcActionLookup on DvcAction
        | lookup EventResultLookup on LogSubType
        | extend EventResult = coalesce(EventResult, EventResult_type)
        | extend temp_addr = coalesce(trim('"', temp_addr1), trim('"', temp_addr2))
        | extend vlan_id = coalesce(trim('"', vlan_id1), trim('"', vlan_id2))
        | extend SrcMacAddr = iff(temp_addr matches regex "(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}))", temp_addr, "")
        | parse temp_addr with *  "[" temp_ip: string "]:" temp_port: string 
        | extend SrcIpAddr = case(
                        temp_addr has ".",
                        split(temp_addr, ":")[0],
                        isnotempty(temp_ip),
                        temp_ip,
                        temp_addr
                    )
        | extend SrcPortNumber = toint(case(
                          isnotempty(temp_port),
                          temp_port,
                          temp_addr has ".",
                          split(temp_addr, ":")[1],
                          ""
                      )
                    )
        | extend
            SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr),
            EventMessage = Substring;
    union
        FlowsFirewallData,
        IDSAlertData,
        EventsData_associ,
        EventsData_space,
        AirmarshalEvents
    | where (array_length(dvcaction) == 0 or DvcAction has_any (dvcaction))
    | where (eventresult == "*" or EventResult =~ eventresult)
    | extend protocol = trim('"', protocol)
    | lookup NetworkProtocolLookup on protocol
    | invoke _ASIM_ResolveNetworkProtocol('protocol')
    | extend NetworkProtocol = iff(isempty(NetworkProtocolNumber), NetworkProtocol_lookup, NetworkProtocol)
    | extend temp_srcipport = trim('"', coalesce(src, ip_src, last_known_client_ip))
    | parse temp_srcipport with *  "[" temp_srcip: string "]:" temp_srcport: string 
    | extend SrcIpAddr = case( 
                        isnotempty(SrcIpAddr),
                        SrcIpAddr,
                        temp_srcipport has ".",
                        split(temp_srcipport, ":")[0],
                        coalesce(temp_srcip, temp_srcipport)
                    )
    | extend SrcPortNumber = iff(isempty(SrcPortNumber), toint(coalesce(sport, temp_srcport)), SrcPortNumber)
    | extend SrcPortNumber = toint(iff(isempty(SrcPortNumber) and SrcIpAddr has ".", split(temp_srcipport, ":")[1], SrcPortNumber))
    | extend temp_dstipport = trim('"', coalesce(dst, dns_server))
    | parse temp_dstipport with * "[" temp_dstip "]:" temp_dstport
    | extend DstIpAddr = iff(temp_dstipport has ".", split(temp_dstipport, ":")[0], coalesce(temp_dstip, temp_dstipport))
    | extend DstPortNumber = toint(coalesce(dport, temp_dstport))
    | extend DstPortNumber = toint(iff(isempty(DstPortNumber) and DstIpAddr has ".", split(temp_dstipport, ":")[1], DstPortNumber))
    | extend SrcIpAddr = iff(SrcIpAddr == SrcMacAddr, "", SrcIpAddr)
    | extend DstIpAddr = iff(DstIpAddr == DstMacAddr, "", DstIpAddr)
    | where  (isnull(dstportnumber) or dstportnumber == DstPortNumber)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SrcIpAddr, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DstIpAddr, dst_or_any)
    | extend ASimMatchingIpAddr=case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
    | extend
        SrcUsername = trim('"', identity),
        SrcVlanId = trim('"', vlan_id)
    | invoke _ASIM_ResolveDvcFQDN('Device')
    | extend NetworkIcmpType = iff((protocol == 'icmp6' and isnotempty(NetworkIcmpCode)) and (NetworkIcmpCode between (5 .. 99) or NetworkIcmpCode between (102 .. 126) or NetworkIcmpCode between(162 .. 199) or NetworkIcmpCode between (202 .. 254)), "Unassigned", NetworkIcmpType)
    | extend
        EventSeverity = case(
                    isnotempty(EventSeverity),
                    EventSeverity,
                    EventResult == "Failure",
                    "Low",
                    "Informational"
                ),
        EventType = iff(isnotempty(EventType), EventType, "NetworkSession"),
        SrcUsernameType = iff(isnotempty(SrcUsername), "Simple", "")
    | extend
        Dvc = DvcHostname,
        Src = coalesce(SrcIpAddr, SrcMacAddr),
        Dst = coalesce(DstIpAddr, DstMacAddr),
        NetworkDuration = toint(todouble(trim('"', duration)) * 1000)
    | project-rename
        EventOriginalType = LogType,
        EventOriginalSubType = LogSubType
    | extend
        EventCount = int(1),
        EventProduct = "Meraki",
        EventVendor = "Cisco",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        InnerVlanId = SrcVlanId,
        EventUid = _ResourceId
    | project-away
        LogMessage,
        Parser,
        Epoch,
        EpochTimestamp,
        Device,
        Substring,
        protocol,
        priority,
        reason,
        direction,
        duration,
        src,
        dst,
        dns_server,
        sport,
        dport,
        *_lookup,
        type*,
        pattern*,
        last_known_client_ip,
        ip_src,
        client_mac,
        mac,
        shost,
        dhost,
        wired_mac,
        identity,
        temp*,
        vlan_id*,
        LogSubType1,
        LogSubType2,
        restmessage*,
        message,
        rssi,
        aid,
        signature,
        timestamp,
        EventResult_type,
        TenantId,
        SourceSystem,
        Computer,
        _ResourceId,
        MG,
        EventTime,
        Facility,
        HostName,
        SeverityLevel,
        ProcessID,
        HostIP,
        ProcessName,CollectorHostName,NetworkProtocolNumber
};
parser(
    disabled=disabled,
    starttime=starttime, 
    endtime=endtime,
    eventresult=eventresult,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix,
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix,
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    hostname_has_any=hostname_has_any,
    dstportnumber=dstportnumber,
    dvcaction=dvcaction
)
}



//
// Function Name: vimNetworkSessionCorelightZeek
// Description: This ASIM parser supports filtering and normalizing Corelight Zeek Connection logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCorelightZeek(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let NetworkDirectionLookup = datatable(local_orig: bool, local_resp: bool, NetworkDirection: string)
[
  false, true, 'Inbound',
  true, false, 'Outbound',
  true, true, 'Local',
  false, false, 'Local'
];
let ResultLookup = datatable (conn_state:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string, EventSeverity:string)
[ 
   'S0', 'Success', '', 'Connection attempt seen, no reply', 'Informational',
   'S1', 'Success', '', 'Connection established, not terminated', 'Informational',
   'SF', 'Success', 'Terminated', 'Normal establishment and termination', 'Informational', // Note that this is the same symbol as for state S1. You can tell the two apart because for S1 there will not be any byte counts in the summary, while for SF there will be.
   'REJ', 'Failure', 'Rejeced', 'Connection attempt rejected', 'Low',
   'S2', 'Failure', 'Terminated', 'Connection established and close attempt by originator seen (but no reply from responder)', 'Low',
   'S3', 'Failure', 'Terminated', 'Connection established and close attempt by responder seen (but no reply from originator)', 'Low',
   'RSTO', 'Failure', 'Reset', 'Connection established, originator aborted (sent a RST)', 'Low',
   'RSTR', 'Failure', 'Reset', 'Responder sent a RST', 'Low',
   'RSTOS0', 'Failure', 'Reset', 'Originator sent a SYN followed by a RST, no SYN-ACK from the responder','Low',
   'RSTRH', 'Failure', 'Reset', 'Responder sent a SYN ACK followed by a RST, no SYN from the originator','Low',
   'SH', 'Failure', 'Timeout', 'Originator sent a SYN followed by a FIN, no SYN ACK from the responder', 'Low',
   'SHR', 'Failure', 'Timeout', 'Responder sent a SYN ACK followed by a FIN, no SYN from the originator', 'Low',
   'OTH', 'Success', '', 'No SYN seen, just midstream traffic', 'Informational'
];
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null), 
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]), 
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false
) 
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);    
  Corelight_CL 
  | where (isnull(starttime) or TimeGenerated>=starttime) 
      and (isnull(endtime) or TimeGenerated<=endtime) 
      and not(disabled)
      and (array_length(hostname_has_any) == 0)
      and (array_length(dvcaction) == 0)
      and (Message has '"_path":"conn"' or Message has '"conn_red"')
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(Message,ip_any)) 
      and (isnull(dstportnumber) or Message has (strcat('"id.resp_p":', tostring(dstportnumber)))) 
  | project Message
  | parse Message with * '"conn_state":"' conn_state '",' *
  | lookup ResultLookup on conn_state
  | where (eventresult == "*" or eventresult == EventResult)
  | parse-kv Message as (
      ['"_system_name"']:string,
      ['"_write_ts"']:datetime,
      ['"ts"']:datetime,
      ['"uid"']:string,
      ['"id.orig_h"']:string,
      ['"id.orig_p"']:int,
      ['"id.resp_h"']:string,
      ['"id.resp_p"']:int,
      ['"proto"']:string,
      ['"service"']:string,
      ['"duration"']:int,
      ['"orig_bytes"']:long,
      ['"resp_bytes"']:long,
      ['"local_orig"']:bool,
      ['"local_resp"']:bool,
      ['"missed_bytes"']:long,
      ['"history"']:string,
      ['"orig_pkts"']:long,
      ['"resp_pkts"']:long,
      ['"orig_l2_addr"']:string,
      ['"resp_l2_addr"']:string,
      ['"community_id']:string,
      ['"vlan"']:string,
      ['"inner_vlan"']:string
  ) 
  with (quote = '"')
  | extend 
      EventCount=int(1),
      EventProduct="Zeek",
      EventVendor="Corelight",
      EventSchema = "NetworkSession",
      EventSchemaVersion="0.2.4",
      EventType="Flow"
  | project-rename
      EventStartTime= ['"ts"'],
      EventEndTime = ['"_write_ts"'],
      EventOriginalUid = ['"uid"'],
      SrcIpAddr = ['"id.orig_h"'],
      SrcPortNumber = ['"id.orig_p"'],
      DstIpAddr = ['"id.resp_h"'],
      DstPortNumber = ['"id.resp_p"'],
      NetworkProtocol = ['"proto"'],
      NetworkApplicationProtocol = ['"service"'],
      NetworkDuration = ['"duration"'],
      SrcBytes = ['"orig_bytes"'],
      DstBytes = ['"resp_bytes"'],
      local_orig = ['"local_orig"'],
      local_resp = ['"local_resp"'],
      FlowMissedBytes = ['"missed_bytes"'],
      SrcPackets = ['"orig_pkts"'],
      DstPackets = ['"resp_pkts"'],
      SrcMacAddr = ['"orig_l2_addr"'],
      DstMacAddr = ['"resp_l2_addr"'],
      DstVlanId = ['"vlan"'],
      SrcVlanId = ['"inner_vlan"'],
      FlowHistory = ['"history"'],
      NetworkSessionId = ['"community_id'],
      Dvc = ['"_system_name"']
  | extend 
    temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
    temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | project-away temp*
  | where ASimMatchingIpAddr != "No match"
  | lookup NetworkDirectionLookup on local_orig, local_resp
  | extend
      NetworkBytes = SrcBytes + DstBytes,
      NetworkPackets = SrcPackets + DstPackets,
      NetworkProtocol = toupper(NetworkProtocol)
  // Aliases
  | extend 
      IpAddr=SrcIpAddr,
      Src=SrcIpAddr,
      Duration=NetworkDuration,
      SessionId = NetworkSessionId,
      InnerVlanId = SrcVlanId,
      OuterVlanId = DstVlanId,
      Dst=DstIpAddr
  | project-away Message, local_orig, local_resp, conn_state
};
parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionCrowdStrikeFalconHost
// Description: This ASIM parser supports normalizing CrowdStrike Falcon Endpoint Protection logs to the ASIM Network Session normalized schema. These events are captured through CrowdStrike Falcon Endpoint Protection data connector which allows you to easily connect your CrowdStrike Falcon Event Stream with Microsoft Sentinel.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCrowdStrikeFalconHost(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
[
    "0", "Informational",
    "1", "Informational",
    "2", "Low",
    "3", "Medium",
    "4", "High",
    "5", "High"
];
let EventFieldsLookup = datatable (
    ruleAction: int,
    DvcOriginalAction: string,
    DvcAction: string,
    EventResult: string
)
[
    0, "invalid", "Deny", "Failure",
    1, "allowed", "Allow", "Success",
    2, "blocked", "Deny", "Failure"
];
//ActionLokkup is prepapred by considering facts as below:
//Response bit: KILL PROCESS, modifier bit: '', DvcAction: Deny
//Response bit: KILL PROCESS, modifier bit: POLICY_DISABLED, DvcAction: Allow as here process would have been killed or blocked if policy was enabled so current event is not killed.
let ActionLookup = datatable (
    EventOutcome: string,
    DvcOriginalAction: string,
    DvcAction: string,
    EventResult: string
)
[
    "0", "Detection", "Allow", "Success",
    "2", "Detection", "Allow", "Success",
    "16", "Prevention-killed", "Deny", "Failure",
    "128", "Quarantine", "Allow", "Success",
    "144", "Prevention-killed,quarantine", "Deny", "Failure",
    "272", "Detection", "Allow", "Success",
    "400", "Detection-quarantine", "Allow", "Success",
    "512", "Prevention-killed", "Deny", "Failure",
    "640", "Prevention-killed,quarantine", "Deny", "Failure",
    "768", "Detection", "Allow", "Success", 
    "1024", "Prevention-blocked", "Deny", "Failure",
    "1040", "Prevention-killed,blocked", "Deny", "Failure",
    "1152", "Prevention-blocked,quarantine", "Deny", "Failure",
    "1168", "Prevention-killed,blocked,quarnatine", "Deny", "Failure",
    "1280", "Detection", "Allow", "Success",
    "1296", "Detection", "Allow", "Success",
    "2048", "Prevention-blocked", "Deny", "Failure",
    "2176", "Prevention-quarantine,blocked ", "Deny", "Failure",
    "2304", "Detection", "Allow", "Success",
    "2432", "Detection-quarantine", "Allow", "Success",
    "4096", "Prevention-blocked", "Deny", "Failure",
    "4112", "Prevention-blocked,killed", "Deny", "Failure",
    "4224", "Prevention-blocked,quarantine", "Deny", "Failure",
    "4240", "Prevention-killed,blocked,quarantine", "Deny", "Failure",
    "4352", "Detection", "Allow", "Success",
    "4368", "Detection", "Allow", "Success",
    "4638", "Detection", "Allow", "Success",
    "5120", "Prevention-blocked", "Deny", "Failure",
    "8192", "Disabled", "Allow", "Success",
    "8208", "Detection", "Allow", "Success",
    "8320", "Detection-quarnatine", "Allow", "Success",
    "8704", "Detection", "Allow", "Success",
    "9216", "Detection", "Allow", "Success",
    "10240", "Detection", "Allow", "Success",
    "12304", "Detection", "Allow", "Success",
    "16400", "Killed", "Deny", "Failure",
    "32768", "Prevention-blocked", "Deny", "Failure",
    "32896", "Prevention-blocked,quarantine", "Deny", "Failure",
    "33024", "Detection", "Allow", "Success",
    "65536", "Downgraded", "Allow", "Success",
    "65552", "Prevention-killed", "Deny", "Failure",
    "65792", "Detection-downgraded", "Allow", "Success",
    "65808", "Detection-downgraded", "Allow", "Success",
    "73728", "Detection-downgraded", "Allow", "Success",
    "73744", "Detection-downgraded", "Allow", "Success",
    "131088", "Prevention-killed", "Deny", "Failure",
    "131216", "Prevention-killed,quarantine", "Deny", "Failure",
    "131584", "Prevention-killed", "Deny", "Failure",
    "131712", "Prevention-killed,quarantine", "Deny", "Failure",
    "2099200", "Prevention-blocked", "Deny", "Failure",
    "2099328", "Prevention-blocked,quarantine", "Deny", "Failure",
    "4196352", "Prevention-blocked", "Deny", "Failure",
    "4196480", "Prevention-blocked,quarantine", "Deny", "Failure",
    "1048576", "Prevention-suspend", "Deny", "Failure",
    "524288", "Prevention-suspend", "Deny", "Failure",
    "262144", "Blocking Disabled", "Allow", "Success",
    "16384", "Safeguard Enabled", "Allow", "Success",
    "131072", "Kill Failed", "Deny", "Failure",
    "256", "Policy Disabled", "Allow", "Success",
    "2097152", "Response Action Already Applied", "Deny", "Failure",
    "4194304", "Response Failed", "Deny", "Failure"
];
let parser = (starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]), 
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]), 
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let alldata = CommonSecurityLog
        | where not(disabled)
            and (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime)
        | where DeviceVendor == "CrowdStrike" and DeviceProduct == "FalconHost"
        | where DeviceEventClassID in ("Network Access In A Detection Summary Event", "FirewallMatchEvent")
        | where (array_length(hostname_has_any) == 0 or DestinationHostName has_any (hostname_has_any))
            and (isnull(dstportnumber) or (DestinationPort == dstportnumber) or (AdditionalExtensions has tostring(dstportnumber)))
    ;
    let firewalldata = alldata
        | where DeviceEventClassID == "FirewallMatchEvent"
        | parse-kv AdditionalExtensions as (deviceId: string, cmdLine: string, connectionDirection: int, eventType: string, hostName: string, icmpCode: int, icmpType: string, localAddress: string, localPort: int, matchCount: int, networkProfile: string, protocol: int, remoteAddress: string, remotePort: int, ruleAction: int, ruleDescription: string, ruleGroupName: string, ruleName: string, status: string) with (pair_delimiter=";", kv_delimiter="=")
        | lookup EventFieldsLookup on ruleAction
        | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
        | where ((eventresult == "*") or EventResult == eventresult)
        | extend
            EventCount = matchCount,
            EventStartTime = unixtime_milliseconds_todatetime(tolong(ReceiptTime)),
            NetworkDirection = case(
                      connectionDirection == 1, "Inbound",
                      connectionDirection == 2, "Outbound",
                      ""
                  ),
              SrcIpAddr = case(
                  connectionDirection == 1, remoteAddress,
                  connectionDirection == 2, localAddress,
                  ""
              ),
              SrcPortNumber = case(
                      connectionDirection == 1, remotePort,
                      connectionDirection == 2, localPort,
                      int(null)
                  ),
              DstIpAddr = case(
                  connectionDirection == 1, remoteAddress,
                  connectionDirection == 2, localAddress,
                  ""
              ),
              DstPortNumber = case(
                      connectionDirection == 1, localPort,
                      connectionDirection == 2, remotePort,
                      int(null)
                  )
        | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))
        | extend
            temp_isSrcMatch = has_any_ipv4_prefix(SrcIpAddr, src_or_any), 
            temp_isDstMatch = has_any_ipv4_prefix(DstIpAddr, dst_or_any)
        | extend ASimMatchingIpAddr = case(
                                  array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                  "-", 
                                  (temp_isSrcMatch and temp_isDstMatch),
                                  "Both", 
                                  temp_isSrcMatch,
                                  "SrcIpAddr",
                                  temp_isDstMatch,
                                  "DstIpAddr",
                                  "No match" 
                              )        
        | where ASimMatchingIpAddr != "No match"
        | extend deviceIp = iff(hostName matches regex "(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))", hostName, "")
        | extend 
            hostName = iff(isempty(deviceIp), hostName, ""),
            AdditionalFields = bag_pack(
                      "networkProfile", networkProfile,
                      "ruleDescription", ruleDescription,
                      "ruleGroupName", ruleGroupName,
                      "cmdLine", cmdLine
                  ),
            NetworkIcmpCode = icmpCode
        | invoke _ASIM_ResolveDvcFQDN('hostName')
        | invoke _ASIM_ResolveNetworkProtocol('protocol')
        | extend NetworkIcmpType = _ASIM_LookupICMPType('icmpType')
        | project-rename
            DvcId = deviceId,
            DvcIpAddr = deviceIp,
            EventOriginalSubType = eventType,
            NetworkRuleName = ruleName
        | extend
            Rule = NetworkRuleName,
            Dvc = coalesce(DvcId, DvcHostname, DvcIpAddr);
    let networkaccessdata = alldata
        | where DeviceEventClassID has "Network Access In A Detection Summary Event"
        | lookup ActionLookup on EventOutcome
        | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
        | where ((eventresult == "*") or EventResult == eventresult)
        | extend
            temp_isSrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any), 
            temp_isDstMatch = has_any_ipv4_prefix(DestinationIP, dst_or_any)
        | extend ASimMatchingIpAddr = case(
                                  array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                  "-", 
                                  (temp_isSrcMatch and temp_isDstMatch),
                                  "Both", 
                                  temp_isSrcMatch,
                                  "SrcIpAddr",
                                  temp_isDstMatch,
                                  "DstIpAddr",
                                  "No match" 
                              )        
        | where ASimMatchingIpAddr != "No match"
        | parse-kv AdditionalExtensions as (CSMTRPatternDisposition: string, tactic: string, technique: string, objective: string) with (pair_delimiter=";", kv_delimiter="=")
        | invoke _ASIM_ResolveSrcFQDN('DestinationHostName')
        | extend ASimMatchingHostname = case(
                                    array_length(hostname_has_any) == 0,
                                    "-",
                                    SrcHostname has_any (hostname_has_any),
                                    "SrcHostname",
                                    "No match"
                                )
        | where ASimMatchingHostname != "No match"
        | extend
            EventStartTime = todatetime(DeviceCustomDate1),
            DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
            SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
            EventCount = int(1),
            SrcDomain = coalesce(SrcDomain, DestinationNTDomain),
            EventOriginalResultDetails = CSMTRPatternDisposition,
            SrcProcessId = tostring(FieldDeviceCustomNumber2),
            SrcDomainType = iff(isnotempty(DestinationNTDomain), "Windows", SrcDomainType),
            AdditionalFields = bag_pack(
                      "CSMTRPatternDisposition", CSMTRPatternDisposition, 
                      "Tactic", coalesce(tactic, Activity),
                      "Technique", coalesce(technique, DeviceAction),
                      "Objective", coalesce(objective, Reason),
                      DeviceCustomString6Label, DeviceCustomString6
                  )
        | project-rename
            DvcId = ExtID,
            DstPortNumber = DestinationPort,
            SrcPortNumber = SourcePort,
            SrcMacAddr = SourceMACAddress,
            SrcUsername = DestinationUserName,
            SrcProcessName = FileName
        | extend
            Dvc = DvcId,
            Hostname = SrcHostname,
            User = SrcUsername,
            SrcAppId = SrcProcessId,
            SrcAppName = SrcProcessName,
            SrcAppType = "Process",
            SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
            SrcUsernameType = _ASIM_GetUsernameType(SrcUsername);
    union firewalldata, networkaccessdata
    | lookup EventSeverityLookup on LogSeverity
    | extend NetworkProtocolVersion = case(
                                      DstIpAddr contains ".", "IPv4",
                                      DstIpAddr contains ":", "IPv6",
                                      ""
                                  )
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventVendor = "CrowdStrike",
        EventProduct = "FalconHost",
        EventType = "EndpointNetworkSession"
    | project-rename
        EventOriginalType = DeviceEventClassID,
        EventProductVersion = DeviceVersion,
        EventUid = _ItemId,
        EventOriginalSeverity= LogSeverity
    | extend
        EventEndTime = EventStartTime,
        Dst = DstIpAddr,
        Src = coalesce(SrcFQDN, SrcHostname, SrcIpAddr),
        IpAddr = SrcIpAddr,
        DvcIdType = iff(isnotempty(DvcId), "Other", "")
    | project-away 
        Source*,
        Destination*,
        Device*,
        AdditionalExtensions,
        CommunicationDirection,
        Computer,
        EndTime,
        FieldDevice*,
        Flex*,
        File*,
        Old*,
        MaliciousIP*,
        OriginalLogSeverity,
        Process*,
        Protocol,
        Activity,
        ReceivedBytes,
        SentBytes,
        Remote*,
        Request*,
        SimplifiedDeviceAction,
        StartTime,
        TenantId,
        Threat*,
        ExternalID,
        ReportReferenceLink,
        ReceiptTime,
        Reason,
        ApplicationProtocol,
        _ResourceId,
        ExtID,
        Message,
        EventOutcome,
        IndicatorThreatType,
        cmdLine,
        connectionDirection,
        hostName,
        matchCount,
        networkProfile,
        protocol,
        ruleAction,
        ruleDescription,
        ruleGroupName,
        icmpCode,
        icmpType,
        status,
        CSMTRPatternDisposition,
        temp_*,
        NetworkProtocolNumber,
        localAddress,
        localPort,
        remoteAddress,
        remotePort
};
parser(
    starttime=starttime, 
    endtime=endtime,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber, 
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction, 
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionEmpty
// Description: This function returns an empty ASIM Network Session schema 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionEmpty
{
let parser=datatable(
   TimeGenerated:datetime
 , _ResourceId:string
 , Type:string
 // -- Event Fields
 , EventMessage:string // Optional
 , EventCount:int // Mandatory
 , EventStartTime:datetime // Mandatory
 , EventEndTime:datetime // Alias
 , EventType:string // Mandatory
 , EventSubType:string // Optional
 , EventResult:string // Mandatory
 , EventResultDetails:string // Optional
 , EventOriginalResultDetails:string // Optional
 , EventSeverity:string // Mandatory
 , EventOriginalSeverity:string // Optional
 , EventOriginalUid:string // Optional
 , EventOriginalType:string // Optional
 , EventOriginalSubType:string // Optional
 , EventProduct:string // Mandatory
 , EventProductVersion:string // Optional
 , EventVendor:string // Mandatory
 , EventSchema:string // Mandatory
 , EventSchemaVersion:string // Mandatory
 , EventReportUrl:string // Mandatory
 , Dvc:string // Alias
 , DvcIpAddr:string // Mandatory
 , DvcHostname:string // Mandatory
 , DvcDomain:string // Recommended
 , DvcDomainType:string // Recommended
 , DvcFQDN:string // Optional
 , DvcId:string // Optional
 , DvcIdType:string // Optional
 , DvcMacAddr:string // Optional
 , DvcZone:string // Optional
 , DvcDescription:string // Optional
 // -- Network Session Fields
 , Dst:string // Alias
 , DstIpAddr:string // Recommended
 , DstPortNumber:int // Optional
 , DstHostname:string // Recommended
 , Hostname:string // Alias
 , DstDescription:string // Optional
 , DstDomain:string // Recommended
 , DstDomainType:string // Recommended
 , DstFQDN:string // Optional
 , DstDvcId:string // Optional
 , DstDvcIdType:string // Optional
 , DstDeviceType:string // Optional
 , DstUserId:string // Optional
 , DstUserIdType:string // Optional
 , DstUsername:string // Optional
 , User:string // Alias
 , DstUsernameType:string // Alias
 , DstUserType:string // Optional
 , DstOriginalUserType:string // Optional
 , DstUserDomain:string // Optional
 , DstAppName:string // Optional
 , DstAppId:string // Optional
 , DstAppType:string // Optional
 , DstZone:string // Optional
 , DstInterfaceName:string // Optional
 , DstInterfaceGuid:string // Optional
 , DstMacAddr:string // Optional
 , DstGeoCountry:string // Optional
 , DstGeoRegion: string // Optional
 , DstGeoCity:string // Optional
 , DstGeoLatitude:real // Optional
 , DstGeoLongitude:real // Optional
 , Src:string // Alias
 , SrcIpAddr:string // Recommended
 , SrcPortNumber:int // Optional
 , SrcHostname:string // Recommended
 , SrcDescription:string // Optional
 , SrcDomain:string // Recommended
 , SrcDomainType:string // Recommended
 , SrcFQDN:string // Optional
 , SrcDvcId:string // Optional
 , SrcDvcIdType:string // Optional
 , SrcDeviceType:string // Optional
 , SrcUserId:string // Optional
 , SrcUserIdType:string // Optional
 , SrcUsername:string // Optional
 , SrcUsernameType:string // Alias
 , SrcUserType:string // Optional
 , SrcOriginalUserType:string // Optional
 , SrcUserDomain:string // Optional
 , SrcAppName:string // Optional
 , SrcAppId:string // Optional
 , IpAddr:string // Alias
 , SrcAppType:string // Optional
 , SrcZone:string // Optional
 , SrcInterfaceName:string // Optional
 , SrcInterfaceGuid:string // Optional
 , SrcMacAddr:string // Optional
 , SrcGeoCountry:string // Optional
 , SrcGeoCity:string // Optional
 , SrcGeoRegion: string // Optional 
 , SrcGeoLatitude:real // Optional
 , SrcGeoLongitude:real // Optional
 , NetworkApplicationProtocol:string // Optional
 , NetworkProtocol:string // Optional
 , NetworkProtocolVersion:string // Optional
 , NetworkDirection:string // Optional
 , NetworkDuration:int // Optional
 , Duration:int // Alias
 , NetworkIcmpCode:int // Optional
 , NetworkIcmpType:string // Optional
 , DstBytes:long // Optional
 , SrcBytes:long // Optional
 , NetworkBytes:long // Optional
 , DstPackets:long // Optional
 , SrcPackets:long // Optional
 , NetworkPackets:long // Optional
 , NetworkSessionId:string // Optional
 , SessionId:string // Alias
 , NetworkConnectionHistory:string // Optional
 , SrcVlanId:string // Optional
 , DstVlanId:string // Alias
 , InnerVlanId:string // Optional
 , OuterVlanId: string // Alias
 // -- Intermediary device fields
 , DstNatIpAddr:string // Optional
 , DstNatPortNumber:int // Optional
 , SrcNatIpAddr:string // Optional
 , SrcNatPortNumber:int // Optional
 , DvcInboundInterface:string // Optional
 , DvcOutboundInterface:string // Optional
 , DvcInterface:string // Optional
 // -- Inspection fields
 , NetworkRuleName:string // Optional
 , NetworkRuleNumber:int // Optional
 , Rule:string // Optional
 , DvcAction:string // Optional
 , DvcOriginalAction:string // Optional
 , ThreatId:string // Optional
 , ThreatName:string // Optional
 , ThreatCategory:string // Optional
 , ThreatRiskLevel:int // Optional
 , ThreatOriginalRiskLevel:string // Optional
 , DvcSubscriptionId:string // Optional
 , SrcSubscriptionId:string // Optional
 , DstSubscriptionId:string // Optional 
 )[];
parser
}



//
// Function Name: vimNetworkSessionForcePointFirewall
// Description: This ASIM parser supports normalizing Force Point Firewall logs coming from CEF Data Connector to the ASIM Network Session normalized schema.ParserName: vimNetworkSessionForcePointFirewall

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionForcePointFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ApplicationProtocolLookup=datatable(ApplicationProtocol:string,NetworkApplicationProtocol:string)
   [
         "HTTPS","HTTPS",
         "HTTP-Over-QUIC","HTTP",
         "HTTP","HTTP",
         "DNS Over TLS","DNS",
         "HTTP proxy","HTTP",
         "IMAPS","IMAPS",
         "SMTP","SMTP",
         "IMAP","IMAP",
         "POP3S","POP3",
         "SMTP Submission Service","SMTP",
         "X11","X11",
         "RTSP","RTSP",
         "Telnet","TELNET",
         "NNTP","NNTP",
         "ISAKMP","ISAKMP","ISAKMP","ISAKMP",
         "POP3","POP3",
         "BGP","BGP",
         "FTP","FTP",
         "RIP","RIP",
         "Squid HTTP proxy","HTTP",
         "TFTP","TFTP",
         "QOTD","QOTD",
         "SCCP","SCCP",
         "Modbus","MODBUS",
         "SVN","SVN",
         "RADIUS (Accounting)","RADIUS",
         "Kerberos","KERBEROS",
         "GRE","GRE",
         "UUCP-rlogin","UUCP",
         "GTP User Data Tunneling","GTP",
         "NNTPS","NNTP",
         "GTP Control","GTP",
         "IRC-default","IRC",
         "FTPS (Control)","FTPS",
         "ICCP","ICCP",
         "IRCS","IRC",
         "Telnets","TELNET",
         "Finger","FINGER",
         "ESP","ESP",
         "Rlogin","RLP",
         "IMAP3","IMAP",
         "MGCP","MGCP",
         "RADIUS Accounting (Old)","RADIUS",
         "RADIUS (Old)","RADIUS",
         "CVS","CVS",
         "Ident","IDENT",
         "Gopher","GOPHER",
         "BGMP","BGMP",
         "FTPS (Data)","FTPS",
         "POP2","POP",
         "TLISRV","TLISRV",
         "INGRES-NET","INGRES-NET",
         "IPIP","IPIP",
         "XTP","XTP",
         "UUCP","UUCP",
         "IRC","IRC",
         "Photuris (ICMP)","ICMP",
         "TACACS-DS","TACACS-DS",
         "WESP","WESP",
         "EGP","EGP",
         "WSN","WSN",
         "XDMCP","XDMCP",
         "Kerberos IV","KERBEROS",
         "IRTP","IRTP",
         "TTP","TTP",
         "IRC-SERV","IRC",
         "I-NLSP","NLSP",
         "SNP","SNP",
         "XNS-IDP","XNS",
         "SECURE-VMTP","VMTP",
         "VMTP","VMTP",
         "IPLT","IPLT",
         "GGP","GGP",
         "MFE-NSP","NSP",
         "HIP","HIP",
         "MERIT-NSP","NSP",
         "NSFNET-IGP","IGP",
         "DCN-MEAS","DCN",
         "STP","STP",
         "SRP","SRP",
         "HMP","HMP",
         "XNET","XNET",
         "VRRP","VRRP",
         "ENCAP","ENCAP",
         "CPNX","CPNX",
         "PTP","PTP",
         "SKIP","SKIP",
         "SCPS","SCPS",
         "Sprite-RPC","RPC",
         "IPv6 ICMP","ICMP",
         "MUX","MUX",
         "CHAOS","CHAOS",
         "SSCOPMCE","SSCOPMCE",
         "CBT","CBT",
         "SPS","SPS",
         "ETHERIP","ETHERIP",
         "MTP","MTP",
         "ROHC","ROHC",
         "CRTP","CRTP",
         "PNNI","PNNI",
         "NETBLT","NETBLT",
         "TLSP","TLSP",
         "IDPR","IDPR",
         "DDX","DDX",
         "PUP","PUP",
         "DSR","DSR",
         "NARP","NARP",
         "CPHB","CPHB",
         "SMP","SMP",
         "L2TP","L2TP",
         "IPv6 ICMP/143/0","ICMP",
         "MICP","MICP",
         "GMTP","GMTP",
         "LARP","LARP",
         "IFMP","IFMP",
         "IGP","IGP",
         "CFTP","CFTP",
         "PGM","PGM",
         "DDP","DDP",
         "PIPE","PIPE",
         "IATP","IATP",
         "IGMP","IGMP",
         "3PC","3PC",
         "DGP","DGP",
         "TCF","TCF",
         "UTI","UTI",
         "DCCP","DCCP",
         "SWIPE","SWIPE",
         "EMCON","EMCON",
         "PIM","PIM",
         "RVD","RVD",
   ];
 let ActionLookup=datatable(DeviceAction:string,DvcAction_ActionLookup:string,EventResult_ActionLookup:string,EventSeverity_ActionLookup:string)
 [
           "Allow","Allow","Success","Informational",          
           "Discard","Drop","Failure","Low",
           "Permit","Allow","Success","Informational",          
           "Refuse","Deny","Failure","Low",
           "Terminate","Reset Source","Failure","Low",          
           "Terminate (failed)","","Failure","Low",
           "Terminate (passive)","Reset Destination","Failure","Low",          
           "Terminate (reset)","Reset","Failure","Low",
           "Wait for Authentication","","Success","Informational",
           "Wait for Further Actions","","Success","Informational",          
           "Wait for RPC Reply","","Success","Informational"
 ];
 let DeviceEventClassIDLookup_Packet=datatable(DeviceEventClassID:string,EventSubType:string,DvcAction_DeviceEventClassIDLookup:string,EventResult_DeviceEventClassIDLookup:string,EventSeverity_DeviceEventClassIDLookup:string) //Add more codes if needed
 [
           "70018","Start","Allow","Success","Informational", // Connection_Allowed
           "70019","End","Deny","Failure","Low", // Connection_Discarded
           "70021","End","Reset","Failure","Low", // Connection_Closed
           "70022","End","Reset","Failure","Low", // Connection_Closed-Abnormally
           "70026","","","Success","Informational", // Connection_Progress
 ];
 let DeviceEventClassIDLookup_File=datatable(DeviceEventClassID:string,DvcAction_DeviceEventClassIDLookup:string,EventResult_DeviceEventClassIDLookup:string,EventSeverity_DeviceEventClassIDLookup:string)
 [
           "76506","Allow","Success","Informational", // File_Allowed
           "76508","Deny","Failure","Low", // File_Malware-Blocked
           "76509","","Failure","Low" // File_Malware-Detected
 ];
 let MessageLookup = datatable (Message:string, DvcAction_MessageLookup:string, EventResult_MessageLookup:string, EventResultDetails:string, EventOriginalResultDetails:string)  
 [
         "Connection dropped", "Drop", "Failure","Terminated", "Connection dropped",
         "Connection removed because NGFW Engine is low on memory.","Drop", "Failure","Terminated","Connection removed because NGFW Engine is low on memory.",
         "Connection timeout in state TCP_CLOSE_WAIT", "", "Success", "Timeout",	"One end of the Connection waits for the FIN packet (passive close).",
         "Connection timeout in state TCP_CLOSE_WAIT_ACK", "", "Success", "Timeout", "One end of the Connection waits for the FIN packet (passive close)",
         "Connection timeout in state TCP_CLOSING", "", "Success", "Timeout", "Closing packet (FIN) sent by one end of the Connection (simultaneous).",
         "Connection timeout in state TCP_CLOSING_ACK", "", "Success", "Timeout", "Waiting for ACK for the FIN before going to closing status (active close).",
         "Connection timeout in state TCP_ESTABLISHED", "", "Failure", "Timeout", "Normal status of TCP Connections for data transfer.",
         "Connection timeout in state TCP_FIN_WAIT_1", "", "Success", "Timeout",	"One end of the Connection waits for sending the FIN packet (active close).",
         "Connection timeout in state TCP_FIN_WAIT_2", "", "Success", "Timeout", "One end of the Connection waits for receiving ACK packet.",
         "Connection timeout in state TCP_LAST_ACK", "",	"Success", "Timeout", "One end of the Connection sent a FIN packet (passive close).",
         "Connection timeout in state TCP_LAST_ACK_WAIT", "", "Failure",	"Timeout", "Waiting for the FIN packet to be acknowledged.",
         "Connection timeout in state TCP_SYN_ACK_SEEN", "", "Failure",	"Timeout", "Second phase of the TCP three-way handshake, the server has replied to client sent SYN with SYN+ACK, next status will be established.",
         "Connection timeout in state TCP_SYN_FIN_SEEN", "",	"Success", "Timeout", "T/TCP (Transactional TCP) Connection, RFC 1644.",
         "Connection timeout in state TCP_SYN_RETURN", "", "Failure", "Timeout", "Received simultaneous SYN from the other end (simultaneous open).",
         "Connection timeout in state TCP_SYN_SEEN", "", "Failure", "Timeout", "First packet sent by one end of the Connection.",
         "Connection timeout in state TCP_TIME_WAIT", "", "Success", "Timeout", "One end of the Connection acknowledged closing packet (FIN).",
         "Connection timeout in state TCP_TIME_WAIT_ACK", "", "Failure",	"Timeout", "Waiting for ACK for the FIN status before going to time wait status (active close).",
         "Connection timeout in state ICMP_ECHO", "", "Failure", "Timeout", "Ping reply is expected.",
         "Connection timeout in state ICMP_REPLY_WAIT", "", "Failure", "Timeout", "Other ICMP request or reply types.",
         "Connection was reset by client", "Reset Source", "Failure","Reset", "",
         "Connection was reset by server", "Reset Destination", "Failure","Reset", "",
         "invalid packet (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [A] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [FA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [FPA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [PA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [RA] (CT)", "", "Failure", "Invalid TCP", "",
         "not a (valid) SYN packet [SA] (CT)", "", "Failure", "Invalid TCP", "",
         "TCP state violation","Deny","Failure", "Invalid TCP", "",
         "TCP state violation: Connection end-point replied with ACK to SYN-packet. Connection refused.", "Deny", "Failure", "Invalid TCP", "",
         "TSC error: Query timed out", "", "Failure", "Timeout", ""
 ];
 let parser = (
     starttime:datetime=datetime(null), 
     endtime:datetime=datetime(null), 
     srcipaddr_has_any_prefix:dynamic=dynamic([]), 
     dstipaddr_has_any_prefix:dynamic=dynamic([]), 
     ipaddr_has_any_prefix:dynamic=dynamic([]),
     dstportnumber:int=int(null), 
     hostname_has_any:dynamic=dynamic([]), 
     dvcaction:dynamic=dynamic([]), 
     eventresult:string='*', 
     disabled:bool=false) {
 let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
 let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
 let prefilter = (T:(DestinationPort:int,ApplicationProtocol:string,SourceIP:string,DestinationIP:string,AdditionalExtensions:string)) {
     T
     | where (isnull(dstportnumber) or (DestinationPort == dstportnumber) or (ApplicationProtocol has tostring(dstportnumber)))
     | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), 
              temp_isDstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
     | extend ASimMatchingIpAddr = case(
                     array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                     (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                     temp_isSrcMatch, "SrcIpAddr",
                     temp_isDstMatch, "DstIpAddr",
                     "No match"
                 )
     | where ASimMatchingIpAddr != "No match"
     | where array_length(hostname_has_any) == 0 or AdditionalExtensions has_any (hostname_has_any)
 };
 let ForcePointNetwork = CommonSecurityLog
         | where not(disabled)
         | where (isnull(starttime) or TimeGenerated >= starttime) 
             and (isnull(endtime) or TimeGenerated <= endtime)
         | where DeviceVendor=="FORCEPOINT" and DeviceProduct=="Firewall"
         | where DeviceFacility in~ ("Inspection","Packet Filtering","File Filtering") and isnotempty(DeviceEventClassID) and DeviceEventClassID != "0"
         ;
 let PacketFilteringData = ForcePointNetwork
         | where DeviceFacility == "Packet Filtering" and DeviceEventClassID !in ("70383","70393","70734","71009","71040")
         | invoke prefilter()
         | lookup DeviceEventClassIDLookup_Packet on DeviceEventClassID
         | lookup MessageLookup on Message
         | extend DvcAction = coalesce(DvcAction_MessageLookup, DvcAction_DeviceEventClassIDLookup), 
                  EventResult = case (Message startswith "Referred connection not known", "Failure",
                                     coalesce(EventResult_MessageLookup, EventResult_DeviceEventClassIDLookup)), 
                  EventSeverity = case(Message startswith "Referred connection not known", "Low",
                                     EventSeverity_DeviceEventClassIDLookup),
                  EventOriginalResultDetails = case(Message startswith "Referred connection not known", Message,
                                                 EventOriginalResultDetails),
                 EventType = "NetworkSession"
         | project-away DvcAction_*, EventResult_*, EventSeverity_DeviceEventClassIDLookup;
 let FileFilteringData = ForcePointNetwork
         | where DeviceFacility == "File Filtering"
         | invoke prefilter()
         | lookup DeviceEventClassIDLookup_File on DeviceEventClassID
         | extend ThreatName = case (DeviceEventClassID in ("76508", "76509"), Activity,
                                     "")
         | project-rename DvcAction = DvcAction_DeviceEventClassIDLookup
         | extend EventResult = case(isnotempty(Message), "Failure",
                                     EventResult_DeviceEventClassIDLookup), 
                  EventSeverity = case(isnotempty(Message), "Low",
                                     EventSeverity_DeviceEventClassIDLookup),
                  EventOriginalResultDetails = case(isnotempty(Message), Message,
                                                 ""),
                 EventType = "NetworkSession"
         | project-away *_DeviceEventClassIDLookup;
 let InspectionData = ForcePointNetwork
         | where DeviceFacility == "Inspection" or DeviceEventClassID == "70734"
         | invoke prefilter()
         | extend MessageCode = toint(DeviceEventClassID)
         | extend EventSeverity = case (DeviceAction in~ ("Allow","Permit"), "Informational",
                                     MessageCode >= 200000, "High",
                                     MessageCode < 200000, "Low",
                                     ""),
                  EventType = case (MessageCode < 80000, "NetworkSession",
                                  "IDS")
         | extend ThreatName = Activity
         | project-away MessageCode;
 union PacketFilteringData, FileFilteringData, InspectionData
         | extend NetworkProtocol = _ASIM_LookupNetworkProtocol(Protocol)
         | lookup ActionLookup on DeviceAction
         | extend DvcAction = coalesce(DvcAction,DvcAction_ActionLookup), 
                  EventResult = coalesce(EventResult,EventResult_ActionLookup), 
                  EventSeverity = coalesce(EventSeverity, EventSeverity_ActionLookup)
         | project-away *_ActionLookup
         | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
         | where ((eventresult == "*") or (EventResult == eventresult))
         | lookup ApplicationProtocolLookup on ApplicationProtocol
         | extend 
                 EventCount = toint(1),
                 EventSchema = "NetworkSession",
                 EventSchemaVersion = "0.2.6",
                 EventVendor = "Forcepoint",
                 EventProduct = "Firewall"
         | parse AdditionalExtensions with * "requestURL=" requestURL            
         | project-rename
                 EventOriginalType = DeviceEventClassID,
                 DstPortNumber = DestinationPort,
                 DstIpAddr = DestinationIP,
                 SrcPortNumber = SourcePort,
                 SrcIpAddr = SourceIP,
                 DstNatIpAddr = DestinationTranslatedAddress,
                 DstNatPortNumber = DestinationTranslatedPort,
                 SrcNatIpAddr = SourceTranslatedAddress,
                 SrcNatPortNumber = SourceTranslatedPort,
                 EventProductVersion = DeviceVersion,
                 EventMessage = Message,
                 DvcOriginalAction = DeviceAction,
                 SrcBytes = SentBytes,
                 DstBytes = ReceivedBytes,
                 EventOriginalSubType = DeviceFacility,
                 DvcId = DeviceExternalID,
                 DvcInboundInterface = DeviceInboundInterface,
                 DvcOutboundInterface = DeviceOutboundInterface,
                 DvcIpAddr = DeviceAddress,
                 EventOriginalSeverity = LogSeverity,
                 ThreatId = DeviceCustomString3
         | invoke _ASIM_ResolveDvcFQDN('Computer')
         | extend
                 ThreatCategory = column_ifexists("DeviceEventCategory",""),
                 EventStartTime = todatetime(ReceiptTime),
                 EventEndTime = todatetime(ReceiptTime),
                 ipv6_parts = extract_all (@'^\[(.+)\](?:\:(\d+))?$',requestURL)[0],
                 ipv4_parts = extract_all (@'^(\d+\.\d+\.\d+\.\d+)(?:\:(\d+))?$',requestURL)[0],
                 host_parts = extract_all (@'^([^\\\d:]+)(?:\:(\d+))?$',requestURL)[0]
         | extend 
                  NetworkRuleName = case(isnotempty(DeviceCustomString2), strcat(DeviceCustomString1,',',DeviceCustomString2),
                                         DeviceCustomString1),
                  DstDomainPart = tostring(host_parts[0]),
                  DstIpAddr = coalesce(DstIpAddr, tostring(ipv4_parts[0]), tostring(ipv6_parts[0])),
                  DstPortNumber = coalesce(DstPortNumber, toint(host_parts[1]), toint(ipv4_parts[1]), toint(ipv6_parts[1]))
         | invoke _ASIM_ResolveDstFQDN('DstDomainPart')
         | extend ASimMatchingHostname = case(array_length(hostname_has_any) == 0 ,"-",
                                     DstHostname has_any (hostname_has_any), "DstHostname",
                                     "No match"
                                     )
         | where ASimMatchingHostname != "No match"
         | extend
                  DvcIdType = case(isnotempty(DvcId), "ForcepointId",
                                 ""),
                  DstPortNumber = case(
                                 isnotempty(DstPortNumber), DstPortNumber,
                                 ApplicationProtocol startswith "TCP", toint(split(ApplicationProtocol,'/')[1]),
                                 ApplicationProtocol startswith "UDP", toint(split(ApplicationProtocol,'/')[1]),
                                 int(null)),
                  AdditionalFields = pack(iff(isnotempty(RequestMethod) and RequestMethod != "UNKNOWN", "RequestMethod", ""),RequestMethod,
                                          iff(isnotempty(DeviceCustomString4),"VirusId",""),DeviceCustomString4),
                  DstAppName = case(DestinationServiceName in~ ("Generic-Web-HTTP","Application-Unknown","Unknown-Encrypted-Application"), "",
                                     DestinationServiceName),
                  DvcIpAddr = coalesce(DvcIpAddr,DeviceName)
         | extend
                 Dvc = DvcIpAddr,
                 IpAddr = SrcIpAddr,
                 Rule = NetworkRuleName,
                 Dst = DstIpAddr,
                 Src = SrcIpAddr,
                 DvcInterface = DvcInboundInterface,
                 Hostname = DstHostname
         | project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, Remote*, ReportReferenceLink, Request*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, ExtID, EventOutcome, FieldDevice*, Reason, ApplicationProtocol, Activity, requestURL, Computer, DstDomainPart, host_parts, ipv4_parts, ipv6_parts, temp_*
     };
     parser(starttime=starttime, 
             endtime=endtime, 
             srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
             dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
             ipaddr_has_any_prefix=ipaddr_has_any_prefix, 
             dstportnumber=dstportnumber, 
             hostname_has_any=hostname_has_any, 
             dvcaction=dvcaction, 
             eventresult=eventresult, 
             disabled=disabled)
}



//
// Function Name: vimNetworkSessionFortinetFortiGate
// Description: This ASIM parser supports filtering and normalizing Fortinet FortiGate logs produced by the Microsoft Sentinel Fortinet connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionFortinetFortiGate(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventLookup=datatable(DeviceAction:string,DvcAction:string,EventResult:string,EventResultDetails:string)
  [
    "accept","Allow","Success",""
    , "client-rst","Reset Source","Failure",""
    , "close","","Success",""
    , "deny","Deny","Failure",""
    , "ip-conn","","Failure","IP connection error"
    , "server-rst","Reset Destination","Failure",""
    , "timeout","","Failure",""
  ];
  // -- See https://docs.fortinet.com/document/fortigate/7.2.4/fortios-log-message-reference/671442/cef-priority-levels
  let SeverityLookup = datatable (EventOriginalSeverity:string, EventSeverity:string)
  [
    "1", "Informational", // Debug
    "2", "Informational", // Information
    "3", "Informational", // Notification
    "4", "Low", // Warning
    "5", "Low", // Error
    "6", "Critical", // High
    "7", "Alert", // Medium
    "8", "High" // Emergency
  ];
  let Parser=(starttime:datetime=datetime(null), endtime:datetime=datetime(null), srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]), dstportnumber:int=int(null), hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]), eventresult:string='*', disabled:bool=false){
    let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    CommonSecurityLog
    | where not(disabled)
    | where (isnull(starttime) or TimeGenerated>=starttime) and (isnull(endtime) or TimeGenerated<=endtime)
    | where DeviceVendor == "Fortinet" and DeviceProduct startswith "FortiGate" and (column_ifexists("DeviceEventCategory","") has "traffic" or AdditionalExtensions has "cat=traffic")
    | where DeviceAction != "dns" and Activity !has "dns" 
    | where (array_length(hostname_has_any)==0)
    | where  (isnull(dstportnumber) or DestinationPort==dstportnumber)
    | extend temp_ResultMatch = case (
        eventresult=="*", true,
        (eventresult == "Success") and (DeviceAction in ("accept", "close") or Activity has_any ("accept", "close")), true,
        (eventresult == "Failure") and (DeviceAction !in ("accept", "close") and not(Activity has_any ("accept", "close"))), true,
        false
    )
    | where temp_ResultMatch
    | extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any)
      , temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
    | extend ASimMatchingIpAddr=case(
        array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
        temp_SrcMatch and temp_DstMatch, "Both",
        temp_SrcMatch, "SrcIpAddr",
        temp_DstMatch, "DstIpAddr",
        "No match"
    )
    | where ASimMatchingIpAddr != "No match" 
    | parse Activity with "traffic:forward " temp_DeviceAction:string 
    | extend DeviceAction = coalesce(DeviceAction, temp_DeviceAction)  
    | lookup EventLookup on DeviceAction 
    | where (array_length(dvcaction)==0 or DvcAction has_any (dvcaction))
    | project Activity,AdditionalExtensions,DestinationIP,DestinationPort,DeviceAction,DeviceInboundInterface,DeviceOutboundInterface,DeviceProduct,DeviceVersion,LogSeverity,Protocol,ReceivedBytes,SentBytes,SourceIP,SourcePort,TimeGenerated, DeviceExternalID, Type, _ItemId, Computer, EventResult, EventResultDetails, ASimMatchingIpAddr, DvcAction
    | project-rename DstBytes = ReceivedBytes
      , DstInterfaceName = DeviceOutboundInterface
      , DstIpAddr = DestinationIP
      , DstPortNumber = DestinationPort
      , Dvc = Computer
      , EventMessage = Activity
      , EventOriginalSeverity = LogSeverity
      , EventProduct = DeviceProduct
      , EventProductVersion = DeviceVersion
      , SrcBytes = SentBytes
      , SrcInterfaceName = DeviceInboundInterface
      , SrcIpAddr = SourceIP
      , SrcPortNumber = SourcePort
      , DvcId = DeviceExternalID
      , EventUid = _ItemId
    | invoke _ASIM_ResolveNetworkProtocol ('Protocol')
    | project-rename DvcOriginalAction = DeviceAction
    | parse-kv AdditionalExtensions as (
            FortinetFortiGatestart:datetime,
            FortinetFortiGatesrcintfrole:string,
            FortinetFortiGatedstintfrole:string,
            FortinetFortiGateexternalID:string,
            FortinetFortiGatepolicyid:int,
            FortinetFortiGatedstcountry:string,
            FortinetFortiGatesrccountry:string,
            FortinetFortiGatecrscore:string,
            FortinetFortiGateduration:int,
            FortinetFortiGatesentpkt:long,
            FortinetFortiGatercvdpkt:long
        ) with (pair_delimiter=';', kv_delimiter='=')
    | project-rename
        EventStartTime          = FortinetFortiGatestart,
        SrcZone                 = FortinetFortiGatesrcintfrole,
        DstZone                 = FortinetFortiGatedstintfrole,
        NetworkSessionId        = FortinetFortiGateexternalID,
        NetworkRuleNumber       = FortinetFortiGatepolicyid,
        NetworkDuration         = FortinetFortiGateduration,
        DstGeoCountry           = FortinetFortiGatedstcountry,
        SrcGeoCountry           = FortinetFortiGatesrccountry,
        ThreatOriginalRiskLevel = FortinetFortiGatecrscore,
        SrcPackets              = FortinetFortiGatesentpkt,
        DstPackets              = FortinetFortiGatercvdpkt
    | extend EventCount = int(1)
      , EventSchema = "NetworkSession"
      , EventSchemaVersion = "0.2.3"
      , EventType = "NetworkSession"
      , EventVendor = "Fortinet"
      , DvcIdType = "Other"
      , NetworkBytes = DstBytes + SrcBytes
      , EventEndTime = TimeGenerated
      , EventStartTime = coalesce(EventStartTime, TimeGenerated)
      , NetworkProtocolVersion = case(DstIpAddr contains ".", "IPv4"
          , DstIpAddr contains ":", "IPv6"
          , "")
      , NetworkPackets = DstPackets + SrcPackets
      | lookup SeverityLookup on EventOriginalSeverity
      | extend 
          Src = SrcIpAddr,
          Dst = DstIpAddr,
          SessionId = NetworkSessionId,
          IpAddr = SrcIpAddr,
          Duration = NetworkDuration,
          Rule = tostring(NetworkRuleNumber)
    | project-away Protocol, AdditionalExtensions, NetworkProtocolNumber
  };
  Parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionMD4IoTAgent
// Description: This ASIM parser supports filtering and normalizing Microsoft Defender for IoT micro agent logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMD4IoTAgent(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null), 
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false)
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let ip_any  =  set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix, srcipaddr_has_any_prefix); 
  let DirectionNetworkEvents =
  SecurityIoTRawEvent 
  | where (isnull(starttime) or TimeGenerated>=starttime) 
      and (isnull(endtime) or TimeGenerated<=endtime)
  | where not(disabled)
  | where RawEventName == "NetworkActivity"
  // ***************  Prefilterring *****************************************************************
  |where  (eventresult=='*' or eventresult=='Success')
      and (array_length(hostname_has_any)==0) 
      and (array_length(dvcaction) ==0  )     /// if filtered by action return nothing
      and EventDetails has tostring(dstportnumber)
      and (array_length (ip_any)==0 or has_any_ipv4_prefix(EventDetails,ip_any))
      // *************** Prefilterring *****************************************************************
  | parse EventDetails with * ',"LocalPort":' LocalPort:int ',"RemotePort":' RemotePort:int ',' *
  | extend outbound = LocalPort > RemotePort
  | where (isnull(dstportnumber) or (not(outbound) and dstportnumber == LocalPort) or (outbound and dstportnumber == RemotePort) ) 
  ;
  let parser = (T: (EventDetails: string)) {
    T 
    | parse EventDetails with 
      '{"LocalAddress":"' LocalAddress:string '",'
      '"RemoteAddress":"' RemoteAddress:string '",'
      *
      '"BytesIn":' BytesIn:long ','
      '"BytesOut":' BytesOut:long ','
      '"Protocol":"' Protocol:string '",'
      '"ProcessId":' ProcessId:string ','
      '"UserId":' UserId:string ','
      '"ApplicationProtocol":"' ApplicationProtocol:string '",'
      * // '"AzureResourceId":"' AzureResourceId:string '",'
      '"DeviceId":"' DeviceId:string '",'
      '"MessageSource":"' MessageSource:string '",'
      '"OriginalEventId":"' OriginalEventId:string '",'
      '"TimestampUTC":"' TimestampUTC:datetime '",'
      *
  }
  ; 
  let OutboundNetworkEvents = 
    DirectionNetworkEvents
    | where outbound
    // ***************  Postfilterring *****************************************************************
    | where (isnull(dstportnumber) or dstportnumber==LocalPort)
    // ***************  Postfilterring *****************************************************************
    | invoke parser ()
    | extend temp_isSrcMatch=has_any_ipv4_prefix(LocalAddress,src_or_any)
           , temp_isDstMatch=has_any_ipv4_prefix(RemoteAddress,dst_or_any)
    | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  ) 
  | where ASimMatchingIpAddr != "No match"
  | project-away temp_*
    | project-rename
      SrcBytes = BytesOut,
      DstBytes = BytesIn,
      SrcPortNumber = LocalPort,
      DstIpAddr = RemoteAddress,
      DstPortNumber = RemotePort,
      SrcProcessId = ProcessId
    | extend
      SrcIpAddr = LocalAddress,
      SrcDvcIdType = "MD4IoTid",
      SrcUserId = UserId,
      SrcUserIdType = "UID",
      SrcDvcId = DeviceId,
      Process = SrcProcessId, // alias
      SrcDvcOs = iif (MessageSource == "Linux", "Linux", "Windows")
  ;
  let InboundNetworkEvents = 
    DirectionNetworkEvents
    | where not(outbound)
    // ***************  Postfilterring *****************************************************************
    | where (isnull(dstportnumber) or dstportnumber==RemotePort)
    // ***************  Postfilterring *****************************************************************
    | invoke parser ()
    | extend temp_isSrcMatch=( // only one of each pair has_any_ipv4_prefix is calculated
                      has_any_ipv4_prefix(RemoteAddress,src_or_any)
                  ) 
         , temp_isDstMatch=(
                   has_any_ipv4_prefix(LocalAddress,dst_or_any) 
                  ) 
    | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  ) 
  | project-away temp_*
  | where ASimMatchingIpAddr != "No match"
    | project-rename
      DstBytes = BytesOut,
      SrcBytes = BytesIn,
      DstPortNumber = LocalPort,
      SrcIpAddr = RemoteAddress,
      SrcPortNumber = RemotePort,
      DstProcessId = ProcessId
    | extend
      DstIpAddr = LocalAddress,
      DstDvcIdType = "MD4IoTid",
      DstUserId = UserId,
      DstUserIdType = "UID",
      DstDvcId = DeviceId,
      Process = DstProcessId, // alias
      DstDvcOs = iif (MessageSource == "Linux", "Linux", "Windows")
  ;
  let NetworkSessionMD4IoT = 
    union InboundNetworkEvents, OutboundNetworkEvents
    | extend
      EventCount = int(1),
      EventProduct = 'Azure Defender for IoT', 
      EventVendor = 'Microsoft',
      EventSchemaVersion = '0.2.3',
      EventSchema = "NetworkSession", 
      EventType = 'NetworkSession',
      EventStartTime = TimeGenerated, 
      EventEndTime = TimeGenerated, 
      EventResult = 'Success',
      EventSeverity = 'Informational'
    | project-rename
      EventProductVersion = AgentVersion, // Not available in Windows
      _ResourceId = AssociatedResourceId, 
      _SubscriptionId = AzureSubscriptionId, 
      EventOriginalUid = OriginalEventId,  // OK pending question
      DvcOs = MessageSource,
      NetworkProtocol = Protocol,
      NetworkApplicationProtocol = ApplicationProtocol,
      DvcId = DeviceId,
      DvcIpAddr = LocalAddress
    | project-away outbound
    | extend
      Dvc = DvcId,
      DvcIdType = "MD4IoTid",
      User = UserId,
      IpAddr = SrcIpAddr,
      Src = SrcIpAddr,
      Dst = DstIpAddr
  ;
  NetworkSessionMD4IoT};
  parser(starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionMD4IoTSensor
// Description: This ASIM parser supports filtering and normalizing Microsoft Defender for IoT sensor logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMD4IoTSensor(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null), 
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false)
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  DefenderIoTRawEvent
  | where RawEventName == "NetworkConnectionData"
  | where (isnull(starttime) or TimeGenerated>=starttime)
    and (isnull(endtime) or TimeGenerated<=endtime)
    and not(disabled)
    and (array_length(dvcaction) == 0)
    and (array_length(hostname_has_any) == 0)
    and (eventresult in ("*","Success"))
  | extend
    DstIpAddr = tostring(EventDetails.Destination.IPAddress),
    SrcIpAddr = tostring(EventDetails.Source.IPAddress)
  | extend temp_SrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
         , temp_DstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
  | extend ASimMatchingIpAddr=case(
      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
      temp_SrcMatch and temp_DstMatch, "Both",
      temp_SrcMatch, "SrcIpAddr",
      temp_DstMatch, "DstIpAddr",
      "No match"
    )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  | extend
    DstPortNumber = toint(EventDetails.Destination.Port)
  | where (isnull(dstportnumber) or DstPortNumber==dstportnumber)
  | project-rename 
      DvcSubscriptionId = AzureSubscriptionId
  | extend 
      Dvc = tostring(EventDetails.SourceId),
      DstDvcId = tostring(EventDetails.Destination.DeviceId),
      DstMacAddr = tostring(EventDetails.Destination.MacAddress),
      DstDescription = tostring(EventDetails.Destination.DeviceName),
      SrcDvcId = tostring(EventDetails.Source.DeviceId),
      SrcMacAddr = tostring(EventDetails.Source.MacAddress),
      SrcPortNumber = toint(EventDetails.Source.Port),
      SrcDescription = tostring(EventDetails.Source.DeviceName),
      EventOriginalUid = tostring(EventDetails.Id),
      EventEndTime = todatetime(EventDetails.LastSeen),
      EventStartTime = todatetime(EventDetails.StartTime),
      NetworkProtocol = tostring(EventDetails.TransportProtocol)
  | extend
      EventProduct = 'Defender for IoT',
      EventResult = 'Success',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.4',
      EventCount = toint(1),
      EventSeverity = 'Informational',
      EventType = iff(DstIpAddr=='' and SrcIpAddr == '','L2NetworkSession','NetworkSession'),
      NetworkDirection = iff(tobool(EventDetails.IsInternal), 'Local',''),
      EventVendor = 'Microsoft',
      DstDvcIdType = 'MD4IoTid',
      SrcDvcIdType = 'MD4IoTid'
  | extend // -- Aliases
      Dst = coalesce(DstIpAddr,DstMacAddr),
      Src = coalesce(SrcIpAddr,SrcMacAddr),
      IpAddr = SrcIpAddr,
      EventStartTime = EventEndTime
  | project-away 
      RawEventCategory, RawEventName, RawEventType, SourceSystem, TenantId, AgentVersion, IoTRawEventId, IsEmpty, AgentId, DeviceId, TimeStamp
  | project-away EventDetails, AssociatedResourceId
};
parser (
  starttime=starttime, 
  endtime=endtime, 
  srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
  dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
  ipaddr_has_any_prefix=ipaddr_has_any_prefix, 
  dstportnumber=dstportnumber, 
  hostname_has_any=hostname_has_any, 
  dvcaction=dvcaction,
  eventresult=eventresult,
  disabled=disabled
)
}



//
// Function Name: vimNetworkSessionMicrosoft365Defender
// Description: This ASIM parser supports filtering and normalizing M365 Defender for Endpoint to the ASIM Network Session schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMicrosoft365Defender(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let M365Defender=
  (starttime:datetime=datetime(null)
  , endtime:datetime=datetime(null)
  , srcipaddr_has_any_prefix:dynamic=dynamic([])
  , dstipaddr_has_any_prefix:dynamic=dynamic([])
  , ipaddr_has_any_prefix:dynamic=dynamic([])
  , dstportnumber:int=int(null)
  , hostname_has_any:dynamic=dynamic([])
  , dvcaction:dynamic=dynamic([])
  , eventresult:string='*'
  , disabled:bool=false
 ){
let DirectionLookup=datatable(ActionType:string,NetworkDirection:string,Outbound:boolean)[
  'ConnectionSuccess','Outbound', true
  ,'ConnectionFailed', 'Outbound', true
  ,'ConnectionRequest','Outbound', true
  ,'InboundConnectionAccepted', 'Inbound', false
  ,'ConnectionFound', 'Unknown', false
  ,'ListeningConnectionCreated', 'Listen', false 
];
let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
// -- Common preprocessing to both input and outbound events
let RawNetworkEvents = (select_outbound:boolean) {
  DeviceNetworkEvents 
  | where    (isnull(starttime) or TimeGenerated>=starttime) 
         and (isnull(endtime) or TimeGenerated<=endtime) 
  | where not(disabled)
  | lookup DirectionLookup on ActionType
  | where Outbound == select_outbound
  | project-away AppGuardContainerId, LocalIPType, MachineGroup, RemoteIPType, Timestamp // , SourceSystem, TenantId, 
  // --  Pre-filtering
  |where  (array_length(dvcaction)==0 )     /// if filtered by action return nothing
         and (isnull(dstportnumber) or dstportnumber == LocalPort or dstportnumber == RemotePort)
         and (array_length(hostname_has_any)==0 
            or RemoteUrl has_any(hostname_has_any) or DeviceName has_any(hostname_has_any)
            )
  | extend temp_isSrcMatch=( // only one of each pair has_any_ipv4_prefix is calculated
                  (Outbound and has_any_ipv4_prefix(LocalIP,src_or_any))
                  or
                  (not(Outbound) and has_any_ipv4_prefix(RemoteIP,src_or_any))
                  ) 
         , temp_isDstMatch=(
                  (not(Outbound) and has_any_ipv4_prefix(LocalIP,dst_or_any))
                  or
                  (Outbound and has_any_ipv4_prefix(RemoteIP,dst_or_any))
                  ) 
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  ) 
  | where ASimMatchingIpAddr != "No match"
  | project-away temp_*
  | extend EventResult = iff(ActionType=='ConnectionFailed','Failure','Success')
  | where (eventresult=='*' or EventResult==eventresult)
  // -- End of pre-filtering
  | extend
    // Event
    EventOriginalUid = tostring(ReportId),
    EventCount = int(1),
    EventProduct = 'M365 Defender for Endpoint',
    EventVendor = 'Microsoft',
    EventSchema = 'NetworkSession',
    EventSchemaVersion = '0.2.3',
    EventStartTime = TimeGenerated,
    EventEndTime = TimeGenerated,
    EventType = 'NetworkSession',
    EventSeverity = "Informational",
    DvcIdType = 'MDEid'
  | project-away 
      ReportId, Outbound
  | project-rename 
      EventOriginalResultDetails = ActionType
  | extend
    RemoteUrl = extract (@"(?:https?://)?(.*)", 1, RemoteUrl)
  | extend
    User = iff (InitiatingProcessAccountDomain == '', InitiatingProcessAccountName, strcat(InitiatingProcessAccountDomain, '\\', InitiatingProcessAccountName)),
    UsernameType = iff(InitiatingProcessAccountDomain == '','Simple', 'Windows'),
    SplitHostname = split(DeviceName,"."),
    SplitUrl = split(RemoteUrl,"."),
    NetworkProtocol = case (
      Protocol startswith "Tcp", "TCP",
      Protocol == "Unknown", "",
      toupper(Protocol)
    )
  | project-away Protocol
  | extend  
    DvcHostname = tostring(SplitHostname[0]),
    DvcDomain = tostring(strcat_array(array_slice(SplitHostname, 1, -1), '.')),
    DvcFQDN = iif (DeviceName contains ".", DeviceName, ""),
    UrlHostname = tostring(SplitUrl[0]),
    UrlDomain = tostring(strcat_array(array_slice(SplitUrl, 1, -1), '.')),
    UrlFQDN = iif(RemoteUrl contains ".", RemoteUrl, "")
  | project-away RemoteUrl, DeviceName
  | extend
    DvcDomainType = iif(DvcFQDN != "", "FQDN", ""),
    UrlDomainType = iff(UrlFQDN != "", "FQDN", ""),
    DvcIpAddr = LocalIP
  | extend
    Dvc = DvcHostname  
  | project-rename
    DvcId = DeviceId
  | project-away SplitUrl, SplitHostname
};
let OutboundNetworkEvents = 
  RawNetworkEvents (true)
  // *************** Postfilterring *****************************************************************
  | where (isnull(dstportnumber) or dstportnumber==RemotePort)
  // *************** /Postfilterring *****************************************************************
  | extend temp_isMatchSrcHostname=DvcHostname has_any(hostname_has_any)
         , temp_isMatchDstHostname=UrlHostname has_any(hostname_has_any)
  |extend ASimMatchingHostname = case(array_length(hostname_has_any) == 0 ,"-",
                              temp_isMatchDstHostname and temp_isMatchSrcHostname, "Both",
                              temp_isMatchDstHostname, "DstHostname",
                              temp_isMatchSrcHostname, "SrcHostname",
                                "No match"
                            )
  | project-away temp*
  | where ASimMatchingHostname != "No match"
  | project-rename
     DstIpAddr = RemoteIP,
     SrcIpAddr = LocalIP,
     DstPortNumber = RemotePort,
     SrcPortNumber = LocalPort,
     SrcUsernameType = UsernameType,
     SrcUserAadId = InitiatingProcessAccountObjectId,
     SrcUserId = InitiatingProcessAccountSid,
     SrcUserUpn = InitiatingProcessAccountUpn
  | extend
     SrcUsername = User,
     SrcDvcId = DvcId,
     SrcDvcIdType = 'MDEid',
     SrcUserIdType = iff (SrcUserId <> "S-1-0-0", "SID", ""),
     SrcUserId = iff (SrcUserId <> "S-1-0-0", SrcUserId, ""),
     DstHostname = UrlHostname
  | project-rename
     DstDomain = UrlDomain,
     DstFQDN = UrlFQDN,
     DstDomainType = UrlDomainType
  | extend  
     SrcHostname = DvcHostname,
     SrcDomain = DvcDomain,
     SrcFQDN = DvcFQDN,
     SrcDomainType = DvcDomainType
  // Processes
  | extend
     SrcProcessId = tostring(InitiatingProcessId),
     ParentProcessId = tostring(InitiatingProcessParentId)
  | project-rename
     SrcProcessName = InitiatingProcessFileName,
     SrcProcessCommandLine = InitiatingProcessCommandLine,
     SrcProcessCreationTime = InitiatingProcessCreationTime,
     SrcProcessIntegrityLevel = InitiatingProcessIntegrityLevel,
     SrcProcessTokenElevation = InitiatingProcessTokenElevation,
     ParentProcessName = InitiatingProcessParentFileName,
     ParentProcessCreationTime = InitiatingProcessParentCreationTime
  | extend
     Process = SrcProcessName,
     ProcessId = SrcProcessId,
     SrcAppName = SrcProcessName,
     SrcAppType = "Process"
;
let InboundNetworkEvents = 
  RawNetworkEvents (false)
  // *************** Postfilterring *****************************************************************
  | where (isnull(dstportnumber) or dstportnumber==LocalPort)
  // *************** /Postfilterring *****************************************************************
    |extend ASimMatchingHostname = case(array_length(hostname_has_any) == 0 ,"",
                                UrlHostname has_any(hostname_has_any), "SrcHostname",
                                DvcHostname has_any(hostname_has_any), "DstHostname",
                                "No match"
                            )
  | where ASimMatchingHostname != "No match"
  | project-rename
     SrcIpAddr = RemoteIP,
     DstIpAddr = LocalIP,
     SrcPortNumber = RemotePort,
     DstPortNumber = LocalPort,
     DstUsernameType = UsernameType,
     DstUserAadId = InitiatingProcessAccountObjectId,
     DstUserId = InitiatingProcessAccountSid,
     DstUserUpn = InitiatingProcessAccountUpn,
     SrcDomain = UrlDomain,
     SrcFQDN = UrlFQDN,
     SrcDomainType = UrlDomainType
  | extend
     DstUsername = User,
     DstDvcId = DvcId,
     DstDvcIdType = 'MDEid',
     DstUserIdType = 'SID',
     SrcHostname = UrlHostname
  | extend  
     DstHostname = DvcHostname,
     DstDomain = DvcDomain,
     DstFQDN = DvcFQDN
  // Processes
  | extend
     DstProcessId = tostring(InitiatingProcessId),
     ParentProcessId = tostring(InitiatingProcessParentId)
  | project-rename
     DstProcessName = InitiatingProcessFileName,
     DstProcessCommandLine = InitiatingProcessCommandLine,
     DstProcessCreationTime = InitiatingProcessCreationTime,
     DstProcessIntegrityLevel = InitiatingProcessIntegrityLevel,
     DstProcessTokenElevation = InitiatingProcessTokenElevation,
     ParentProcessName = InitiatingProcessParentFileName,
     ParentProcessCreationTime = InitiatingProcessParentCreationTime
  | extend
     Process = DstProcessName,
     DstAppName = DstProcessName,
     DstAppType = "Process"
;
union InboundNetworkEvents, OutboundNetworkEvents
| project-rename 
   Hostname = UrlHostname
| extend // aliases
   IpAddr = SrcIpAddr,
   Src = SrcIpAddr,
   Dst = DstIpAddr 
};
M365Defender (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionLinuxSysmon
// Description: This ASIM parser supports filtering and normalizing Sysmon for Linux event 3 to the ASIM Network Session schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionLinuxSysmon(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);    
let DirectionNetworkEvents =
    Syslog 
    | where (isnull(starttime) or TimeGenerated>=starttime) 
        and (isnull(endtime) or TimeGenerated<=endtime) 
    | where not(disabled)
    | project SyslogMessage, TimeGenerated, HostIP
    | where SyslogMessage has_all ('<Provider Name="Linux-Sysmon"', '<EventID>3</EventID>')
    // ***************  Prefilterring *****************************************************************
    | where  
             (eventresult=='*' or eventresult=='Success')
        and (array_length(dvcaction) ==0  )     /// if filtered by action return nothing
        and (array_length(ip_any)==0 
              or has_any_ipv4_prefix(SyslogMessage,ip_any)
            ) 
       and (array_length(hostname_has_any)==0 
              or SyslogMessage has_any(hostname_has_any)) 
        and (isnull(dstportnumber) or SyslogMessage has (tostring(dstportnumber))) 
    // *************** / Prefilterring ***************************************************************
    | parse SyslogMessage with * '<Data Name="SourceIp">' SrcIpAddr:string '</Data>' *
    | where (array_length(srcipaddr_has_any_prefix)==0 
              or has_any_ipv4_prefix(SrcIpAddr,srcipaddr_has_any_prefix)
            ) 
    | extend outbound = (SrcIpAddr == HostIP or SrcIpAddr in ('127.0.0.1', '0.0.0.0'))
;
let parser = (T: (SyslogMessage: string)) {
  T 
  | parse SyslogMessage with 
      *
      '<EventRecordID>' EventOriginalUid:string '</EventRecordID>'
      *
      '<Computer>' SysmonComputer:string '</Computer>'
      *
      '<Data Name="RuleName">' RuleName:string '</Data>'
      '<Data Name="UtcTime">' EventEndTime:datetime '</Data>'
      '<Data Name="ProcessGuid">{' ProcessGuid:string '}</Data>'
      '<Data Name="ProcessId">' ProcessId:string '</Data>'
      '<Data Name="Image">' Process:string '</Data>'
      '<Data Name="User">' User:string '</Data>'
      '<Data Name="Protocol">' Protocol:string '</Data>' // -- source is lowercase
      '<Data Name="Initiated">' Initiated:bool '</Data>' 
      '<Data Name="SourceIsIpv6">' SourceIsIpv6:bool '</Data>'		
      '<Data Name="SourceIp">' * '</Data>'
      '<Data Name="SourceHostname">' SrcHostname:string '</Data>'
      '<Data Name="SourcePort">' SrcPortNumber:int '</Data>'
      '<Data Name="SourcePortName">' SrcPortName:string '</Data>'
      '<Data Name="DestinationIsIpv6">' DestinationIsIpv6:bool '</Data>'
      '<Data Name="DestinationIp">' DstIpAddr:string '</Data>'
      '<Data Name="DestinationHostname">' DstHostname:string '</Data>'
      '<Data Name="DestinationPort">' DstPortNumber:int '</Data>'
      '<Data Name="DestinationPortName">' DstPortName:string '</Data>'
      *
    | project-away DstPortName, DestinationIsIpv6, Initiated, SourceIsIpv6, SrcPortName, RuleName
};
let OutboundNetworkEvents = 
  DirectionNetworkEvents
  | where outbound
  | invoke parser ()
  | extend 
         temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any) 
       , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
| extend ASimMatchingIpAddr = case(
        array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
        , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
        , temp_isSrcMatch, "SrcIpAddr"
        , temp_isDstMatch, "DstIpAddr"
        , "No match"
)
 | where ASimMatchingIpAddr != "No match"
 | extend temp_isSrcHostMatch= (SrcHostname has_any (hostname_has_any))
        , temp_isDstHostMatch = (DstHostname has_any (hostname_has_any))
  | extend ASimMatchingHostname = case(
        array_length(hostname_has_any) == 0, "-" // match not requested: probably most common case
        , (temp_isSrcHostMatch and temp_isDstHostMatch), "Both" // has to be checked before the individual 
        , temp_isSrcHostMatch, "SrcHostname"
        , temp_isDstHostMatch, "DstHostname"
        , "No match"
)
 | where ASimMatchingHostname != "No match"
 | project-away temp_*
 | extend
    SrcUsernameType = 'Simple',
    SrcUsername = User,
    SrcAppType = 'Process'
  | project-rename
    SrcProcessId = ProcessId, 
    SrcProcessGuid = ProcessGuid,
    SrcProcessName = Process
  | extend
    SrcAppName = SrcProcessName
  | project-away SyslogMessage
;
let InboundNetworkEvents = 
    DirectionNetworkEvents
    | where not(outbound)
    | invoke parser ()
    // *************** Postfilterring ***************************************************************
    | where (array_length(hostname_has_any)==0 or DstHostname has_any (hostname_has_any)or SrcHostname has_any (hostname_has_any) )
    and  (isnull(dstportnumber) or DstPortNumber ==dstportnumber)
    // *************** Postfilterring ***************************************************************
    | extend 
        temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any) 
      , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend ASimMatchingIpAddr = case(
      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
      , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
      , temp_isSrcMatch, "SrcIpAddr"
      , temp_isDstMatch, "DstIpAddr"
      , "No match"
  )
  | project-away temp_*
  | where ASimMatchingIpAddr != "No match"
  | extend
    DstUsernameType = 'Simple',
    DstAppType = 'Process' 
  | project-rename
    DstUsername = User,
    DstProcessId = ProcessId, 
    DstProcessGuid = ProcessGuid,
    DstProcessName = Process
  | extend
    DstAppName = DstProcessName
  | project-away SyslogMessage
;
let SysmonForLinuxNetwork=
    union OutboundNetworkEvents, InboundNetworkEvents
    | extend 
        EventType = 'NetworkSession',
        EventStartTime = EventEndTime,
        EventCount = int(1),
        EventVendor = 'Microsoft',
        EventSchemaVersion = '0.2.3',
        EventSchema = 'NetworkSession', 
        EventProduct = 'Sysmon for Linux',
        EventResult = 'Success',
        EventSeverity = 'Informational',
        DvcOs = 'Linux',
        NetworkProtocol = toupper(Protocol),
        NetworkDirection = iff(outbound, "Outbound", "Inbound"),
        EventOriginalType = '3' // Set with a constant value to avoid parsing
    | project-away outbound, Protocol
    | project-rename 
        DvcIpAddr = HostIP,
        DvcHostname = SysmonComputer
    | extend // aliases
        Dvc = DvcHostname,
        Hostname = DstHostname,
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr
;
SysmonForLinuxNetwork
}



//
// Function Name: vimNetworkSessionMicrosoftSecurityEventFirewall
// Description: This ASIM parser supports normalizing Microsoft Windows Firewall Events logs ingested in 'SecurityEvent' table to the ASIM Network Session schema. Event IDs which are parsed as part of this parser: 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5167, 5158, 5159

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMicrosoftSecurityEventFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let LayerCodeTable = datatable (LayerCode:string,LayerName:string)[
  '%%14596', 'IP Packet',
  '%%14597', 'Transport',
  '%%14598', 'Forward',
  '%%14599', 'Stream',
  '%%14600', 'Datagram Data',
  '%%14601', 'ICMP Error',
  '%%14602', 'MAC 802.3',
  '%%14603', 'MAC Native',
  '%%14604', 'vSwitch',
  '%%14608', 'Resource Assignment',
  '%%14609', 'Listen',
  '%%14610', 'Receive/Accept',
  '%%14611', 'Connect',
  '%%14612', 'Flow Established',
  '%%14614', 'Resource Release',
  '%%14615', 'Endpoint Closure',
  '%%14616', 'Connect Redirect',
  '%%14617', 'Bind Redirect',
  '%%14624', 'Stream Packet'];
let ProtocolTable = datatable (Protocol:int, NetworkProtocol: string)[
  1, 'ICMP',
  3, 'GGP',
  6, 'TCP',
  8, 'EGP',
  12, 'PUP',
  17, 'UDP',
  20, 'HMP',
  27, 'RDP',
  46, 'RSVP',
  47, 'PPTP data over GRE',
  50, 'ESP',
  51, 'AH',
  66, 'RVD',
  88, 'IGMP',
  89, 'OSPF'];
let Directions = datatable (DirectionCode:string,NetworkDirection:string, isOutBound:bool)[
  '%%14592', 'Inbound', false,
  '%%14593', 'Outbound', true,
  '%%14594', 'Forward',false,
  '%%14595', 'Bidirectional', false,
  '%%14609', 'Listen', false];
///////////////////////////////////////////////////////
// this query extract data fields from EventData column from SecurityEvent table
///////////////////////////////////////////////////////
let parser = (starttime:datetime=datetime(null), endtime:datetime=datetime(null)
, srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]),dstportnumber:int=int(null)
, hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]),eventresult:string='*', disabled:bool=false
) {   
    let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let ip_any =set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let SecurityEventProjected =
      SecurityEvent
      | project EventID, EventData, Computer, TimeGenerated, _ResourceId, _SubscriptionId, Type
    ;
    // Event IDs between (5151 .. 5159)
    // will be extracting Event specific fields from 'EventData' field
    let SecurityEvent_5152 = 
      SecurityEventProjected 
      | where not(disabled)
      | where (isnull(starttime) or TimeGenerated>=starttime)
        and  (isnull(endtime) or TimeGenerated<=endtime)
      | where EventID==5152
      // ***************  Prefilterring *****************************************************************
      |where  (isnull(dstportnumber) or EventData has tostring(dstportnumber) ) 
        and  (array_length(ip_any)==0 
              or has_any_ipv4_prefix(EventData ,ip_any)
              ) 
        and (array_length(dvcaction)==0 or (dvcaction=='Deny') ) 
        and (array_length(hostname_has_any)==0 )
        and (eventresult=='*' or eventresult=='Failure')
        // *************** / Prefilterring *****************************************************************
      | extend EventResult =  "Failure"
        | parse EventData with * 
            '<Data Name="ProcessId">'ProcessId:string'</Data>'
            '\x0d\x0a  <Data Name="Application">'Application'</Data>'
            '\x0d\x0a  <Data Name="Direction">'DirectionCode'</Data>'
            '\x0d\x0a  <Data Name="SourceAddress">'SrcIpAddr:string'</Data>'
            '\x0d\x0a  <Data Name="SourcePort">'SrcPortNumber:int'</Data>'
            '\x0d\x0a  <Data Name="DestAddress">'DstIpAddr'</Data>'
            '\x0d\x0a  <Data Name="DestPort">'DstPortNumber:int'</Data>'
            '\x0d\x0a  <Data Name="Protocol">'Protocol:int'</Data>'
            '\x0d\x0a  <Data Name="FilterRTID">'NetworkRuleNumber:int'</Data>'
            '\x0d\x0a  <Data Name="LayerName">'LayerCode'</Data>'
            '\x0d\x0a  <Data Name="LayerRTID">'LayerRTID'</Data>'*
        | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
        , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
        | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
          )
        | where ASimMatchingIpAddr != "No match"
        | project-away temp_*, EventData
      ;
    let SecurityEvent_5154_5155_5158_5159 =
    SecurityEventProjected 
      | where not(disabled)
      | where (isnull(starttime) or TimeGenerated>=starttime)
          and  (isnull(endtime) or TimeGenerated<=endtime)
        | where EventID in (5154, 5155, 5158, 5159)
        // ***************  Prefilterring *****************************************************************
        |where   (array_length(dstipaddr_has_any_prefix)==0 ) 
          and  (array_length(hostname_has_any)==0 ) 
          and  (isnull(dstportnumber) ) 
          and  (array_length(ip_any)==0 
                or has_any_ipv4_prefix(EventData ,ip_any)
              ) 
          and (array_length(dvcaction)==0 
              or (dvcaction=='Allow' and EventID in  (5154,5158))  
              or (dvcaction=='Deny'  and EventID !in (5154,5158))
              ) 
        | extend EventResult = iff(EventID in (5154, 5158), "Success", "Failure")
        | where (eventresult=='*' or EventResult==eventresult)
        // *************** / Prefilterring *****************************************************************
        | parse EventData with * '<Data Name="ProcessId">'ProcessId:string'</Data>' 
            '\x0d\x0a  <Data Name="Application">'Application:string'</Data>'
            '\x0d\x0a  <Data Name="SourceAddress">'SrcIpAddr:string'</Data>'
            '\x0d\x0a  <Data Name="SourcePort">'SrcPortNumber:int'</Data>'
            '\x0d\x0a  <Data Name="Protocol">'Protocol:int'</Data>'
            '\x0d\x0a  <Data Name="FilterRTID">'NetworkRuleNumber:int'</Data>'
            '\x0d\x0a  <Data Name="LayerName">'LayerCode'</Data>'
            '\x0d\x0a  <Data Name="LayerRTID">'LayerRTID'</Data>'*
        | extend DirectionCode = "%%14609"
        | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
          , temp_isDstMatch=false
        | extend ASimMatchingIpAddr = case(
            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
          )
        | where ASimMatchingIpAddr != "No match"
        | project-away temp_* , EventData
        ;
    let SecurityEvent_5156_5157 =
        SecurityEventProjected
        | where not(disabled) 
        | where (isnull(starttime) or TimeGenerated>=starttime)
          and  (isnull(endtime) or TimeGenerated<=endtime)
        | where EventID in (5156, 5157)
        | extend EventResult = iff(EventID == 5156, "Success", "Failure")
        // ***************  Prefilterring *****************************************************************
        | where (isnull(starttime) or TimeGenerated>=starttime)
          and  (isnull(endtime) or TimeGenerated<=endtime)
                      and  (array_length(ip_any)==0 
                or has_any_ipv4_prefix(EventData ,ip_any)
              ) 
          and  (isnull(dstportnumber) or EventData has tostring(dstportnumber) ) 
          and (array_length(dvcaction)==0 
              or (dvcaction=='Allow' and EventID == 5156)  
              or (dvcaction=='Deny'  and EventID <> 5156)
              )
          and (array_length(hostname_has_any)==0 )
          and (eventresult=='*' or EventResult==eventresult) 
        // *************** / Prefilterring *****************************************************************
        | parse EventData with * '<Data Name="ProcessID">'ProcessId:string'</Data>'
            '\x0d\x0a  <Data Name="Application">'Application:string'</Data>'
            '\x0d\x0a  <Data Name="Direction">'DirectionCode:string'</Data>'
            '\x0d\x0a  <Data Name="SourceAddress">'SrcIpAddr:string'</Data>'
            '\x0d\x0a  <Data Name="SourcePort">'SrcPortNumber:int'</Data>'
            '\x0d\x0a  <Data Name="DestAddress">'DstIpAddr:string'</Data>'
            '\x0d\x0a  <Data Name="DestPort">'DstPortNumber:int'</Data>'
            '\x0d\x0a  <Data Name="Protocol">'Protocol:int'</Data>'
            '\x0d\x0a  <Data Name="FilterRTID">'NetworkRuleNumber:int'</Data>'
            '\x0d\x0a  <Data Name="LayerName">'LayerCode'</Data>'
            '\x0d\x0a  <Data Name="LayerRTID">'LayerRTID'</Data>'
            '\x0d\x0a  <Data Name="RemoteUserID">'RemoteUserID:string'</Data>'
            '\x0d\x0a  <Data Name="RemoteMachineID">'RemoteMachineID:string'</Data>'*
            | project-away EventData
            | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
            | extend ASimMatchingIpAddr = case(
            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
            , temp_isSrcMatch, "SrcIpAddr"
            , temp_isDstMatch, "DstIpAddr"
            , "No match"
            )
          | where ASimMatchingIpAddr != "No match"
          | project-away temp_*
        ;
    union SecurityEvent_5154_5155_5158_5159, SecurityEvent_5156_5157, SecurityEvent_5152
    | lookup Directions on DirectionCode
    | project-rename DvcHostname = Computer
    | extend
          SrcAppName = iff(isOutBound, Application, ""),
          DstAppName = iff(not(isOutBound), Application, ""),
          SrcDvcId = iff(isOutBound, RemoteMachineID, ""),
          DstDvcId = iff(not(isOutBound), RemoteMachineID, ""),
          SrcProcessId =  iff(isOutBound, tostring(ProcessId), ""),
          DstProcessId =  iff(not(isOutBound), tostring(ProcessId), ""),
          DstUserId = iff(isOutBound, RemoteUserID, ""),
          SrcUserId = iff(not(isOutBound), RemoteUserID, ""),
          DstHostname = iff(isOutBound, "", DvcHostname),
          SrcHostname = iff(isOutBound, DvcHostname, "")
        | project-away Application, RemoteMachineID, ProcessId, RemoteUserID
          // *************** Postfilterring *****************************************************************
        | where  (isnull(dstportnumber) or DstPortNumber == dstportnumber )
        // *************** / Postfilterring *****************************************************************
        | extend 
            DvcAction = iff(EventID in (5154, 5156, 5158), "Allow", "Deny"),
            DvcOs = 'Windows',
            DstAppType = "Process",
            SrcUserIdType = iff (SrcUserId <> "S-1-0-0", "SID", ""),
            SrcUserId = iff (SrcUserId <> "S-1-0-0", SrcUserId, ""),
            DstUserIdType = iff (DstUserId <> "S-1-0-0", "SID", ""),
            DstUserId = iff (DstUserId <> "S-1-0-0", DstUserId, ""),
            SrcAppType = "Process",
            EventType = "NetworkSession",
            EventSchema = "NetworkSession",
            EventSchemaVersion="0.2.3",
            EventCount=toint(1),
            EventVendor = "Microsoft",
            EventProduct = "Windows Firewall",
            EventStartTime = TimeGenerated,
            EventEndTime = TimeGenerated,
            EventSeverity = iff(EventID  in (5154, 5156, 5158), "Informational", "Low")
    // -- Aliases
    | extend 
        Dvc = DvcHostname,
        Hostname = DvcHostname,
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Rule = tostring(NetworkRuleNumber),
        DstDvcIdType = iff (DstDvcId != "", "SID", ""),
        SrcDvcIdType = iff (SrcDvcId != "", "SID", "")
    | lookup LayerCodeTable on LayerCode
    | lookup ProtocolTable on Protocol
    | project-away LayerCode, DirectionCode, Protocol, isOutBound, LayerName, EventID, LayerRTID,_ResourceId,_SubscriptionId
    };
    parser(starttime = datetime(null),endtime = datetime(null),srcipaddr_has_any_prefix = dynamic([]),dstipaddr_has_any_prefix = dynamic([]),ipaddr_has_any_prefix = dynamic([]),dstportnumber = int(null),hostname_has_any = dynamic([]),dvcaction = dynamic([]),eventresult = '*',disabled = false)
}



//
// Function Name: vimNetworkSessionMicrosoftSysmon
// Description: This ASIM parser supports normalizing Sysmon network session events (event 3) collected using the Event or WEF (WindowsEvent table) connectors logs ingested in 'Event' table to the ASIM Process Event normalized schema. 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMicrosoftSysmon(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
starttime: datetime=datetime(null), 
endtime: datetime=datetime(null), 
srcipaddr_has_any_prefix: dynamic=dynamic([]), 
dstipaddr_has_any_prefix: dynamic=dynamic([]), 
ipaddr_has_any_prefix: dynamic=dynamic([]),
dstportnumber: int=int(null), 
hostname_has_any: dynamic=dynamic([]), 
dvcaction: dynamic=dynamic([]), 
eventresult: string='*', 
disabled: bool=false
) {
let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let ip_any =set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
let Sysmon3_Event=Event
    | where (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
    | where not(disabled)
    // -- Pre-filtering:
    | where (eventresult == '*' or eventresult == 'Success')
        and array_length(dvcaction) == 0
    // dstportnumber filter used later in the parser
    // hostname_has_any used later in the parser 
    // -- End pre-filtering
    | where Source == "Microsoft-Windows-Sysmon" and EventID == 3
    | parse-kv EventData as (
        SourceIp: string,
        DestinationIp: string,
        SourceHostname: string,
        DestinationHostname: string,
        Initiated: bool,  // Initiated indicates the process initiated a connection (meaning outbound)
        RuleName: string,
        UtcTime: datetime,
        ProcessGuid: string,
        ProcessId: string,
        Image: string,
        User: string,
        Protocol: string,
        SourceIsIpv6: bool,
        SourcePort: int,
        SourcePortName: string,
        DestinationIsIpv6: bool,
        DestinationPort: int,
        DestinationPortName: string
        )
        with (regex=@'<Data Name="(\w+)">{?([^>]*?)}?</Data>')
    | where (array_length(ip_any) == 0 
        or has_any_ipv4_prefix(EventData, ip_any)
        ) 
        and (isnull(dstportnumber)) or dstportnumber == DestinationPort
        and (array_length(hostname_has_any) == 0) or SourceHostname has_any (hostname_has_any) or DestinationHostname has_any (hostname_has_any)
    | extend
        temp_isSrcMatch=has_any_ipv4_prefix(SourceIp, src_or_any)
        ,
        temp_isDstMatch=has_any_ipv4_prefix(DestinationIp, dst_or_any)
    | extend ASimMatchingIpAddr = case(
                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                              "-" // match not requested: probably most common case
        ,
                              (temp_isSrcMatch and temp_isDstMatch),
                              "Both" // has to be checked before the individual 
        ,
                              temp_isSrcMatch,
                              "SrcIpAddr"
        ,
                              temp_isDstMatch,
                              "DstIpAddr"
        ,
                              "No match"
                          )
    | where ASimMatchingIpAddr != "No match"
    | project-away EventData
    | project-rename
        SrcHostname = SourceHostname,
        DstHostname = DestinationHostname
    | project-away
        Source,
        EventLog,
        EventCategory,
        UserName,
        Message,
        ParameterXml,
        RenderedDescription,
        MG,
        AzureDeploymentID,
        Role; 
Sysmon3_Event
| extend
    AppName = tostring(split(Image, "\\")[-1])
| extend
    SrcUsernameType = iff(not(Initiated), "Windows", ""),
    SrcUsername = iff(not(Initiated), tostring(User), ""),
    SrcProcessId = iff(not(Initiated), tostring(ProcessId), ""),
    SrcProcessGuid = iff(not(Initiated), ProcessGuid, ""),
    SrcProcessName = iff(not(Initiated), tostring(Image), ""),
    SrcAppName = iff(not(Initiated), AppName, ""),
    SrcAppType = iff(not(Initiated), 'Process', ""),
    DstUsernameType = iff(Initiated, "Windows", ""),
    DstUsername = iff(Initiated, tostring(User), ""),
    DstProcessId = iff(Initiated, tostring(ProcessId), ""),
    DstProcessGuid = iff(Initiated, ProcessGuid, ""),
    DstProcessName = iff(Initiated, tostring(Image), ""),
    DstAppName = iff(Initiated, AppName, ""),
    DstAppType = iff(Initiated, 'Process', "")
| project-away ProcessId, ProcessGuid, Image, AppName
| project-rename 
    EventStartTime = UtcTime,
    Dvc = Computer,
    SrcIpAddr = SourceIp,
    DstIpAddr  = DestinationIp,
    DstPortNumber = DestinationPort,
    SrcPortNumber = SourcePort,
    NetworkRuleName = RuleName
| extend 
    EventEndTime = EventStartTime,
    Hostname = case(
           Initiated,
           DstHostname,
           not(Initiated),
           SrcHostname,
           Dvc
       ),
    Src = SrcIpAddr,
    Dst = DstIpAddr,
    DvcIpAddr = iff(Initiated, SrcIpAddr, DstIpAddr),
    IpAddr = SrcIpAddr,
    EventType = 'EndpointNetworkSession',
    EventCount = int(1),
    EventVendor = 'Microsoft',
    EventSchemaVersion = '0.2.5',
    EventSchema = 'NetworkSession', 
    EventProduct = 'Sysmon',
    EventResult = 'Success',
    EventSeverity = 'Informational',
    DvcOs = 'Windows',
    Protocol = toupper(Protocol),
    EventOriginalType = '3' // Set with a constant value to avoid parsing   
| extend
    DvcHostname = Hostname
| extend
    SrcHostname = iff(SrcHostname == "-", "", SrcHostname),
    DvcHostname = iff(DvcHostname == "-", "", DvcHostname),
    DstHostname = iff(DstHostname == "-", "", DstHostname) // let's make empty values actually empty
| project-rename
    TmpSrcHostname = SrcHostname,
    TmpDvcHostname = DvcHostname,
    TmpDstHostname = DstHostname
| invoke 
    _ASIM_ResolveSrcFQDN('TmpSrcHostname')
| invoke 
    _ASIM_ResolveDvcFQDN('TmpDvcHostname')
| invoke 
    _ASIM_ResolveDstFQDN('TmpDstHostname')
| project-away
    TmpSrcHostname,
    TmpDvcHostname,
    TmpDstHostname
| extend                         
    NetworkProtocolVersion = iff((DestinationIsIpv6) or (SourceIsIpv6), "IPV6", "IPV4"),
    NetworkProtocol = toupper(Protocol)
| project-away 
    Destination*,
    Initiated,
    ManagementGroupName,
    TenantId,
    Protocol,
    Source*,
    EventID,
    EventLevelName,
    EventLevel,
    _ResourceId
};
  parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix,dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionMicrosoftSysmonWindowsEvent
// Description: This ASIM parser supports normalizing Sysmon network session events (event 3) collected using the Event or WEF (WindowsEvent table) connectors logs ingested in 'WindowsEvent' table to the ASIM Process Event normalized schema. 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMicrosoftSysmonWindowsEvent(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
starttime: datetime=datetime(null), 
endtime: datetime=datetime(null), 
srcipaddr_has_any_prefix: dynamic=dynamic([]), 
dstipaddr_has_any_prefix: dynamic=dynamic([]), 
ipaddr_has_any_prefix: dynamic=dynamic([]),
dstportnumber: int=int(null), 
hostname_has_any: dynamic=dynamic([]), 
dvcaction: dynamic=dynamic([]), 
eventresult: string='*', 
disabled: bool=false
) {
let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let ip_any =set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
let Sysmon3_WindowsEvent=WindowsEvent
    | where not(disabled) 
    | where (isnull(starttime) or TimeGenerated >= starttime) 
      and (isnull(endtime) or TimeGenerated <= endtime)
    // -- Pre-filtering:
    | where (eventresult == '*' or eventresult == 'Success') 
        and array_length(dvcaction) == 0
        // dstportnumber filter used later in the parser
        // hostname_has_any used later in the parser 
    // -- End pre-filtering
    | where Provider == "Microsoft-Windows-Sysmon" and EventID == 3
    | extend
        SourceIp = tostring(EventData.SourceIp),
        DestinationIp = tostring(EventData.DestinationIp),
        DstHostname = tostring(EventData.DestinationHostname),
        SrcHostname = tostring(EventData.SrcHostname),
        RuleName = tostring(EventData.RuleName),
        UtcTime = todatetime(EventData.UtcTime),
        ProcessId = tostring(EventData.ProcessId),
        Image = tostring(EventData.Image),
        User = tostring(EventData.User),
        Protocol = tostring(EventData.Protocol),
        Initiated = tobool(EventData.Initiated), // Initiated indicates the process initiated a connection (meaning outbound)
        SourceIsIpv6 = tobool(EventData.SourceIsIpv6),
        SourcePort = toint(EventData.SourcePort),
        SourcePortName = tostring(EventData.SourcePortName),
        DestinationIsIpv6 = tobool(EventData.DestinationIsIpv6),
        DestinationPort = toint(EventData.DestinationPort),
        DestinationPortName = tostring(EventData.DestinationPortName)
    | where (array_length(ip_any) == 0 
        or has_any_ipv4_prefix(EventData, ip_any)
        ) 
        and (isnull(dstportnumber)) or dstportnumber == DestinationPort
        and (array_length(hostname_has_any) == 0) or SrcHostname has_any (hostname_has_any) or DstHostname has_any (hostname_has_any)
    | extend
        temp_isSrcMatch=has_any_ipv4_prefix(SourceIp, src_or_any)
        ,
        temp_isDstMatch=has_any_ipv4_prefix(DestinationIp, dst_or_any)
    | extend ASimMatchingIpAddr = case(
                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                              "-" // match not requested: probably most common case
        ,
                              (temp_isSrcMatch and temp_isDstMatch),
                              "Both" // has to be checked before the individual 
        ,
                              temp_isSrcMatch,
                              "SrcIpAddr"
        ,
                              temp_isDstMatch,
                              "DstIpAddr"
        ,
                              "No match"
                          )
    | where ASimMatchingIpAddr != "No match"
    | parse EventData.ProcessGuid with "{" ProcessGuid "}"
    | project-away EventData
    | project-away
        Provider,
        Channel,
        Task,
        Data,
        RawEventData,
        EventOriginId;
Sysmon3_WindowsEvent
| extend
    AppName = tostring(split(Image, "\\")[-1])
| extend
    SrcUsernameType = iff(not(Initiated), "Windows", ""),
    SrcUsername = iff(not(Initiated), tostring(User), ""),
    SrcProcessId = iff(not(Initiated), tostring(ProcessId), ""),
    SrcProcessGuid = iff(not(Initiated), ProcessGuid, ""),
    SrcProcessName = iff(not(Initiated), tostring(Image), ""),
    SrcAppName = iff(not(Initiated), AppName, ""),
    SrcAppType = iff(not(Initiated), 'Process', ""),
    DstUsernameType = iff(Initiated, "Windows", ""),
    DstUsername = iff(Initiated, tostring(User), ""),
    DstProcessId = iff(Initiated, tostring(ProcessId), ""),
    DstProcessGuid = iff(Initiated, ProcessGuid, ""),
    DstProcessName = iff(Initiated, tostring(Image), ""),
    DstAppName = iff(Initiated, AppName, ""),
    DstAppType = iff(Initiated, 'Process', "")
| project-away ProcessId, ProcessGuid, Image, AppName
| project-rename 
    EventStartTime = UtcTime,
    Dvc = Computer,
    SrcIpAddr = SourceIp,
    DstIpAddr  = DestinationIp,
    DstPortNumber = DestinationPort,
    SrcPortNumber = SourcePort,
    NetworkRuleName = RuleName 
| extend 
    EventEndTime = EventStartTime,
    Hostname = case(
           Initiated,
           DstHostname,
           not(Initiated),
           SrcHostname,
           Dvc
       ),
    Src = SrcIpAddr,
    Dst = DstIpAddr,
    DvcIpAddr = iff(Initiated, SrcIpAddr, DstIpAddr),
    IpAddr = SrcIpAddr,
    EventType = 'EndpointNetworkSession',
    EventCount = int(1),
    EventVendor = 'Microsoft',
    EventSchemaVersion = '0.2.5',
    EventSchema = 'NetworkSession', 
    EventProduct = 'Sysmon',
    EventResult = 'Success',
    EventSeverity = 'Informational',
    DvcOs = 'Windows',
    Protocol = toupper(Protocol),
    EventOriginalType = '3' // Set with a constant value to avoid parsing   
| extend
    DvcHostname = Hostname
| extend
    SrcHostname = iff(SrcHostname == "-", "", SrcHostname),
    DvcHostname = iff(DvcHostname == "-", "", DvcHostname),
    DstHostname = iff(DstHostname == "-", "", DstHostname) // let's make empty values actually empty
| project-rename
    TmpSrcHostname = SrcHostname,
    TmpDvcHostname = DvcHostname,
    TmpDstHostname = DstHostname
| invoke 
    _ASIM_ResolveSrcFQDN('TmpSrcHostname')
| invoke 
    _ASIM_ResolveDvcFQDN('TmpDvcHostname')
| invoke 
    _ASIM_ResolveDstFQDN('TmpDstHostname')
| project-away
    TmpSrcHostname,
    TmpDvcHostname,
    TmpDstHostname
| extend                         
    NetworkProtocolVersion = iff((DestinationIsIpv6) or (SourceIsIpv6), "IPV6", "IPV4"),
    NetworkProtocol = toupper(Protocol)
| project-away 
    Destination*,
    Initiated,
    ManagementGroupName,
    TenantId,
    Protocol,
    Source*,
    EventID,
    EventLevelName,
    EventLevel,
    Correlation,
    EventRecordId,
    Keywords,
    Opcode,
    SystemProcessId,
    SystemThreadId,
    SystemUserId,
    TimeCreated,
    _ResourceId,
    Version
};
  parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix,dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionMicrosoftWindowsEventFirewall
// Description: This ASIM parser supports normalizing Microsoft Windows Firewall Events logs ingested in 'WindowsEvent' table to the ASIM Network Session schema. Event IDs which are parsed as part of this parser: 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5167, 5158, 5159

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionMicrosoftWindowsEventFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
// Data tables for mapping raw values into string
let LayerCodeTable = datatable (LayerCode:string,LayerName:string)[
  '%%14596', 'IP Packet',
  '%%14597', 'Transport',
  '%%14598', 'Forward',
  '%%14599', 'Stream',
  '%%14600', 'Datagram Data',
  '%%14601', 'ICMP Error',
  '%%14602', 'MAC 802.3',
  '%%14603', 'MAC Native',
  '%%14604', 'vSwitch',
  '%%14608', 'Resource Assignment',
  '%%14609', 'Listen',
  '%%14610', 'Receive/Accept',
  '%%14611', 'Connect',
  '%%14612', 'Flow Established',
  '%%14614', 'Resource Release',
  '%%14615', 'Endpoint Closure',
  '%%14616', 'Connect Redirect',
  '%%14617', 'Bind Redirect',
  '%%14624', 'Stream Packet'];
let ProtocolTable = datatable (Protocol:int, NetworkProtocol: string)[
  1, 'ICMP',
  3, 'GGP',
  6, 'TCP',
  8, 'EGP',
  12, 'PUP',
  17, 'UDP',
  20, 'HMP',
  27, 'RDP',
  46, 'RSVP',
  47, 'PPTP data over GRE',
  50, 'ESP',
  51, 'AH',
  66, 'RVD',
  88, 'IGMP',
  89, 'OSPF'];
let Directions = datatable (DirectionCode:string,NetworkDirection:string, isOutBound:bool)[
  '%%14592', 'Inbound', false,
  '%%14593', 'Outbound', true,
  '%%14594', 'Forward',false,
  '%%14595', 'Bidirectional', false,
  '%%14609', 'Listen', false];
//////////////////////////////////////////////////////
// this query extract the data from WindowsEvent table
//////////////////////////////////////////////////////
let parser = (starttime:datetime=datetime(null), endtime:datetime=datetime(null)
, srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]),dstportnumber:int=int(null)
, hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]),eventresult:string='*', disabled:bool=false)
{
    let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let ip_any =set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    WindowsEvent 
    | project EventID, EventData, Computer, TimeGenerated, _ResourceId, _SubscriptionId, Type
    | where (isnull(starttime) or TimeGenerated>=starttime) 
            and (isnull(endtime) or TimeGenerated<=endtime) 
    |where not(disabled)
    | where EventID between (5150 .. 5159)
    | extend EventResult = iff(EventID in (5154, 5156, 5158), "Success", "Failure")
    // ***************  Prefilterring *******************
    | where  (isnull(dstportnumber) or EventData has tostring(dstportnumber)) 
            and (array_length(ip_any)==0 
                    or has_any_ipv4_prefix(EventData,ip_any)) 
            and (array_length(hostname_has_any)==0 ) 
            and (array_length(dvcaction)==0  ) 
            and (eventresult=='*' or EventResult==eventresult)
    // *************** Prefilterring *****************************************************************
    | extend SrcIpAddr = tostring(EventData.SourceAddress)
              , DstIpAddr = tostring(EventData.DestAddress)
    | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
        , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | where ASimMatchingIpAddr != "No match"
  | project-away temp_*
  | extend 
              EventSeverity=tostring(EventData.Severity),
              LayerCode = tostring(EventData.LayerName),
              NetworkRuleNumber = toint(EventData.FilterRTID),
              Protocol = toint(EventData.Protocol),
              DirectionCode = iff(EventID in (5154, 5155, 5158, 5159), "%%14609",tostring(EventData.Direction))
          | lookup Directions on DirectionCode 
          | project-rename DvcHostname = Computer
          | extend  SrcAppName = iff(isOutBound, tostring(EventData.Application), ""),
                    DstAppName = iff(not(isOutBound), tostring(EventData.Application), ""),
                    SrcDvcId = iff(isOutBound, tostring(EventData.RemoteMachineID), ""),
                    DstDvcId = iff(not(isOutBound), tostring(EventData.RemoteMachineID), ""),
                    SrcPortNumber = toint(EventData.SourcePort),
                    DstPortNumber = toint(EventData.DestPort),
                    SrcProcessId =  iff(isOutBound, tostring(EventData.ProcessId), ""),
                    DstProcessId =  iff(not(isOutBound), tostring(EventData.ProcessId), ""),
                    DstUserId = iff(isOutBound, tostring(EventData.RemoteUserID), ""),
                    SrcUserId = iff(not(isOutBound), tostring(EventData.RemoteUserID), ""),
                    DstHostname = iff(isOutBound, "", DvcHostname),
                    SrcHostname = iff(isOutBound, DvcHostname, "")
          | project-away EventData
          | where  (isnull(dstportnumber) or DstPortNumber == dstportnumber )
          | extend 
            DvcAction = iff(EventID in (5154, 5156, 5158), "Allow", "Deny"),
            DvcOs = 'Windows',
            DstAppType = "Process",
            SrcUserIdType = iff (SrcUserId <> "S-1-0-0", "SID", ""),
            SrcUserId = iff (SrcUserId <> "S-1-0-0", SrcUserId, ""),
            DstUserIdType = iff (DstUserId <> "S-1-0-0", "SID", ""),
            DstUserId = iff (DstUserId <> "S-1-0-0", DstUserId, ""),
            SrcAppType = "Process",
            EventType = "NetworkSession",
            EventSchema = "NetworkSession",
            EventSchemaVersion="0.2.3",
            EventCount=toint(1),
            EventVendor = "Microsoft",
            EventProduct = "Windows Firewall",
            EventStartTime = TimeGenerated,
            EventEndTime = TimeGenerated,
            EventSeverity = iff(EventID  in (5154, 5156, 5158), "Informational", "Low")
    // -- Aliases
    | extend 
        Dvc = DvcHostname,
        Hostname = DvcHostname,
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Rule = tostring(NetworkRuleNumber),
        DstDvcIdType = iff (DstDvcId != "", "SID", ""),
        SrcDvcIdType = iff (SrcDvcId != "", "SID", "")
    | lookup LayerCodeTable on LayerCode
    | lookup ProtocolTable on Protocol
    | project-away LayerCode, DirectionCode, Protocol, isOutBound, LayerName, EventID,_ResourceId,_SubscriptionId
      };
    parser(starttime = datetime(null),endtime = datetime(null),srcipaddr_has_any_prefix = dynamic([]),dstipaddr_has_any_prefix = dynamic([]),ipaddr_has_any_prefix = dynamic([]),dstportnumber = int(null),hostname_has_any = dynamic([]),dvcaction = dynamic([]),eventresult = '*',disabled = false)
}



//
// Function Name: vimNetworkSessionNative
// Description: This ASIM parser supports filters and normalizing the native Microsoft Sentinel Network Session table (ASimNetworkSessionLogs) to the ASIM NetworkSession normalized schema. While the native table is ASIM compliant, the parser is needed to add capabilities, such as aliases, available only at query time. 

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionNative(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null), 
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]), 
  ipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false)
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  ASimNetworkSessionLogs  
  | where (isnull(starttime) or TimeGenerated>=starttime)
    and (isnull(endtime) or TimeGenerated<=endtime)
    and not(disabled)
    and (isnull(dstportnumber) or DstPortNumber==dstportnumber)
    and (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
    and (eventresult == "*" or eventresult==EventResult)
  | extend temp_SrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
         , temp_DstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
  | extend ASimMatchingIpAddr=case(
      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
      temp_SrcMatch and temp_DstMatch, "Both",
      temp_SrcMatch, "SrcIpAddr",
      temp_DstMatch, "DstIpAddr",
      "No match"
    )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  |extend ASimMatchingHostname = case(
      array_length(hostname_has_any) == 0 ,"",
      SrcHostname has_any(hostname_has_any), "SrcHostname",
      DstHostname has_any(hostname_has_any), "DstHostname",
      "No match"
    )
  | where ASimMatchingHostname != "No match"
  | project-rename
        EventUid = _ItemId
  | extend 
      EventSchema = "NetworkSession",
      DvcScopeId = iff(isempty(DvcSubscriptionId), _SubscriptionId, DvcSubscriptionId)
  //  -- Aliases
  | extend
      EventEndTime = iff (isnull(EventEndTime), TimeGenerated, EventEndTime),
      EventStartTime = iff (isnull(EventEndTime), TimeGenerated, EventStartTime),
      Dvc = case(EventType == 'L2NetworkSession',
              coalesce (DvcFQDN, DvcHostname, DvcId, _ResourceId, strcat (EventVendor,'/', EventProduct)),
              coalesce (DvcFQDN, DvcHostname, DvcIpAddr, DvcId, _ResourceId, strcat (EventVendor,'/', EventProduct))
      ),
      Dst = coalesce (DstFQDN, DstHostname, DstIpAddr, DstDvcId),
      Src = coalesce (SrcFQDN, SrcHostname, SrcIpAddr, SrcDvcId),
      DvcInterface = iff(isempty(DvcInterface), coalesce(DvcInboundInterface, DvcOutboundInterface), DvcInterface),
      Hostname = iff  (EventType == "EndpointNetworkSession" and NetworkDirection == ("Inbound"), SrcHostname, DstHostname),
      IpAddr = iff  (EventType == "EndpointNetworkSession" and NetworkDirection == ("Inbound"), DstIpAddr, SrcIpAddr),
      Rule = coalesce(NetworkRuleName, tostring(NetworkRuleNumber)),
      Duration = NetworkDuration,
      SessionId = NetworkSessionId,
      User = DstUsername,
      InnerVlanId = SrcVlanId,
      OuterVlanId = DstVlanId
  | project-away
        TenantId, SourceSystem, DvcSubscriptionId, _SubscriptionId, _ResourceId
};
parser (
  starttime=starttime, 
  endtime=endtime, 
  srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
  dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
  ipaddr_has_any_prefix=ipaddr_has_any_prefix, 
  dstportnumber=dstportnumber, 
  hostname_has_any=hostname_has_any, 
  dvcaction=dvcaction,
  eventresult=eventresult,
  disabled=disabled
)
}



//
// Function Name: vimNetworkSessionPaloAltoCEF
// Description: This ASIM parser supports filtering and normalizing Palo Alto PanOS logs produced by the Microsoft Sentinel Palo Alto Networks connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionPaloAltoCEF(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let Actions=datatable(DeviceAction:string,DvcAction:string)
[ "reset client","Reset Source"
, "reset server","Reset Destination"
, "reset both", "Reset"
, "allow","Allow"
, "deny","Deny"
, "drop", "Drop"
, "drop ICMP", "Drop ICMP"
, "reset-client","Reset Source"
, "reset-server","Reset Destination"
, "reset-both", "Reset"
, "drop-icmp", "Drop ICMP"];
let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
let NWParser=(starttime:datetime=datetime(null), endtime:datetime=datetime(null), srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]), dstportnumber:int=int(null), hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]), eventresult:string='*', disabled:bool=false){
CommonSecurityLog 
| where (isnull(starttime) or TimeGenerated>=starttime)
  and     (isnull(endtime) or TimeGenerated<=endtime)
| where not(disabled)
| where DeviceVendor == "Palo Alto Networks" and DeviceProduct == "PAN-OS" and Activity == "TRAFFIC"
| where  (isnull(dstportnumber) or DestinationPort==dstportnumber)
  and (array_length(hostname_has_any)==0)
    // dvcaction - post filterring
    and (eventresult=="*" or (DeviceAction=="allow" and eventresult=="Success") or (eventresult=="Failure" and DeviceAction!="allow"))
| extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any)
       , temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
| extend ASimMatchingIpAddr=case(
                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
                              temp_SrcMatch and temp_DstMatch, "Both",
                              temp_SrcMatch, "SrcIpAddr",
                              temp_DstMatch, "DstIpAddr",
                              "No match"
                          )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
| parse AdditionalExtensions with "PanOSPacketsReceived=" DstPackets:long * "PanOSPacketsSent=" SrcPackets:long *
  // -- Adjustment to support both old and new CSL fields.
| extend 
  EventStartTime =  coalesce(
    todatetime(StartTime), 
    extract(@'start=(.*?)(?:;|$)',1, AdditionalExtensions,typeof(datetime)),
    datetime(null)
  ),
  EventOriginalResultDetails = coalesce(
    column_ifexists("Reason", ""),
    extract(@'reason=(.*?)(?:;|$)',1, AdditionalExtensions, typeof(string)),
    ""
  )
| project-rename 
      EventProductVersion=DeviceVersion // Not Documented
    , Dvc=DeviceName   
    , NetworkApplicationProtocol=ApplicationProtocol
    , SrcZone=DeviceCustomString4 
    , DstZone=DeviceCustomString5
    , NetworkRuleName=DeviceCustomString1
    , SrcUsername=SourceUserName 
    , DstUsername=DestinationUserName 
    , EventOriginalSeverity=LogSeverity
    , SrcNatIpAddr=SourceTranslatedAddress
    , DstNatIpAddr=DestinationTranslatedAddress
    , PaloAltoFlags=FlexString1 // Flags
| extend
  EventVendor="Palo Alto"
    ,EventProduct="PanOS"
    , DstBytes=tolong(ReceivedBytes) 
    , SrcBytes=tolong(SentBytes)      
    , NetworkProtocol=toupper(Protocol)
    , NetworkBytes=tolong(FlexNumber1)
    , SrcUsernameType=case(isempty(SrcUsername), "", SrcUsername contains "@", "UPN", "Simple")
    , DstUsernameType=case(isempty(DstUsername), "", DstUsername contains "@", "UPN", "Simple")
    , EventType="NetworkSession"
    , EventCount=toint(1)
    , EventResult=case(DeviceAction=="allow","Success","Failure")
    // -- Adjustment to support both old and new CSL fields.
    , NetworkPackets = coalesce(
        tolong(column_ifexists("FieldDeviceCustomNumber2", long(null))),
        tolong(column_ifexists("DeviceCustomNumber2",long(null)))
      )
    , NetworkSessionId = coalesce(
        tostring(column_ifexists("FieldDeviceCustomNumber1", long(null))),
        tostring(column_ifexists("DeviceCustomNumber1",long(null)))
      )
    , NetworkDuration= coalesce(
        toint(1000*column_ifexists("FieldDeviceCustomNumber3", 0)),
        toint(1000*column_ifexists("DeviceCustomNumber3",0)),
        int(null)
      )
    , EventSchemaVersion="0.2.3"
    , EventSchema="NetworkSession"
    , EventSeverity = "Informational"
  | extend hostelements=split(Dvc,'.')
  | extend DvcHostname=tostring(hostelements[0])
        , DvcDomain=strcat_array( array_slice(hostelements,1,-1), '.')
  | extend DvcFQDN = iff(Dvc contains ".",Dvc,"" )
        , DvcDomainType=iff(Dvc contains ".","FQDN","" )
| project-away hostelements
| lookup Actions on DeviceAction
// Action post filtering
| where (array_length(dvcaction)==0 or DvcAction has_any (dvcaction))
| project-rename
    DstMacAddr=DestinationMACAddress
    , SrcMacAddr=SourceMACAddress
    , DstIpAddr=DestinationIP
    , DstPortNumber=DestinationPort
    , DstNatPortNumber=DestinationTranslatedPort
  , SrcPortNumber=SourcePort
    , SrcIpAddr=SourceIP
  , SrcNatPortNumber=SourceTranslatedPort
  , DvcOutboundInterface=DeviceOutboundInterface
  , DvcInboundInterface=DeviceInboundInterface
  , EventMessage=Message
  , DvcOriginalAction=DeviceAction
// -- Aliases
| extend
  IpAddr = SrcIpAddr,
  Rule=NetworkRuleName,
  Dst=DstIpAddr,
  // Host=DstHostname,
  User=DstUsername,
  Duration=NetworkDuration,
  SessionId=NetworkSessionId,
  EventEndTime =EventStartTime,
  Src=SrcIpAddr
  | project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, Process*, ReceiptTime, ReceivedBytes, Remote*, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, EventOutcome, FieldDevice*, ExtID, Reason, Activity, Computer, OriginalLogSeverity, PaloAltoFlags, Protocol
};
NWParser(starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionPaloAltoCortexDataLake
// Description: This ASIM parser supports normalizing NetworkSession logs from Palo Alto Cortex Data Lake to the ASIM NetworkSession normalized schema. These events are captured through the Palo Alto Networks CDL data connector that ingests CDL logs into Microsoft Sentinel.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionPaloAltoCortexDataLake(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let EventSeverityLookup = datatable (LogSeverity: string, EventSeverity: string)
[
    "0", "Low",
    "1", "Low",
    "2", "Low",
    "3", "Low",
    "4", "Low",
    "5", "Low",
    "6", "Medium",
    "7", "Medium",
    "8", "Medium",
    "9", "High",
    "10", "High"
];
let EventResultDvcActionLookup = datatable (
    DeviceAction: string,
    DvcAction: string,
    EventResult: string
)
    [
    "allow", "Allow", "Success",
    "deny", "Deny", "Failure",
    "reset client", "Reset Source", "Failure",
    "reset server", "Reset Destination", "Failure",
    "reset both", "Reset", "Failure",
    "drop", "Drop", "Failure",
    "drop ICMP", "Drop ICMP", "Failure",
    "reset-both", "Reset", "Failure"
];
let EventResultDetailsLookup = datatable(Reason: string, EventResultDetails: string)[
    "threat", "Reset",
    "policy-deny", "Unknown",
    "decrypt-cert-validation", "Terminated",
    "decrypt-unsupport-param", "Terminated",
    "decrypt-error", "Terminated",
    "tcp-rst-from-client", "Reset",
    "tcp-rst-from-server", "Reset",
    "resources-unavailable", "Unknown",
    "tcp-fin", "Unknown",
    "tcp-reuse", "Unknown",
    "decoder", "Unknown",
    "aged-out", "Unknown",
    "unknown", "Unknown",
    "n/a", "NA",
];
let ThreatRiskLevelLookup = datatable(PanOSApplicationRisk: string, ThreatRiskLevel: int)
[
    "1", 20,
    "2", 40,
    "3", 60,
    "4", 80,
    "5", 100
];
let parser=(
    disabled: bool=false, 
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null), 
    eventresult: string='*', 
    srcipaddr_has_any_prefix: dynamic=dynamic([]),
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]), 
    hostname_has_any: dynamic=dynamic([]),
    dstportnumber: int=int(null),
    dvcaction: dynamic=dynamic([])
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    CommonSecurityLog
    | where not(disabled)
        and (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
        and DeviceVendor == "Palo Alto Networks" and DeviceProduct == "LF"
        and DeviceEventClassID == "TRAFFIC"
        and (array_length(hostname_has_any) == 0 or AdditionalExtensions has_any (hostname_has_any))
        and (isnull(dstportnumber) or toint(DestinationPort) == dstportnumber)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(coalesce(DeviceCustomIPv6Address2, SourceIP), src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(coalesce(DeviceCustomIPv6Address3, DestinationIP), dst_or_any)
    | extend 
        ASimMatchingIpAddr=case(
                      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                      "-",
                      temp_SrcMatch and temp_DstMatch,
                      "Both",
                      temp_SrcMatch,
                      "SrcIpAddr",
                      temp_DstMatch,
                      "DstIpAddr",
                      "No match"
                  )
    | where ASimMatchingIpAddr != "No match"
    | parse-kv AdditionalExtensions as (PanOSSessionStartTime: string, PanOSDestinationDeviceHost: string, PanOSSourceDeviceHost: string, PanOSDestinationUUID: string, PanOSDestinationLocation: string, PanOSSourceUUID: string, PanOSDestinationDeviceMac: string, PanOsBytes: long, PanOSIsClienttoServer: string, PanOSSourceLocation: string, PanOSSourceDeviceMac: string, PanOSPacketsReceived: long, PanOSPacketsSent: long, PanOSRuleUUID: int, PanOSApplicationCategory: string, PanOSApplicationSubcategory: string, PanOSChunksReceived: string, PanOSChunksSent: string, PanOSChunksTotal: string, PanOSApplicationContainer: string, PanOSDestinationDeviceCategory: string, PanOSLinkChangeCount: string, PanOSLinkSwitches: string, PanOSLogSource: string, PanOSNSSAINetworkSliceDifferentiator: string, PanOSNSSAINetworkSliceType: string, PanOSOutboundInterfaceDetailsPort: string, PanOSOutboundInterfaceDetailsSlot: string, PanOSOutboundInterfaceDetailsType: string, PanOSOutboundInterfaceDetailsUnit: string, PanOSParentSessionID: string, PanOsRuleUUID: string, PanOSSourceDeviceOS: string, PanOSSourceDeviceOSFamily: string, PanOSSourceDeviceOSVersion: string, PanOSSourceDeviceCategory: string, PanOSVirtualSystemID: string, PanOSVirtualSystemName: string, PanOSCortexDataLakeTenantID: string, PanOSApplicationRisk: string, PanOSIsSaaSApplication: string) with (pair_delimiter=";", kv_delimiter="=")
    | extend 
        temp_is_MatchSrcHostname = PanOSSourceDeviceHost has_any (hostname_has_any),
        temp_is_MatchDstHostname = PanOSDestinationDeviceHost has_any (hostname_has_any)
    | extend ASimMatchingHostname = case(
                                    array_length(hostname_has_any) == 0,
                                    "-",
                                    temp_is_MatchSrcHostname and temp_is_MatchDstHostname,
                                    "Both",
                                    temp_is_MatchSrcHostname,
                                    "SrcHostname",
                                    temp_is_MatchDstHostname,
                                    "DstHostname",
                                    "No match"
                                )
    | where ASimMatchingHostname != "No match"
    | invoke _ASIM_ResolveDvcFQDN('DeviceName')
    | invoke _ASIM_ResolveDstFQDN('PanOSDestinationDeviceHost')
    | invoke _ASIM_ResolveSrcFQDN('PanOSSourceDeviceHost')
    | lookup EventResultDvcActionLookup on DeviceAction
    // post-filtering
    | where (eventresult == "*" or eventresult == EventResult)
      and (array_length(dvcaction)==0 or DvcAction has_any (dvcaction))
    | lookup EventSeverityLookup on LogSeverity
    | lookup EventResultDetailsLookup on Reason
    | lookup ThreatRiskLevelLookup on PanOSApplicationRisk
    | extend
        EventStartTime = todatetime(PanOSSessionStartTime),
        SrcIpAddr = coalesce(SourceIP, DeviceCustomIPv6Address2),
        DstIpAddr = coalesce(DestinationIP, DeviceCustomIPv6Address3),
        NetworkSessionId = tostring(FieldDeviceCustomNumber1),
        NetworkDuration = toint(FieldDeviceCustomNumber3),
        DstBytes = tolong(ReceivedBytes),
        SrcBytes = tolong(SentBytes),
        SrcDomain = coalesce(SourceNTDomain, SrcDomain),
        DstDomain = coalesce(DestinationNTDomain, DstDomain),
        AdditionalFields = bag_pack(
                      "urlcategory",
                      DeviceCustomString2,
                      "virtualLocation",
                      DeviceCustomString3,
                      "PanOSApplicationCategory",
                      PanOSApplicationCategory,
                      "PanOSApplicationSubcategory",
                      PanOSApplicationSubcategory,
                      "PanOSChunksReceived",
                      PanOSChunksReceived,
                      "PanOSChunksSent",
                      PanOSChunksSent,
                      "PanOSChunksTotal",
                      PanOSChunksTotal,
                      "PanOSApplicationContainer",
                      PanOSApplicationContainer,
                      "PanOSDestinationDeviceCategory",
                      PanOSDestinationDeviceCategory,
                      "PanOSIsClienttoServer",
                      PanOSIsClienttoServer,
                      "PanOSLinkChangeCount",
                      PanOSLinkChangeCount,
                      "PanOSLinkSwitches",
                      PanOSLinkSwitches,
                      "PanOSLogSource",
                      PanOSLogSource,
                      "PanOSNSSAINetworkSliceDifferentiator",
                      PanOSNSSAINetworkSliceDifferentiator,
                      "PanOSNSSAINetworkSliceType",
                      PanOSNSSAINetworkSliceType,
                      "PanOSOutboundInterfaceDetailsPort",
                      PanOSOutboundInterfaceDetailsPort,
                      "PanOSOutboundInterfaceDetailsSlot",
                      PanOSOutboundInterfaceDetailsSlot,
                      "PanOSOutboundInterfaceDetailsType",
                      PanOSOutboundInterfaceDetailsType,
                      "PanOSOutboundInterfaceDetailsUnit",
                      PanOSOutboundInterfaceDetailsUnit,
                      "PanOSParentSessionID",
                      PanOSParentSessionID,
                      "PanOsRuleUUID",
                      PanOsRuleUUID,
                      "PanOSSourceDeviceOS",
                      PanOSSourceDeviceOS,
                      "PanOSSourceDeviceOSFamily",
                      PanOSSourceDeviceOSFamily,
                      "PanOSSourceDeviceOSVersion",
                      PanOSSourceDeviceOSVersion,
                      "PanOSSourceDeviceCategory",
                      PanOSSourceDeviceCategory,
                      "PanOSVirtualSystemID",
                      PanOSVirtualSystemID,
                      "PanOSVirtualSystemName",
                      PanOSVirtualSystemName
                  ),
        TcpFlagsFin = iff(Reason== "tcp-fin", true, false),
        TcpFlagsRst = iff(Reason in("tcp-rst-from-client", "tcp-rst-from-server"), true, false)
    | project-rename
        DvcIpAddr = Computer,
        EventUid = _ItemId,
        DstDvcId = PanOSDestinationUUID,
        DstGeoCountry = PanOSDestinationLocation,
        DstMacAddr = PanOSDestinationDeviceMac,
        DstNatIpAddr = DestinationTranslatedAddress,
        DstNatPortNumber = DestinationTranslatedPort,
        DstPackets = PanOSPacketsReceived,
        DstPortNumber = DestinationPort,
        DstUsername = DestinationUserName,
        DvcId = DeviceExternalID,
        DvcOriginalAction = DeviceAction,
        EventOriginalSeverity = LogSeverity,
        DstZone = DeviceCustomString5,
        EventOriginalType = DeviceEventClassID,
        EventOriginalUid = ExtID,
        EventProductVersion = DeviceVersion,
        NetworkPackets = FieldDeviceCustomNumber2,
        NetworkRuleName = DeviceCustomString1,
        SrcDvcId = PanOSSourceUUID,
        SrcGeoCountry = PanOSSourceLocation,
        SrcMacAddr = PanOSSourceDeviceMac,
        SrcNatIpAddr = SourceTranslatedAddress,
        SrcNatPortNumber = SourceTranslatedPort,
        SrcPackets = PanOSPacketsSent,
        SrcPortNumber = SourcePort,
        SrcUsername = SourceUserName,
        SrcZone = DeviceCustomString4,
        DvcScopeId = PanOSCortexDataLakeTenantID,
        EventOriginalSubType = Activity,
        EventOriginalResultDetails = Reason,
        SrcUserId = SourceUserID,
        DstUserId = DestinationUserID,
        DvcInboundInterface = DeviceInboundInterface,
        DvcOutboundInterface = DeviceOutboundInterface,
        SrcAppName = ApplicationProtocol,
        ThreatOriginalRiskLevel = PanOSApplicationRisk
    | extend
        Dvc = coalesce(DvcFQDN, DvcId, DvcHostname, DvcIpAddr),
        EventEndTime = EventStartTime,
        Dst = coalesce(DstDvcId, DstHostname, DstIpAddr),
        Src = coalesce(SrcDvcId, SrcHostname, SrcIpAddr),
        DstUserType = _ASIM_GetUserType(DstUsername, ""),
        NetworkProtocol = toupper(Protocol),
        NetworkBytes = SrcBytes + DstBytes,
        NetworkProtocolVersion = case(
                            DstIpAddr contains ".",
                            "IPv4",       
                            DstIpAddr contains ":",
                            "IPv6", 
                            ""
                        ),
        NetworkDirection = iff(PanOSIsClienttoServer == "true", "Outbound", "Inbound"),
        Rule = NetworkRuleName,
        SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
        DstUsernameType = _ASIM_GetUsernameType(DstUsername),
        DvcIdType = iff(isnotempty(DvcId), "Other", ""),
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        Duration = NetworkDuration,
        IpAddr = SrcIpAddr,
        SessionId = NetworkSessionId,
        User = DstUsername,
        Hostname = DstHostname,
        SrcDvcIdType = iff(isnotempty(SrcDvcId), "Other", ""),
        DstDvcIdType = iff(isnotempty(DstDvcId), "Other", ""),
        SrcDomainType = iff(isnotempty(SourceNTDomain), "Windows", SrcDomainType),
        DstDomainType = iff(isnotempty(DestinationNTDomain), "Windows", DstDomainType),
        SrcUserIdType = iff(isnotempty(SrcUserId), "UID", ""),
        DstUserIdType = iff(isnotempty(DstUserId), "UID", ""),
        SrcAppType = case(isnotempty(SrcAppName) and PanOSIsSaaSApplication == "true", "SaaS Application",
                            isnotempty(SrcAppName) and PanOSIsSaaSApplication == "false", "Other",
                            "")
    | extend
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventProduct = "Cortex Data Lake",
        EventVendor = "Palo Alto"
    | project-away
        Source*,
        Destination*,
        Device*,
        AdditionalExtensions,
        CommunicationDirection,
        EventOutcome,
        PanOS*,
        PanOs*,
        Protocol,
        SimplifiedDeviceAction,
        temp*,
        ExternalID,
        Message,
        EndTime,
        FieldDevice*,
        Flex*,
        File*,
        Old*,
        MaliciousIP*,
        OriginalLogSeverity,
        Process*,
        ReceivedBytes,
        SentBytes,
        Remote*,
        Request*,
        StartTime,
        TenantId,
        ReportReferenceLink,
        ReceiptTime,
        Indicator*,
        _ResourceId,
        ThreatConfidence,
        ThreatDescription,
        ThreatSeverity
};
parser(
    disabled=disabled,
    starttime=starttime, 
    endtime=endtime,
    eventresult=eventresult,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix,
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix,
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    hostname_has_any=hostname_has_any,
    dstportnumber=dstportnumber,
    dvcaction=dvcaction
)
}



//
// Function Name: vimNetworkSessionSentinelOne
// Description: This ASIM parser supports normalizing SentinelOne logs to the ASIM Network Session normalized schema. SentinelOne events are captured through SentinelOne data connector which ingests SentinelOne server objects such as Threats, Agents, Applications, Activities, Policies, Groups, and more events into Microsoft Sentinel through the REST API.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionSentinelOne(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let NetworkDirectionLookup = datatable (
    alertInfo_netEventDirection_s: string, 
    NetworkDirection: string
)[
    "OUTGOING", "Outbound",
    "INCOMING", "Inbound",
];
let DeviceTypeLookup = datatable (
    agentDetectionInfo_machineType_s: string,
    SrcDeviceType: string
)
    [
    "desktop", "Computer",
    "server", "Computer",
    "laptop", "Computer",
    "kubernetes node", "Other",
    "unknown", "Other"
];
let ThreatConfidenceLookup_undefined = datatable(
    alertInfo_analystVerdict_s: string,
    ThreatConfidence_undefined: int
)
    [
    "FALSE_POSITIVE", 5,
    "Undefined", 15,
    "SUSPICIOUS", 25,
    "TRUE_POSITIVE", 33 
];
let ThreatConfidenceLookup_suspicious = datatable(
    alertInfo_analystVerdict_s: string,
    ThreatConfidence_suspicious: int
)
    [
    "FALSE_POSITIVE", 40,
    "Undefined", 50,
    "SUSPICIOUS", 60,
    "TRUE_POSITIVE", 67 
];
let ThreatConfidenceLookup_malicious = datatable(
    alertInfo_analystVerdict_s: string,
    ThreatConfidence_malicious: int
)
    [
    "FALSE_POSITIVE", 75,
    "Undefined", 80,
    "SUSPICIOUS", 90,
    "TRUE_POSITIVE", 100 
];
let parser=(
    disabled: bool=false, 
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null), 
    eventresult: string='*', 
    srcipaddr_has_any_prefix: dynamic=dynamic([]),
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]), 
    hostname_has_any: dynamic=dynamic([]),
    dstportnumber: int=int(null),
    dvcaction: dynamic=dynamic([])
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let alldata = SentinelOne_CL
    | where not(disabled) 
        and (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
        and event_name_s == "Alerts."
        and alertInfo_eventType_s == "TCPV4"
        and (eventresult == "*" or eventresult == "Success")
        and (isnull(dstportnumber) or toint(alertInfo_dstPort_s) == dstportnumber)
        and (array_length(hostname_has_any) == 0 or agentDetectionInfo_name_s has_any (hostname_has_any))
        and (array_length(dvcaction) == 0 or dvcaction has_any ("Allow"))
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(alertInfo_srcIp_s, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(alertInfo_dstIp_s, dst_or_any)
    | extend 
        ASimMatchingIpAddr=case(
                      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                      "-",
                      temp_SrcMatch and temp_DstMatch,
                      "Both",
                      temp_SrcMatch,
                      "SrcIpAddr",
                      temp_DstMatch,
                      "DstIpAddr",
                      "No match"
                  ),
        ASimMatchingHostname = "SrcHostname"
    | where ASimMatchingIpAddr != "No match";
    let undefineddata = alldata
        | where ruleInfo_treatAsThreat_s == "UNDEFINED"
        | lookup ThreatConfidenceLookup_undefined on alertInfo_analystVerdict_s;
    let suspiciousdata = alldata
        | where ruleInfo_treatAsThreat_s == "Suspicious"
        | lookup ThreatConfidenceLookup_suspicious on alertInfo_analystVerdict_s;
    let maliciousdata = alldata
        | where ruleInfo_treatAsThreat_s == "Malicious"
        | lookup ThreatConfidenceLookup_malicious on alertInfo_analystVerdict_s;
    union undefineddata, suspiciousdata, maliciousdata
    | lookup NetworkDirectionLookup on alertInfo_netEventDirection_s
    | lookup DeviceTypeLookup on agentDetectionInfo_machineType_s
    | invoke _ASIM_ResolveDvcFQDN('agentDetectionInfo_name_s')
    | extend 
        DstPortNumber = toint(alertInfo_dstPort_s),
        SrcPortNumber = toint(alertInfo_srcPort_s),
        ThreatConfidence = coalesce(ThreatConfidence_undefined, ThreatConfidence_suspicious, ThreatConfidence_malicious)
    | project-rename
        EventStartTime = sourceProcessInfo_pidStarttime_t,
        DstIpAddr = alertInfo_dstIp_s,
        EventUid = _ItemId,
        SrcIpAddr = alertInfo_srcIp_s,
        DvcId = agentDetectionInfo_uuid_g,
        DvcOs = agentDetectionInfo_osName_s,
        DvcOsVersion = agentDetectionInfo_osRevision_s,
        EventOriginalSeverity = ruleInfo_severity_s,
        EventOriginalUid = alertInfo_dvEventId_s,
        SrcProcessName = sourceProcessInfo_name_s,
        SrcProcessId = sourceProcessInfo_pid_s,
        SrcUsername = sourceProcessInfo_user_s,
        ThreatOriginalConfidence = ruleInfo_treatAsThreat_s
    | extend
        EventEndTime = EventStartTime,
        Dst = DstIpAddr,
        DvcIpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        SrcHostname = DvcHostname,
        SrcDvcId = DvcId,
        IpAddr = SrcIpAddr,
        EventSeverity = iff(EventOriginalSeverity == "Critical", "High", EventOriginalSeverity),
        SrcDvcIdType = iff(isnotempty(DvcId), "Other", ""),
        DvcIdType = iff(isnotempty(DvcId), "Other", ""),
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        SrcUserType = _ASIM_GetUserType(SrcUsername, "")
    | extend
        Dvc = coalesce(DvcId, DvcHostname, DvcIpAddr),
        Hostname = SrcHostname
    | extend
        EventCount = int(1),
        EventProduct = "SentinelOne",
        EventResult = "Success",
        DvcAction = "Allow",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventResultDetails = "NA",
        EventType = "EndpointNetworkSession",
        EventVendor = "SentinelOne",
        NetworkProtocol = "TCP",
        NetworkProtocolVersion = "IPv4"
    | project-away
        *_d,
        *_s,
        *_g,
        *_t,
        *_b,
        _ResourceId,
        temp*,
        TenantId,
        RawData,
        Computer,
        MG,
        ManagementGroupName,
        SourceSystem,
        ThreatConfidence_*
};
parser(
    disabled=disabled,
    starttime=starttime, 
    endtime=endtime,
    eventresult=eventresult,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix,
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix,
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    hostname_has_any=hostname_has_any,
    dstportnumber=dstportnumber,
    dvcaction=dvcaction
)
}



//
// Function Name: vimNetworkSessionSonicWallFirewall
// Description: This ASIM parser supports filtering and normalizing SonicWall SonicOS ArcSight-formatted syslog data ingested by the Microsoft Sentinel to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionSonicWallFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let Actions=datatable(fw_action:string,DvcAction:string)
[ "reset client","Reset Source"
, "reset server","Reset Destination"
, "reset both", "Reset" 
, "allow","Allow"
, "\"forward\"","Allow"
, "\"mgmt\"","Other"
, "\"NA\"","Other"
, "deny","Deny"
, "\"drop\"", "Drop"
, "drop ICMP", "Drop ICMP"];
let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
let Parser=(starttime:datetime=datetime(null), endtime:datetime=datetime(null), srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]), dstportnumber:int=int(null), hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]), eventresult:string='*', disabled:bool=false){
CommonSecurityLog
| where (isnull(starttime) or TimeGenerated >= starttime) and (isnull(endtime) or TimeGenerated <= endtime)
| where not(disabled)
| where DeviceVendor == "SonicWall"
| where DeviceEventClassID !in (14, 97, 1382, 440, 441, 442, 646, 647, 734, 735)
| where ( isnotempty(SourceIP) and isnotempty(DestinationIP) )
| where (isnull(dstportnumber) or DestinationPort == dstportnumber) and (array_length(hostname_has_any) == 0)
| parse-kv AdditionalExtensions as (['gcat']:string, ['app']:string, ['arg']:string, ['dstV6']:string, ['srcV6']:string, ['snpt']:string, ['dnpt']:string, ['susr']:string,['appName']:string, ['appcat']:string, ['appid']:string, ['sid']:string, ['catid']:string, ['ipscat']:string, ['ipspri']:string, ['spycat']:string, ['spypri']:string, ['fw_action']:string, ['dpi']:string, ['bid']:string, ['af_action']:string, ['af_polid']:string, ['af_policy']:string, ['af_type']:string, ['af_service']:string, ['af_object']:string, ['contentObject']:string, ['fileid']:string, ['uuid']:string) with (pair_delimiter=";", kv_delimiter="=")
| extend
    SourceIP = coalesce(SourceIP, srcV6)
  , DestinationIP = coalesce(DestinationIP, dstV6)
| where gcat in (3, 5, 6, 10) // Include only these event categories.
| extend
    temp_SrcMatch=has_any_ipv4_prefix(SourceIP, src_or_any)
  , temp_DstMatch=has_any_ipv4_prefix(DestinationIP, dst_or_any)
// Filter by source/dest. https://learn.microsoft.com/en-us/azure/sentinel/normalization-schema-network
| extend ASimMatchingIpAddr=case(
                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 , "-",
                              temp_SrcMatch and temp_DstMatch, "Both",
                              temp_SrcMatch, "SrcIpAddr",
                              temp_DstMatch, "DstIpAddr",
                              "No match"
                          )
| where ASimMatchingIpAddr != "No match" 
| project-away temp_*
| extend ASimMatchingHostname = case(
                                  array_length(hostname_has_any) == 0 , "-",
                                  DestinationHostName has_any (hostname_has_any), "DestinationHostname",
                                  "No match"
                                  )
| extend fw_action = column_ifexists("fw_action", "") // Firewall Action, such as drop, forward, mgmt, NA
| lookup Actions on fw_action
  | where (array_length(dvcaction) == 0 or DvcAction has_any(dvcaction))
// Sets the mandatory EventResult based on the DvcAction.
| extend EventResult = case(DvcAction == "Allow", "Success",
                          DvcAction == "Management", "NA",
                          DvcAction == "NA", "NA",
                          DvcAction == "Other", "NA",
                          "Failure"
                          )
| where (eventresult == "*" or eventresult == "" or (eventresult has_any("Success", "Failure", "NA") and EventResult has eventresult))
| extend sosLogMsgSeverity = case(LogSeverity == 10, "Emergency (0)",
                                            LogSeverity == 9, "Alert (1)",
                                            LogSeverity == 8, "Critical (2)",
                                            LogSeverity == 7, "Error (3)",
                                            LogSeverity == 6, "Warning (4)",
                                            LogSeverity == 5, "Notice (5)",
                                            LogSeverity == 4, "Info (6)/Debug (7)",
                                            LogSeverity == 3, "Not Mapped (3)",
                                            LogSeverity == 2, "Not Mapped (2)",
                                            LogSeverity == 1, "Not Mapped (1)",
                                            "Not Mapped"
                                            )
| extend EventSeverity = case(tolong(LogSeverity) <= 4, "Informational"
                              , tolong(LogSeverity) <= 6, "Low"
                              , tolong(LogSeverity) <= 8, "Medium"
                              , tolong(LogSeverity) > 8, "High"
                              , ""
                              )
| extend NetworkProtocolVersion = case(DestinationIP has ".", "IPv4"
                                      , DestinationIP has ":", "IPv6"
                                      , ""
                                      )
  , NetworkProtocol = toupper(iff(Protocol contains "-" and Protocol !contains "/", toupper(trim_start(@".*-", Protocol)), toupper(trim_end(@"/.*", Protocol))))
  , NetworkApplicationProtocol = tostring(toupper(trim_start(@".*/", Protocol)))
  , EventOriginalType = DeviceEventClassID
| project-rename
  DstMacAddr = DestinationMACAddress
  , SrcMacAddr = SourceMACAddress
  , DstIpAddr = DestinationIP
  , SrcIpAddr = SourceIP
  , DstPortNumber = DestinationPort
  , SrcPortNumber = SourcePort
  , EventMessage = Activity
  , sosEventMessageDetail = Message
  , EventProductVersion = DeviceVersion
  , sosSerialNumber = Computer
  , DvcOutboundInterface = DeviceOutboundInterface
  , DvcInboundInterface = DeviceInboundInterface
  , sosApplicationID = ApplicationProtocol // Application ID number (when Flow Reporting is enabled).
  , sosCFSFullString = Reason // CFS Category ID and Name
  , NetworkRuleName = DeviceCustomString1 // Rule ID. Identify a policy or rule associated with an event.
  , sosSourceVPNPolicyName = DeviceCustomString2 // Displays the source VPN policy name associated with the event.
  , sosDestinationVPNPolicyName = DeviceCustomString3 // Displays the destination VPN policy name associated with the event.
  , sosLogMsgNote = DeviceCustomString6 // "Note" field. Additional information that is application-dependent.
  , SrcNatIpAddr = DeviceCustomString1Label // NAT'ed source IP4/IPv6 address.
  , DstNatIpAddr = DeviceCustomString2Label // NAT'ed destination IPv4/IPv6 address.
  , sosSourceZone = DeviceCustomString3Label // Source Zone on Gen7. Src Zone Type on Gen6.
  , sosDestinationZone = DeviceCustomString4Label // Destination Zone on Gen7. Dest Zone Type (Trusted/Untrusted, etc.) on Gen6.
  , sosUserSessionType = DeviceCustomString5Label // String indicating the user session type, determined by the auth mechanism.
  , sosUserSessionDuration = DeviceCustomString6Label // User session duration in seconds.
  , NetworkIcmpType = FieldDeviceCustomNumber1 // ICMP Type
  , NetworkIcmpCode = FieldDeviceCustomNumber2 // ICMP Code
  , SrcUsername = SourceUserName
  , ThreatOriginalConfidence = ThreatConfidence
| extend sosLogMsgCategory = case(gcat == 1, "System (1)",
                                              gcat == 2, "Log (2)",
                                              gcat == 3, "Security Services (3)",
                                              gcat == 4, "Users (4)",
                                              gcat == 5, "Firewall Settings (5)",
                                              gcat == 6, "Network (6)",
                                              gcat == 7, "VPN (7)",
                                              gcat == 8, "High Availability (8)",
                                              gcat == 9, "3G/4G, Modem, and Module (9)",
                                              gcat == 10, "Firewall (10)",
                                              gcat == 11, "Wireless (11)",
                                              gcat == 12, "VoIP (12)",
                                              gcat == 13, "SSL VPN (13)",
                                              gcat == 14, "Anti-Spam (14)",
                                              gcat == 15, "WAN Acceleration (15)",
                                              gcat == 16, "Object (16)",
                                              gcat == 17, "SD-WAN (17)",
                                              gcat == 18, "Multi-Instance (18)",
                                              gcat == 19, "Unified Policy Engine (19)",
                                              "Log Category Not Mapped"
                                              )
| extend sosLegacyMessageCategory = case(DeviceEventCategory == 0, "None (0)",
                                            DeviceEventCategory == 1, "System Maintenance (1)",
                                            DeviceEventCategory == 2, "System Errors (2)",
                                            DeviceEventCategory == 4, "Blocked Web Sites (4)",
                                            DeviceEventCategory == 8, "Blocked Java Etc. (8)",
                                            DeviceEventCategory == 16, "User Activity (16)",
                                            DeviceEventCategory == 32, "Attacks (32)",
                                            DeviceEventCategory == 64, "Dropped TCP (64)",
                                            DeviceEventCategory == 128, "Dropped UDP (128)",
                                            DeviceEventCategory == 256, "Dropped ICMP (256)",
                                            DeviceEventCategory == 512, "Network Debug (512)",
                                            DeviceEventCategory == 1024, "Connection Closed (1024)",
                                            DeviceEventCategory == 2048, "Dropped LAN TCP (2048)",
                                            DeviceEventCategory == 4096, "Dropped LAN UDP (4096)",
                                            DeviceEventCategory == 8192, "Dropped LAN ICMP (8192)",
                                            DeviceEventCategory == 32768, "Modem Debug (32768)",
                                            DeviceEventCategory == 65536, "VPN Tunnel Status (65536)",
                                            DeviceEventCategory == 131072, "IEEE 802.11 Management (131072)",
                                            DeviceEventCategory == 262144, "Connection Opened (262144)",
                                            DeviceEventCategory == 524288, "System Environment (524288)",
                                            DeviceEventCategory == 1048576, "Expanded - VoIP Activity (1048576)",
                                            DeviceEventCategory == 2097152, "Expanded - WLAN IDS Activity (2097152)",
                                            DeviceEventCategory == 4194304, "Expanded - SonicPoint Activity (4194304)",
                                            DeviceEventCategory == 8388608, "Expanded - Unified Policy Engine (8388608)",
                                            "Legacy Category Not Mapped"
                                            )
| extend sosIPSPriority = case(ipspri == 1, "High (1)",
                                            ipspri == 2, "Medium (2)",
                                            ipspri == 3, "Low (3)",
                                            ""
                                            )
| extend sosAntiSpywarePriority = case(spypri == 1, "High (1)",
                                            spypri == 2, "Medium (2)",
                                            spypri == 3, "Low (3)",
                                            ""
                                            )
| extend
    EventVendor = "SonicWall"
  , EventProduct = "Firewall"
  , DvcOs = "SonicOS"
  , DvcOsVersion = EventProductVersion
  , DvcIdType = "Other"
  , Dvc = sosSerialNumber
  , DvcDescription = DeviceProduct
  , NetworkIcmpType = tostring(NetworkIcmpType)
  , NetworkIcmpCode = toint(NetworkIcmpCode)
  , Rule = NetworkRuleName
  , NetworkBytes = tolong(coalesce(toint(ReceivedBytes), 0) + coalesce(toint(SentBytes), 0))
  , sosIPSFullString = ipscat
  , ipscat = extract(@'^"?([a-zA-Z-\/]+)', 1, ipscat) // IPS Category/Signature
  , sosIPSSignatureName = extract(@'[ ](.*)\S', 1, ipscat) // IPS Signature name
  , FileSize = tolong(coalesce(FileSize, long(null)))
  , sosAppControlFileName = extract(@'.*Filename: (.*)\"', 1, sosEventMessageDetail) // App Control Filename Logging
  , sosCaptureATPVerdict = extract(@'Gateway Anti-Virus Status: (.*)\. ', 1, sosEventMessageDetail)
  , sosGAVSignatureName = extract(@'Gateway Anti-Virus Alert: (.*) blocked\.', 1, sosEventMessageDetail)
  , sosASWSignatureName = extract(@'Anti-Spyware Detection Alert: (.*)\. ', 1, sosEventMessageDetail)
  , sosCountry = extract(@'Country Name:(.*)\"$', 1, sosEventMessageDetail)
  , SrcZone = sosSourceZone
  , DstZone = sosDestinationZone
  , EventOriginalSeverity = LogSeverity
  , Dst = DstIpAddr
  , Src = SrcIpAddr
  , IpAddr = SrcIpAddr
  , sosCFSCategoryID = extract(@'(\d+)\s', 1, coalesce(sosCFSFullString, "")) // Application Name from App Control
  , sosCFSCategoryName = extract(@'.*-("(.*))', 1, coalesce(sosCFSFullString, "")) // Application Name from App Control
  , sosCFSPolicyName = extract(@'Policy: (.*), Info:', 1, coalesce(sosLogMsgNote, ""))
  , EventStartTime = coalesce(todatetime(StartTime), TimeGenerated)
  , EventEndTime = coalesce(todatetime(EndTime), TimeGenerated)
  , EventType = "NetworkSession"
  , EventSchemaVersion = "0.2.6"
  , EventSchema = "NetworkSession"
  , EventCount = toint(1)
  , EventUid = _ItemId
  , EventResultDetails = "NA"
  , ThreatConfidence = coalesce(toint(ThreatOriginalConfidence), int(null))
| extend
      SrcUsername = coalesce(susr, SrcUsername)
    , FileName = coalesce(FileName, sosAppControlFileName)
    , NetworkDirection = case(SrcZone == "" and DstZone == "", "NA"
                              , SrcZone == "WAN" and (DstZone == "WAN" and DstIpAddr !has ".255"), "Inbound"
                              , SrcZone == "WAN" and DstZone == "WAN", "External"
                              , SrcZone == "WAN" and DstZone != "WAN", "Inbound"
                              , SrcZone == "VPN" and DstZone == "WAN", "Outbound"
                              , SrcZone == "VPN" and DstZone != "WAN", "Inbound"
                              , DstZone == "MULTICAST", "NA"
                              , DstZone == "WAN", "Outbound"
                              , "Local"
                              )
| extend
    SrcUsernameType = case(SrcUsername has "=", "DN",
                                  SrcUsername has "\\", "Windows",
                                  SrcUsername has "@", "UPN",
                                  SrcUsername == "Unknown (external IP)", "",
                                  SrcUsername == "Unknown (SSO bypassed)", "",
                                  isnotempty(SrcUsername), "Simple",
                                  ""
                                  )
    , ThreatField = case(isnotempty(ThreatOriginalConfidence) and NetworkDirection == "Outbound", "SrcIpAddr"
                        , isnotempty(ThreatOriginalConfidence) and NetworkDirection == "Inbound", "DstIpAddr"
                        , ""
                        )
| extend
    ThreatIpAddr = case(ThreatField == "SrcIpAddr", SrcIpAddr
                        , ThreatField == "DstIpAddr", DstIpAddr
                        , ""
                        )
| extend
  SrcGeoCountry = iff(NetworkDirection == "Inbound", sosCountry, "")
  , DstGeoCountry = iff(NetworkDirection == "Outbound", sosCountry, "")
  , SrcAppName = iff(NetworkDirection in ("Inbound", "Local", "NA"), coalesce(appcat, appName), "")
  , DstAppName = iff(NetworkDirection in ("Outbound", "Local", "NA"), coalesce(appcat, appName), "")
  , SrcAppId = iff(NetworkDirection in ("Inbound", "Local", "NA"), sid, "")
  , DstAppId = iff(NetworkDirection in ("Outbound", "Local", "NA"), sid, "")
| extend
  SrcAppType = case(isempty(SrcAppName), ""
                    , SrcAppName contains "\'General " or SrcAppName contains "\'Service ", "Service", "Other")
  , DstAppType = case(isempty(DstAppName), ""
                    , DstAppName contains "\'General " or DstAppName contains "\'Service ", "Service", "Other")
| project-rename
    sosReceivedPackets = DeviceCustomNumber1Label // DeviceCustomNumberXLabel (cnXLabel=)
  , sosSentPackets = DeviceCustomNumber2Label // DeviceCustomNumberXLabel (cnXLabel=)
| extend
    DstPackets = case(NetworkDirection == "Outbound", tolong(sosReceivedPackets)
                  , NetworkDirection == "Inbound", tolong(sosSentPackets)
                  , tolong(long(null))
                  )
  , SrcPackets = case(NetworkDirection == "Outbound", tolong(sosSentPackets)
                  , NetworkDirection == "Inbound", tolong(sosReceivedPackets)
                  , tolong(long(null))
                  )
| project-rename
    sosConnectionDuration = DeviceCustomNumber3Label // Applies to "Connection Closed"
  , sosUser = susr // Logged-in username associated with the log event.
  , sosAppRulePolicyId = af_polid // App Rule Policy ID.
  , sosAppRulePolicyName = af_policy // App Rule Policy Name.
  , sosAppRuleService = af_service // App Rule Service Name.
  , sosAppRuleType = af_type // App Rule Policy Type.
  , sosAppRuleObject = af_object // App Rule Object Name.
  , sosAppRuleObjectContent = contentObject // App Rule Object Content.
  , sosAppRuleAction = af_action
  , sosSourceIPv6Address = srcV6
  , sosDestinationIPv6Address = dstV6
  , sosAppFullString = appcat // The full "<CATEGORY> <APPNAME> -- <SIGNAME>" string.
  , sosAppIDNumber = app // Numeric Application ID. Not the same as "ApplicationProtocol".
  , sosAppID = appid // Application ID from App Control
  , sosAppCategoryID = catid // Application Category ID
  , sosAppSignatureID = sid // Application Signature ID
  , sosIPSCategoryName = ipscat // IPS Category Name
  , sosAntiSpywareCategory = spycat // Anti-Spyware Category
  , sosURLPathName = arg // URL. Represents the URL path name.
  , sosFileIdentifier = fileid // File hash or URL
  , sosDPIInspectedFlow = dpi // Indicates a flow was inspected by DPI. Applies only to Connection Closed messages.
  , DstNatPortNumber = dnpt
  , SrcNatPortNumber = snpt
  , sosBladeID = bid // Blade ID
  , sosUUID = uuid
  , sosFileName = FileName
  , DvcOriginalAction = fw_action
| extend
  ThreatName = coalesce(sosASWSignatureName, sosGAVSignatureName, sosIPSSignatureName, "")
  , ThreatId = coalesce(sosAppSignatureID, "")
  , ThreatCategory = coalesce(sosIPSCategoryName, sosAntiSpywareCategory, "")
  , DstNatPortNumber = toint(DstNatPortNumber)
  , SrcNatPortNumber = toint(SrcNatPortNumber)
| extend AdditionalFields = bag_pack(
  "AppRulePolicyId", sosAppRulePolicyId
  , "AppRulePolicyName", sosAppRulePolicyName
  , "AppRuleService", sosAppRuleService
  , "AppRuleType", sosAppRuleType
  , "AppRuleObject", sosAppRuleObject
  , "AppRuleObjectContent", sosAppRuleObjectContent
  , "AppRuleAction", sosAppRuleAction
  , "AppID", sosAppID
  , "AppCategoryID", sosAppCategoryID
  , "IPSCategoryName", sosIPSCategoryName
  , "AntiSpywareCategory", sosAntiSpywareCategory
  , "FileIdentifier", sosFileIdentifier
  , "DPIInspectedFlow", sosDPIInspectedFlow
  , "BladeID", sosBladeID
  , "UUID", sosUUID
  , "FileName", sosFileName
  , "FileSize", FileSize
  , "CaptureATPVerdict", sosCaptureATPVerdict
  , "CFSCategoryID", sosCFSCategoryID
  , "CFSCategoryName", sosCFSCategoryName
  , "CFSPolicyName", sosCFSPolicyName
  , "AppControlFileName", sosAppControlFileName
  , "IPSFullString", sosIPSFullString
  , "IPSSignatureName", sosIPSSignatureName
  , "LegacyMessageCategory", sosLegacyMessageCategory
  , "LogMsgCategory", sosLogMsgCategory
  , "LogMsgNote", sosLogMsgNote
  , "LogMsgSeverity", sosLogMsgSeverity
  , "SourceVPNPolicyName", sosSourceVPNPolicyName
  , "DestinationVPNPolicyName", sosDestinationVPNPolicyName
  , "EventMessageDetail", sosEventMessageDetail
  , "UserSessionType", sosUserSessionType
  )
| project-away
    DeviceEventCategory
  , gcat
  , RequestMethod
  , ipspri
  , spypri
  , sos*
  , RequestURL
  , Protocol
  , appName
  , AdditionalExtensions
  , Flex*
  , Indicator*
  , Malicious*
  , Field*
  , DeviceCustom*
  , Old*
  , File*
  , Source*
  , Destination*
  , Device*
  , SimplifiedDeviceAction
  , ExternalID
  , ExtID
  , TenantId
  , ProcessName
  , ProcessID
  , ExtID
  , OriginalLogSeverity
  , LogSeverity
  , EventOutcome
  , StartTime
  , EndTime
  , ReceiptTime
  , Remote*
  , ThreatDescription
  , ThreatSeverity
  , RequestContext
  , RequestCookies
  , CommunicationDirection
  , ReportReferenceLink
  , ReceivedBytes
  , SentBytes
  , _ResourceId
  , _ItemId
| project-reorder
    TimeGenerated
  , EventVendor
  , EventProduct
  , DvcDescription
  , Dvc
  , DvcOs
  , DvcOsVersion
};
Parser(starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionVectraAI
// Description: This ASIM parser supports filtering and normalizing Vectra AI Streams logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionVectraAI(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false,
    ['pack']:bool=false)
{
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null),
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]),
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]),
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false,
  pack:bool=false)
{
  let NetworkDirectionLookup = datatable(local_orig_b:bool, local_resp_b:bool, NetworkDirection:string)[
    false, true, 'Inbound',
    true, false, 'Outbound',
    true, true, 'Local',
    false, false, 'External'];
  let EventSubTypeLookup = datatable(conn_state_s:string, EventSubType:string)[
    "S1", 'Start',
    "SF", 'End'];
  let HostnameRegex = @'^[a-zA-Z0-9-]{1,61}$';
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
  VectraStream_CL
  | where (isnull(starttime) or TimeGenerated>=starttime)
    and   (isnull(endtime) or TimeGenerated<=endtime)
  | where not(disabled)
  | where metadata_type_s == 'metadata_isession'
  | project-away MG, ManagementGroupName, RawData, SourceSystem, TenantId
  | where array_length(dvcaction) == 0
  | where eventresult == "*"
  | where  (isnull(dstportnumber) or dstportnumber==id_resp_p_d)
    and (array_length(hostname_has_any)==0 
      or resp_domain_s has_any (hostname_has_any)
      or resp_hostname_s has_any (hostname_has_any)
      or orig_hostname_s has_any (hostname_has_any)
    )
  | extend temp_SrcMatch=has_any_ipv4_prefix(id_orig_h_s,src_or_any)
         , temp_DstMatch=has_any_ipv4_prefix(id_resp_h_s,dst_or_any)
  | extend ASimMatchingIpAddr=case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
                                temp_SrcMatch and temp_DstMatch, "Both",
                                temp_SrcMatch, "SrcIpAddr",
                                temp_DstMatch, "DstIpAddr",
                                "No match"
                            )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  | project-rename
      DstIpAddr = id_resp_h_s,
      DvcDescription = hostname_s,
      DstDescription = resp_hostname_s,
      SrcDescription = orig_hostname_s,
      // -- huid does not seem to be unique per device and not mapped for now
      // DstDvcId = resp_huid_s, 
      // SrcDvcId = orig_huid_s,
      DvcId = sensor_uid_s,
      // -- community id is just a hash of addresses and ports, and not unique for the session
      // NetworkSessionId = community_id_s,
      SrcIpAddr = id_orig_h_s,
      EventUid = _ItemId
  // -- the domain field may have invalid values. Most of them are IP addresses filtered out, but a small fraction are not filtered.
  | extend resp_domain_s = iff (ipv4_is_match(resp_domain_s, "0.0.0.0",0), "", resp_domain_s)
  | extend SplitRespDomain = split(resp_domain_s,".")
  | extend 
      DstDomain = tostring(strcat_array(array_slice(SplitRespDomain, 1, -1), '.')),
      DstFQDN = iif (array_length(SplitRespDomain) > 1, resp_domain_s, ''),
      DstDomainType = iif (array_length(SplitRespDomain) > 1, 'FQDN', '')
  | extend
      DstHostname = case (
          resp_domain_s != "", tostring(SplitRespDomain[0]),
          DstDescription startswith "IP-" or not(DstDescription matches regex HostnameRegex), "",
          DstDescription)
  | project-away SplitRespDomain
  | extend
      SrcHostname = iff (SrcDescription startswith "IP-" or not(SrcDescription matches regex HostnameRegex), "", SrcDescription),
      DvcHostname = iff (DvcDescription startswith "IP-" or not(DvcDescription matches regex HostnameRegex), "", DvcDescription),
      NetworkApplicationProtocol = toupper(service_s),
      NetworkProtocol = toupper(protoName_s),
      NetworkProtocolVersion = toupper(id_ip_ver_s),
      Dst = DstIpAddr,
      DstBytes = tolong(resp_ip_bytes_d),
      DstPackets = tolong(resp_pkts_d),
      DstPortNumber = toint(id_resp_p_d),
      DstVlanId = tostring(toint(resp_vlan_id_d)),
      EventCount = toint(1),
      EventEndTime = unixtime_milliseconds_todatetime(ts_d),
      EventOriginalSubType = tostring(split(metadata_type_s, '_')[1]),
      EventProduct = 'Vectra Stream',
      EventResult = 'Success',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.2',
      EventSeverity = 'Informational',
      EventStartTime = unixtime_milliseconds_todatetime(session_start_time_d),
      EventType = 'NetworkSession',
      EventVendor = 'Vectra AI',
      SrcBytes = tolong(orig_ip_bytes_d),
      SrcPackets = tolong(orig_pkts_d),
      SrcPortNumber = toint(id_orig_p_d),
      SrcVlanId = tostring(toint(orig_vlan_id_d)),
      // -- No ID mapped, since huid found not to be unique
      // SrcDvcIdType = 'VectraId',
      // DstDvcIdType = 'VectraId',
      DvcIdType = 'VectraId',
      NetworkDuration = toint(duration_d)
  | extend 
      Hostname = DstHostname,
      IpAddr = SrcIpAddr,
      // SessionId = NetworkSessionId,
      Src = SrcIpAddr,
      Dvc = DvcId,
      Duration = NetworkDuration,
      InnerVlanId = SrcVlanId,
      NetworkBytes = SrcBytes + DstBytes,
      NetworkPackets = SrcPackets + DstPackets,
      OuterVlanId = DstVlanId
  | lookup NetworkDirectionLookup on local_orig_b, local_resp_b
  | lookup EventSubTypeLookup on conn_state_s
  // -- preserving non-normalized important fields
  | extend AdditionalFields = iff (
      pack, 
      bag_pack (
        "first_orig_resp_data_pkt", first_orig_resp_data_pkt_s,
        "first_resp_orig_data_pkt", first_resp_orig_data_pkt_s,
        "orig_sluid", orig_sluid_s, 
        "resp_sluid", resp_sluid_s,
        "orig_huid", orig_huid_s,
        "resp_huid", resp_huid_s,
        "community_id", community_id_s,
        "resp_multihome", resp_multihomed_b,
        "host_multihomed", host_multihomed_b,
        "first_orig_resp_data_pkt_time", unixtime_milliseconds_todatetime(first_orig_resp_data_pkt_time_d),
        "first_orig_resp_pkt_time", unixtime_milliseconds_todatetime(first_orig_resp_pkt_time_d),
        "first_resp_orig_data_pkt_time", unixtime_milliseconds_todatetime(first_resp_orig_data_pkt_time_d),
        "first_resp_orig_pkt_time", unixtime_milliseconds_todatetime(first_resp_orig_pkt_time_d)
      ),
      dynamic([])
    )
  | project-away
      *_d, *_s, *_b, *_g, Computer
};
parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled, pack=pack)
}



//
// Function Name: vimNetworkSessionVMConnection
// Description: This ASIM parser supports filtering and normalizing VM connection logs collected using the Log Analytics agent to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionVMConnection(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let SeverityLookup = datatable (EventOriginalSeverity: string, EventSeverity:string) [
  '', 'Informational', 
  '0', 'Informational',
  '1', 'Low',
  '2', 'Medium',
  '3', 'High'
];
let VMConnectionProjected = VMConnection | project-away AdditionalInformation, AgentId, TenantId, TLPLevel, SourceSystem, IsActive, *ReportedDateTime, LinksFailed, LinksLive, LinksTerminated, Description, Responses, ResponseTimeMin, ResponseTimeMax, RemoteClassification, RemoteDnsQuestions;
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null), 
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]), 
  ipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false)
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
  let outbound = 
      VMConnectionProjected
      | where (isnull(starttime) or TimeGenerated >= starttime)
          and (isnull(endtime) or TimeGenerated <= endtime)
      | where not (disabled)
      | where array_length(hostname_has_any)==0 
      or (Computer has_any (hostname_has_any)) or ( RemoteDnsCanonicalNames has_any (hostname_has_any))
      | where Direction == "outbound"
      // -- Pre-filtering:
      | where
          eventresult in ("*", "Success") 
          and array_length(dvcaction) == 0
          and  (isnull(dstportnumber) or (DestinationPort == dstportnumber))
      | extend EventOriginalSeverity = tostring(Severity)
      | lookup SeverityLookup on EventOriginalSeverity
      | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIp,src_or_any)
         , temp_isDstMatch=has_any_ipv4_prefix(DestinationIp,dst_or_any)
      | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
          )
      | where ASimMatchingIpAddr != "No match"
      // -- End pre-filtering
      | invoke _ASIM_ResolveSrcFQDN ("Computer")
      | extend FQDN = iff(RemoteDnsCanonicalNames == "", "", todynamic(RemoteDnsCanonicalNames)[0])
      | invoke _ASIM_ResolveDstFQDN("FQDN")
      | project-away RemoteDnsCanonicalNames, Computer
      // -- post-filtering
      | extend temp_isMatchSrcHostname= SrcHostname has_any (hostname_has_any)
            ,  temp_isMatchDstHostname = DstHostname has_any (hostname_has_any)
      | extend ASimMatchingHostname = case(
          array_length(hostname_has_any) == 0 , "-"
          , (temp_isMatchSrcHostname and temp_isMatchDstHostname), "Both" 
          , temp_isMatchSrcHostname, "SrcHostname"
          , temp_isMatchDstHostname, "DstHostname"
          , "No match"
          )
      | where ASimMatchingHostname != "No match"
      | project-away temp_*
      | extend
          SrcAppType = "Process",
          SrcDvcIdType = "VMConnectionId",
          SrcHostnameType = "Simple",
          DstGeoCountry = RemoteCountry,
          DstGeoLongitude = RemoteLongitude,
          DstGeoLatitude = RemoteLatitude,
          SrcAppId = Process,
          SrcAppName = ProcessName,
          SrcDvcId = Machine,
          ThreatField = iff (MaliciousIp != "", "DstIpAddr", "")
      | extend
          RemoteFQDN = DstFQDN,
          RemoteHostname = DstHostname,
          RemoteDomain = DstDomain,
          RemoteDomainType = DstDomainType,
          LocalFQDN = SrcFQDN,
          LocalHostname = SrcHostname,
          LocalDomain = SrcDomain,
          LocalDomainType = SrcDomainType,
          LocalIpAddr = SourceIp
  ;
  let inbound =
      VMConnectionProjected
      | where (starttime == datetime(null) or TimeGenerated >= starttime)
          and (endtime == datetime(null) or TimeGenerated <= endtime)
      | where not (disabled)
      | where Direction == "inbound"
      // -- Pre-filtering:
      | where
          eventresult  in ("*", "Success") 
          and array_length(dvcaction) == 0
          and  (dstportnumber==int(null) or DestinationPort == dstportnumber)
          and (array_length(hostname_has_any)==0 
               or Computer has_any (hostname_has_any) or RemoteDnsCanonicalNames has_any (hostname_has_any)
               )
      | extend EventOriginalSeverity = tostring(Severity)
      | lookup SeverityLookup on EventOriginalSeverity
      | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIp,src_or_any)
         , temp_isDstMatch=has_any_ipv4_prefix(DestinationIp,dst_or_any)
      | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
          )
      | where ASimMatchingIpAddr != "No match"
      // -- End pre-filtering
      | invoke _ASIM_ResolveDstFQDN ("Computer")
      | extend FQDN = iff(RemoteDnsCanonicalNames == "", "", todynamic(RemoteDnsCanonicalNames)[0])
      | invoke _ASIM_ResolveSrcFQDN("FQDN")
      | project-away Computer, RemoteDnsCanonicalNames
      // -- post-filtering
      | extend temp_isMatchSrcHostname= SrcHostname has_any (hostname_has_any)
            ,  temp_isMatchDstHostname = DstHostname has_any (hostname_has_any)
      | extend ASimMatchingHostname = case(
          array_length(hostname_has_any) == 0 , "-"
          , (temp_isMatchSrcHostname and temp_isMatchDstHostname), "Both" 
          , temp_isMatchSrcHostname, "SrcHostname"
          , temp_isMatchDstHostname, "DstHostname"
          , "No match"
          )
      | where ASimMatchingHostname != "No match"
      | project-away temp_*
      | extend
          DstAppType = "Process",
          DstDvcIdType = "VMConnectionId",
          SrcGeoCountry = RemoteCountry,
          SrcGeoLongitude = RemoteLongitude,
          SrcGeoLatitude = RemoteLatitude,
          DstAppId = Process,
          DstAppName = ProcessName,
          DstDvcId = Machine,
          ThreatField = iff (MaliciousIp != "", "SrcIpAddr", "")
      | extend
          RemoteFQDN = SrcFQDN,
          RemoteHostname = SrcHostname,
          RemoteDomain = SrcDomain,
          RemoteDomainType = SrcDomainType,
          LocalFQDN = DstFQDN,
          LocalHostname = DstHostname,
          LocalDomain = DstDomain,
          LocalDomainType = DstDomainType,
          LocalIpAddr = DestinationIp
  ;
  union outbound, inbound
  // Event fields
  | extend 
    EventCount = toint(LinksEstablished), // -- prioritized over LinksLive and LinksTerminated
    EventStartTime = TimeGenerated,
    EventVendor = "Microsoft",
    EventProduct = "VMConnection",
    EventSchema = "NetworkSession",
    EventSchemaVersion = "0.2.3",
    EventType = "EndpointNetworkSession",
    DvcIdType = "VMConnectionId",
    NetworkDirection = iff(Direction=="inbound", "Inbound", "Outbound"),
    EventEndTime = TimeGenerated
  | project-rename
    DstIpAddr = DestinationIp,
    DstPortNumber = DestinationPort, 
    SrcIpAddr = SourceIp, 
    NetworkSessionId = ConnectionId,
    ThreatName = IndicatorThreatType,
    RemoteGeoCountry = RemoteCountry,
    RemoteGeoLatitude = RemoteLatitude, 
    RemoteGeoLongitude = RemoteLongitude,
    LocalAppId = Process,
    LocalAppName = ProcessName,
    DvcId = Machine,
    RemoteIpAddr = RemoteIp,
    EventReportUrl = ReportReferenceLink,
    ThreatIpAddr = MaliciousIp
  // -- Calculated fields
  | extend
    EventResult = "Success",
    LocalAppType = "Process",
    NetworkDuration = toint(ResponseTimeSum/LinksEstablished),
    ThreatRiskLevel = toint(Confidence),
    NetworkProtocol = toupper(Protocol),
    SrcBytes = tolong(BytesSent),
    DstBytes = tolong(BytesReceived)
  | project-away BytesSent, BytesReceived, Confidence, ResponseTimeSum, Protocol, Direction, Severity, LinksEstablished
  // -- Aliases
  | extend
    IpAddr = RemoteIpAddr,
    Src = SrcIpAddr,
    Local = LocalIpAddr,
    DvcIpAddr = LocalIpAddr,
    Dst = DstIpAddr,
    Remote = RemoteIpAddr,
    Dvc = LocalHostname,
    DvcHostname = LocalHostname,
    DvcDomain = LocalDomain,
    DvcDomainType = LocalDomainType,
    DvcFQDN = LocalFQDN,
    Hostname = RemoteHostname,
    Duration = NetworkDuration,
    SessionId = NetworkSessionId
};
parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionVMwareCarbonBlackCloud
// Description: This ASIM parser supports normalizing VMware Carbon Black Cloud logs to the ASIM NetworkSession normalized schema. VMware Carbon Black Cloud events are captured through VMware Carbon Black Cloud data connector which ingests Carbon Black Audit, Notification and Event data into Microsoft Sentinel through the REST API.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionVMwareCarbonBlackCloud(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['dvcaction']:dynamic=dynamic([]),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let NetworkProtocolLookup = datatable (netconn_protocol_s: string, NetworkProtocol: string)
  [
  "PROTO_TCP", "TCP",
  "PROTO_UDP", "UDP"
];
let DvcActionLookup = datatable (sensor_action_s: string, DvcAction: string)
    [
    "ACTION_ALLOW", "Allow",
    "ACTION_SUSPEND", "Drop",
    "ACTION_TERMINATE", "Drop",
    "ACTION_BREAK", "Drop",
    "ACTION_BLOCK", "Deny"
];
let EventSeverityLookup = datatable (DvcAction: string, EventSeverity: string)
    [
    "Allow", "Informational",
    "Drop", "Low",
    "Deny", "Low"
];
let ThreatConfidenceLookup = datatable (ThreatOriginalConfidence: string, ThreatConfidence: int)
    [
    "1", 10,
    "2", 20,
    "3", 30,
    "4", 40,
    "5", 50,
    "6", 60,
    "7", 70,
    "8", 80,
    "9", 90,
    "10", 100
];
let parser=(
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]), 
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]), 
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false
    ) {
    let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let CarbonBlackEventsSchema = datatable ( 
    eventType_s: string,
    netconn_protocol_s: string,
    sensor_action_s: string,
    alert_id_g: string,
    device_name_s: string,
    action_s: string,
    createTime_s: string,
    netconn_domain_s: string,
    remote_ip_s: string,
    netconn_inbound_b: bool,
    process_guid_s: string,
    remote_port_d: real,
    local_port_d: real,
    process_pid_d: real,
    device_external_ip_s: string,
    local_ip_s: string,
    device_id_s: string,
    device_os_s: string,
    event_description_s: string,
    event_id_g: string,
    event_origin_s: string,
    process_path_s: string,
    process_username_s: string,
    org_key_s: string
)[];
    let CarbonBlackNotificationsSchema = datatable (
    type_s: string,
    threatInfo_incidentId_g: string,
    threatInfo_score_d: real,
    threatInfo_summary_s: string,
    threatInfo_time_d: real,
    threatInfo_threatCause_threatCategory_s: string,
    threatInfo_threatCause_causeEventId_g: string,
    ruleName_s: string,
    deviceInfo_deviceVersion_s: string,
    threatInfo_threatCause_originSourceType_s: string,
    threatInfo_threatCause_reputation_s: string,
    threatInfo_threatCause_reason_s: string,
    id_g: string,
    primary_event_id_g: string,
    threat_id_g: string
)[];
    let alldata = union (CarbonBlackEventsSchema), (CarbonBlackEvents_CL)
        | where not(disabled)
        | where (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime)
            and array_length(hostname_has_any) == 0
            and eventType_s == "endpoint.event.netconn"
            and (isnull(dstportnumber) or toint(remote_port_d) == dstportnumber)
        | lookup NetworkProtocolLookup on netconn_protocol_s
        | lookup DvcActionLookup on sensor_action_s
        | lookup EventSeverityLookup on DvcAction
        | invoke _ASIM_ResolveDvcFQDN('device_name_s')
        | extend temp_action = tostring(split(action_s, "|")[0])
        | extend 
            EventResult = case(
                  temp_action == "ACTION_CONNECTION_CREATE_FAILED",
                  "Failure",
                  sensor_action_s == "ACTION_ALLOW" or isempty(sensor_action_s),
                  "Success",
                  "Failure"
              ),
            temp_SrcMatch = has_any_ipv4_prefix(local_ip_s, src_or_any),
            temp_DstMatch = has_any_ipv4_prefix(remote_ip_s, dst_or_any)
        | extend 
            ASimMatchingIpAddr=case(
                      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                      "-",
                      temp_SrcMatch and temp_DstMatch,
                      "Both",
                      temp_SrcMatch,
                      "SrcIpAddr",
                      temp_DstMatch,
                      "DstIpAddr",
                      "No match"
                  ),
            ASimMatchingHostname = case(
                          array_length(hostname_has_any) == 0,
                          "-",
                          DvcHostname has_any (hostname_has_any),
                          "SrcHostname",
                          "No match"
                      )
        | where (eventresult == "*" or eventresult =~ EventResult)
            and (array_length(dvcaction) == 0 or DvcAction has_any (dvcaction))
            and ASimMatchingIpAddr != "No match"
            and ASimMatchingHostname != "No match";
    let alldatawiththreat = alldata 
        | where isnotempty(alert_id_g)
        | join kind=leftouter(union (CarbonBlackNotifications_CL), (CarbonBlackNotificationsSchema)
            | where type_s == "THREAT"
            | project
                threatInfo_incidentId_g,
                threatInfo_score_d,
                threatInfo_summary_s,
                threatInfo_time_d,
                threatInfo_threatCause_threatCategory_s,
                threatInfo_threatCause_causeEventId_g,
                ruleName_s,
                deviceInfo_deviceVersion_s,
                threatInfo_threatCause_originSourceType_s,
                threatInfo_threatCause_reputation_s,
                threatInfo_threatCause_reason_s)
            on $left.alert_id_g == $right.threatInfo_incidentId_g
        | join kind=leftouter(union (CarbonBlackNotifications_CL), (CarbonBlackNotificationsSchema)
            | where type_s == "CB_ANALYTICS"
            | project
                id_g,
                deviceInfo_deviceVersion_s,
                threat_id_g,
                threatInfo_score_d,
                threatInfo_summary_s,
                threatInfo_threatCause_reason_s)
            on $left.alert_id_g == $right.id_g
        | extend 
            ThreatCategory = threatInfo_threatCause_threatCategory_s,
            ThreatFirstReportedTime = unixtime_milliseconds_todatetime(threatInfo_time_d),
            RuleName = ruleName_s,
            AdditionalFields_threat = bag_pack(
                              "threatInfo_threatCause_reason",
                              coalesce(threatInfo_threatCause_reason_s, threatInfo_threatCause_reason_s1),
                              "threatInfo_threatCause_reputation",
                              threatInfo_threatCause_reputation_s,
                              "threatInfo_threatCause_originSourceType",
                              threatInfo_threatCause_originSourceType_s,
                              "threatInfo_summary",
                              coalesce(threatInfo_summary_s, threatInfo_summary_s1)
                          ),
            ThreatId = threat_id_g,
            ThreatOriginalConfidence = tostring(toint(coalesce(threatInfo_score_d, threatInfo_score_d1))),
            DvcOsVersion = coalesce(deviceInfo_deviceVersion_s, deviceInfo_deviceVersion_s1)
        | lookup ThreatConfidenceLookup on ThreatOriginalConfidence;
    let alldatawithoutthreat = alldata
        | where isempty(alert_id_g);
    union alldatawiththreat, alldatawithoutthreat
    | extend
        EventStartTime = todatetime(split(createTime_s, '+')[0]),
        SrcDomain = case(
                netconn_domain_s == remote_ip_s or netconn_domain_s has ":" or netconn_domain_s !has ".",
                "",
                netconn_inbound_b,
                netconn_domain_s,
                ""
            ),
        AdditionalFields_Common = bag_pack(
                              "Process Guid",
                              process_guid_s
                          ),
        DstPortNumber = toint(remote_port_d),
        NetworkDirection = case(
                      temp_action == "ACTION_CONNECTION_LISTEN",
                      "Listen",
                      netconn_inbound_b == true,
                      "Inbound",
                      "Unknown"
                  ),
        SrcPortNumber = toint(local_port_d),
        SrcProcessId = tostring(toint(process_pid_d))
    | project-rename
        DstIpAddr = remote_ip_s,
        DvcIpAddr = device_external_ip_s,
        EventUid = _ItemId,
        SrcIpAddr = local_ip_s,
        DvcId = device_id_s,
        DvcOriginalAction = sensor_action_s,
        DvcOs = device_os_s,
        EventMessage = event_description_s,
        EventOriginalType = action_s,
        EventOriginalUid = event_id_g,
        EventOwner = event_origin_s,
        SrcUsername = process_username_s,
        SrcProcessName = process_path_s,
        DvcScopeId = org_key_s
    | extend
        EventCount = int(1),
        EventProduct = "Carbon Black Cloud",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "EndpointNetworkSession",
        EventVendor = "VMware",
        SrcHostname = SrcIpAddr,
        DstHostname = iff(NetworkDirection == "Inbound", coalesce(DvcHostname, DstIpAddr), DstIpAddr),
        NetworkProtocolVersion = case(
                            DstIpAddr contains ".",
                            "IPv4",       
                            DstIpAddr contains ":",
                            "IPv6", 
                            ""
                        )
    | extend
        Dvc = coalesce(DvcFQDN, DvcId, DvcHostname, DvcIpAddr),
        EventEndTime = EventStartTime,
        Dst = coalesce(DstHostname, DstIpAddr),
        Src = coalesce(SrcHostname, SrcIpAddr),
        IpAddr = SrcIpAddr,
        SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
        SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
        SrcDomainType = iff(isnotempty(SrcDomain), "FQDN", ""),
        DvcIdType = iff(isnotempty(DvcId), "Other", ""),
        AdditionalFields = bag_merge(AdditionalFields_threat, AdditionalFields_Common),
        SrcAppName = SrcProcessName,
        SrcAppId = SrcProcessId,
        SrcAppType = "Process",
        Hostname = DstHostname
    | project-away
        *_d,
        *_s,
        *_g,
        *_b,
        temp*,
        _ResourceId,
        Computer,
        MG,
        ManagementGroupName,
        RawData,
        SourceSystem,
        TenantId,
        AdditionalFields_*
};
parser(
    starttime=starttime, 
    endtime=endtime,
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber, 
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction, 
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionWatchGuardFirewareOS
// Description: This ASIM parser supports filtering and normalizing WatchGuard Fireware OS logs produced by the Microsoft Sentinel Syslog connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionWatchGuardFirewareOS(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let Parser=(starttime:datetime=datetime(null), endtime:datetime=datetime(null), srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]), dstportnumber:int=int(null), hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]), eventresult:string='*', disabled:bool=false){
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let EventLookup=datatable(DvcAction:string,EventResult:string,EventSeverity:string)
  [
      "Allow","Success","Informational"
      , "Deny","Failure","Low"
  ];
  let SyslogParser = (Syslog:(SyslogMessage:string)) {
    Syslog
    | parse-kv SyslogMessage as (geo_src:string
    , geo_dst:string
    , src_user:string
    , dst_user:string
    , duration:int
    , sent_bytes:long
    , rcvd_bytes:long
    , fqdn_src_match:string
    , fqdn_dst_match:string) with (pair_delimiter=' ', kv_delimiter='=', quote='"')
    | project-rename SrcGeoCountry = geo_src
    , DstGeoCountry = geo_dst
    , SrcUsername = src_user
    , DstUsername = dst_user
    , NetworkDuration = duration
    , SrcBytes = sent_bytes
    , DstBytes = rcvd_bytes
    , DstDomain = fqdn_dst_match
    , SrcDomain = fqdn_src_match
    | extend DstDomainType = iif(isnotempty(DstDomain),"FQDN","")
    | extend SrcDomainType = iif(isnotempty(SrcDomain),"FQDN","")
    | extend NetworkProtocol = extract(@" (tcp|udp|icmp|igmp) ", 1, SyslogMessage)
    | extend SrcUsernameType = case(isempty(SrcUsername), ""
      , SrcUsername contains "@" , "UPN"
      , "Simple"
    )
    | extend DstUsernameType = case(isempty(DstUsername), ""
      , DstUsername contains "@" , "UPN"
      , "Simple"
    )
    | parse SyslogMessage with * "repeated " EventCount:int " times" *
    | extend EventCount = iif(isnotempty(EventCount), EventCount, toint(1))
    | project-away SyslogMessage
  };
  let IPParser = (T:(SrcIpAddr:string,DstIpAddr:string)){
    T
    | extend temp_SrcMatch = has_any_ipv4_prefix(SrcIpAddr,src_or_any)
    , temp_DstMatch = has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend ASimMatchingIpAddr = case(
      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-",
      temp_SrcMatch and temp_DstMatch, "Both",
      temp_SrcMatch, "SrcIpAddr",
      temp_DstMatch, "DstIpAddr",
      "No match"
    )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  };
  let HostParser = (Syslog:(SrcDomain:string,DstDomain:string)){
  Syslog
  | extend temp_SrcMatch = SrcDomain has_any(hostname_has_any)
    , temp_DstMatch= DstDomain has_any(hostname_has_any)
  | extend ASimMatchingHostname =case(
      array_length(hostname_has_any) == 0, "-",
      temp_SrcMatch and temp_DstMatch, "Both",
      temp_SrcMatch, "SrcDomain",
      temp_DstMatch, "DstDomain",
      "No match"
    )
  | where ASimMatchingHostname != "No match" 
  | project-away temp_*
  };
  let AllSyslog = 
  Syslog
  | where not(disabled)
  | where (isnull(starttime) or TimeGenerated>=starttime) and (isnull(endtime) or TimeGenerated<=endtime)
  | where SyslogMessage has_any('msg_id="3000-0148"' 
      , 'msg_id="3000-0149"' 
      , 'msg_id="3000-0150"'
      , 'msg_id="3000-0151"'
      , 'msg_id="3000-0173"'
  ) and SyslogMessage !has 'msg="DNS Forwarding" '
    and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any))
    and (array_length(hostname_has_any)==0 or SyslogMessage has_any(hostname_has_any))
  | where (array_length(dvcaction)==0 or SyslogMessage has_any (dvcaction))
  | extend DvcAction = extract(@'" (Allow|Deny) ', 1, SyslogMessage)
  | lookup EventLookup on DvcAction
  | where (eventresult=='*' or EventResult == eventresult)
  | project TimeGenerated, SyslogMessage, HostName, DvcAction, EventResult, EventSeverity
  ;
  let Parse1 = 
  AllSyslog
  | where SyslogMessage !has "icmp" and SyslogMessage !has "igmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} (tcp|udp) \d{2,5} \d{2,5} " SrcIpAddr " " DstIpAddr " " SrcPortNumber:int @" " DstPortNumber:int @" " *
  | where  (isnull(dstportnumber) or DstPortNumber==dstportnumber)
  | invoke SyslogParser()
  | invoke IPParser()
  | invoke HostParser()
  ;
  let Parse2 = 
  AllSyslog
  | where SyslogMessage !has "icmp" and SyslogMessage !has "igmp" and SyslogMessage has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" (tcp|udp) " SrcIpAddr " " DstIpAddr " " SrcPortNumber:int @" " DstPortNumber:int @" " *
  | where  (isnull(dstportnumber) or DstPortNumber==dstportnumber)
  | invoke SyslogParser()
  | invoke IPParser()
  | invoke HostParser()
  ;
  let Parse3 = 
  AllSyslog
  | where SyslogMessage has "icmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} icmp \d{2,5} \d{1,5} " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  | invoke IPParser()
  | invoke HostParser()
  ;
  let Parse4 = 
  AllSyslog
  | where SyslogMessage has "icmp" and SyslogMessage has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" icmp " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  | invoke IPParser()
  | invoke HostParser()
  ;
  let Parse5 = 
  AllSyslog
  | where SyslogMessage has "igmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} igmp \d{2,5} \d{1,5} " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  | invoke IPParser()
  | invoke HostParser()
  ;
  union isfuzzy=false Parse1, Parse2, Parse3, Parse4, Parse5
  | extend EventSchema = "NetworkSession"
      , EventSchemaVersion = "0.2.4"
      , EventVendor = "WatchGuard"
      , EventProduct = "Fireware"
      , EventType = "NetworkSession"
      , DvcHostname = HostName
      , NetworkProtocolVersion = case(DstIpAddr contains ".", "IPv4"
          , DstIpAddr contains ":", "IPv6"
          , "")
      , NetworkProtocol = toupper(NetworkProtocol)
      , NetworkDuration = toint(NetworkDuration * toint(1000))
      , NetworkBytes = SrcBytes + DstBytes
      , EventEndTime = TimeGenerated
      , EventStartTime = TimeGenerated
      , Src = SrcIpAddr
      , Dst = DstIpAddr
      , Duration = NetworkDuration
      , User = DstUsername
      , IpAddr = SrcIpAddr
  | project-rename Dvc = HostName
};
Parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionZscalerZIA
// Description: This ASIM parser supports filtering and normalizing Zscaler ZIA firewall logs produced by the Microsoft Sentinel Zscaler connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionZscalerZIA(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ActionLookup = datatable (DvcOriginalAction: string, DvcAction:string) [
  // See https://help.zscaler.com/zia/firewall-insights-logs-filters
  'Allow','Allow',
  'Allow due to insufficient app data','Allow',
  'Block/Drop','Drop',
  'Block/ICMP','Drop ICMP',
  'Block/Reset', 'Reset',
  'IPS Drop', 'Drop',
  'IPS Reset', 'Reset',
  // Observed in real world events
  'Block ICMP', 'Drop ICMP',
  'Drop', 'Drop'
];
let parser=  
  (starttime:datetime=datetime(null)
  , endtime:datetime=datetime(null)
  , srcipaddr_has_any_prefix:dynamic=dynamic([])
  , dstipaddr_has_any_prefix:dynamic=dynamic([])
  , ipaddr_has_any_prefix:dynamic=dynamic([])
  , dstportnumber:int=int(null)
  , hostname_has_any:dynamic=dynamic([])
  , dvcaction:dynamic=dynamic([])
  , eventresult:string='*'
  , disabled:bool=false) {
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
CommonSecurityLog 
| where (isnull(starttime) or TimeGenerated >= starttime)
   and  (isnull(endtime) or TimeGenerated <= endtime)
| where not(disabled)
| where DeviceVendor == "Zscaler"
| where DeviceProduct == "NSSFWlog"
|where
  (array_length(hostname_has_any) == 0) // No host name information, so always filter out if hostname filter used. 
  and   (isnull(dstportnumber) or dstportnumber == DestinationPort) 
| extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
| extend ASimMatchingIpAddr=case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
                                temp_SrcMatch and temp_DstMatch, "Both",
                                temp_SrcMatch, "SrcIpAddr",
                                temp_DstMatch, "DstIpAddr",
                                "No match"
                            )
// -- Pre-filtering
| where ASimMatchingIpAddr != "No match"
| project-away temp_*
| project-rename DvcOriginalAction = DeviceAction
| lookup ActionLookup on DvcOriginalAction 
| where array_length(dvcaction) == 0 or DvcAction in (dvcaction)
| extend EventResult = iff (DvcOriginalAction == "Allow", "Success", "Failure") 
| where (eventresult=='*' or EventResult == eventresult)
// -- Event fields
| extend 
  EventStartTime=TimeGenerated, 
  EventVendor = "Zscaler", 
  EventProduct = "ZIA Firewall", 
  EventSchema = "NetworkSession", 
  EventSchemaVersion="0.2.3", 
  EventType = 'NetworkSession', 
  EventSeverity = 'Informational',
  EventEndTime=TimeGenerated 
| project-rename
  DvcHostname = Computer, 
  EventProductVersion = DeviceVersion, 
  NetworkProtocol = Protocol, 
  DstIpAddr = DestinationIP, 
  DstPortNumber = DestinationPort, 
  DstNatIpAddr = DestinationTranslatedAddress, 
  DstNatPortNumber = DestinationTranslatedPort, 
  DstAppName = DeviceCustomString3, 
  NetworkApplicationProtocol = DeviceCustomString2, 
  SrcIpAddr = SourceIP, 
  SrcPortNumber = SourcePort, 
  SrcUsername = SourceUserName,
  SrcNatIpAddr= SourceTranslatedAddress, 
  SrcNatPortNumber = SourceTranslatedPort, 
  SrcUserDepartment = DeviceCustomString1,  // Not in standard schema
  SrcUserLocation = SourceUserPrivileges,  // Not in standard schema
  ThreatName = DeviceCustomString6, 
  ThreatCategory = DeviceCustomString5, 
  NetworkRuleName = Activity,
  EventOriginalSeverity = LogSeverity,
  EventMessage = Message 
// -- Calculated fields
| extend
  // -- Adjustment to support both old and new CSL fields.
  EventCount=coalesce(
    toint(column_ifexists("FieldDeviceCustomNumber2", int(null))), 
    toint(column_ifexists("DeviceCustomNumber2",int(null)))
  ),
  NetworkDuration = coalesce(
    toint(column_ifexists("FieldDeviceCustomNumber1", int(null))),
    toint(column_ifexists("DeviceCustomNumber1",int(null)))
  ),
  ThreatCategory = iff(DeviceCustomString4 == "None", "", ThreatCategory),
  SrcUsername = iff (SrcUsername == SrcUserLocation, "", SrcUsername),
  DstBytes = tolong(ReceivedBytes), 
  SrcBytes = tolong(SentBytes)
// -- Enrichment
| extend
  DstAppType = "Service", 
  SrcUsernameType = "UPN" 
// -- Aliases
| extend
  Dvc = DvcHostname,
  User = SrcUsername,
  IpAddr = SrcIpAddr,
  Src = SrcIpAddr,
  Dst = DstIpAddr,
  Rule = NetworkRuleName,
  Duration = NetworkDuration
| project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, ReceiptTime, ReceivedBytes, Remote*, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, EventOutcome, FieldDevice*, ExtID, Reason, ApplicationProtocol, ReportReferenceLink
};
parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



