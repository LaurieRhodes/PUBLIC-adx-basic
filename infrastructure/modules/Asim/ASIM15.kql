//
// Function Name: ASimNetworkSessionVectraAI
// Description: This ASIM parser supports normalizing Vectra AI Streams logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionVectraAI(    ['disabled']:bool=false,
    ['pack']:bool=false)
{
let parser = (disabled:bool=false, pack:bool=false) 
{
  let NetworkDirectionLookup = datatable(local_orig_b:bool, local_resp_b:bool, NetworkDirection:string)[
    false, true, 'Inbound',
    true, false, 'Outbound',
    true, true, 'Local',
    false, false, 'External'];
  let EventSubTypeLookup = datatable(conn_state_s:string, EventSubType:string)[
    "S1", 'Start',
    "SF", 'End'];
  let HostnameRegex = @'^[a-zA-Z0-9-]{1,61}$';
  VectraStream_CL
  | where metadata_type_s == 'metadata_isession'
  | project-away MG, ManagementGroupName, RawData, SourceSystem, TenantId
  | project-rename
      DstIpAddr = id_resp_h_s,
      DvcDescription = hostname_s,
      DstDescription = resp_hostname_s,
      SrcDescription = orig_hostname_s,
      // -- huid does not seem to be unique per device and not mapped for now
      // DstDvcId = resp_huid_s, 
      // SrcDvcId = orig_huid_s,
      DvcId = sensor_uid_s,
      // -- community id is just a hash of addresses and ports, and not unique for the session
      // NetworkSessionId = community_id_s,
      SrcIpAddr = id_orig_h_s,
      EventUid = _ItemId
  // -- the domain field may have invalid values. Most of them are IP addresses filtered out, but a small fraction are not filtered.
  | extend resp_domain_s = iff (ipv4_is_match(resp_domain_s, "0.0.0.0",0), "", resp_domain_s)
  | extend SplitRespDomain = split(resp_domain_s,".")
  | extend 
      DstDomain = tostring(strcat_array(array_slice(SplitRespDomain, 1, -1), '.')),
      DstFQDN = iif (array_length(SplitRespDomain) > 1, resp_domain_s, ''),
      DstDomainType = iif (array_length(SplitRespDomain) > 1, 'FQDN', '')
  | extend
      DstHostname = case (
          resp_domain_s != "", tostring(SplitRespDomain[0]),
          DstDescription startswith "IP-" or not(DstDescription matches regex HostnameRegex), "",
          DstDescription)
  | project-away SplitRespDomain
  | extend
      SrcHostname = iff (SrcDescription startswith "IP-" or not(SrcDescription matches regex HostnameRegex), "", SrcDescription),
      DvcHostname = iff (DvcDescription startswith "IP-" or not(DvcDescription matches regex HostnameRegex), "", DvcDescription),
      NetworkApplicationProtocol = toupper(service_s),
      NetworkProtocol = toupper(protoName_s),
      NetworkProtocolVersion = toupper(id_ip_ver_s),
      Dst = DstIpAddr,
      DstBytes = tolong(resp_ip_bytes_d),
      DstPackets = tolong(resp_pkts_d),
      DstPortNumber = toint(id_resp_p_d),
      DstVlanId = tostring(toint(resp_vlan_id_d)),
      EventCount = toint(1),
      EventEndTime = unixtime_milliseconds_todatetime(ts_d),
      EventOriginalSubType = tostring(split(metadata_type_s, '_')[1]),
      EventProduct = 'Vectra Stream',
      EventResult = 'Success',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.2',
      EventSeverity = 'Informational',
      EventStartTime = unixtime_milliseconds_todatetime(session_start_time_d),
      EventType = 'NetworkSession',
      EventVendor = 'Vectra AI',
      SrcBytes = tolong(orig_ip_bytes_d),
      SrcPackets = tolong(orig_pkts_d),
      SrcPortNumber = toint(id_orig_p_d),
      SrcVlanId = tostring(toint(orig_vlan_id_d)),
      // -- No ID mapped, since huid found not to be unique
      // SrcDvcIdType = 'VectraId',
      // DstDvcIdType = 'VectraId',
      DvcIdType = 'VectraId',
      NetworkDuration = toint(duration_d)
  | extend 
      Hostname = DstHostname,
      IpAddr = SrcIpAddr,
      // SessionId = NetworkSessionId,
      Src = SrcIpAddr,
      Dvc = DvcId,
      Duration = NetworkDuration,
      InnerVlanId = SrcVlanId,
      NetworkBytes = SrcBytes + DstBytes,
      NetworkPackets = SrcPackets + DstPackets,
      OuterVlanId = DstVlanId
  | lookup NetworkDirectionLookup on local_orig_b, local_resp_b
  | lookup EventSubTypeLookup on conn_state_s
  // -- preserving non-normalized important fields
  | extend AdditionalFields = iff (
      pack, 
      bag_pack (
        "first_orig_resp_data_pkt", first_orig_resp_data_pkt_s,
        "first_resp_orig_data_pkt", first_resp_orig_data_pkt_s,
        "orig_sluid", orig_sluid_s, 
        "resp_sluid", resp_sluid_s,
        "orig_huid", orig_huid_s,
        "resp_huid", resp_huid_s,
        "community_id", community_id_s,
        "resp_multihome", resp_multihomed_b,
        "host_multihomed", host_multihomed_b,
        "first_orig_resp_data_pkt_time", unixtime_milliseconds_todatetime(first_orig_resp_data_pkt_time_d),
        "first_orig_resp_pkt_time", unixtime_milliseconds_todatetime(first_orig_resp_pkt_time_d),
        "first_resp_orig_data_pkt_time", unixtime_milliseconds_todatetime(first_resp_orig_data_pkt_time_d),
        "first_resp_orig_pkt_time", unixtime_milliseconds_todatetime(first_resp_orig_pkt_time_d)
      ),
      dynamic([])
    )
  | project-away
      *_d, *_s, *_b, *_g, Computer
};
parser (disabled=disabled, pack=pack)
}



//
// Function Name: ASimNetworkSessionVMConnection
// Description: This ASIM parser supports normalizing VM connection logs collected using the Log Analytics agent to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionVMConnection(    ['disabled']:bool=false)
{
let SeverityLookup = datatable (EventOriginalSeverity: string, EventSeverity:string) [
  '', 'Informational', 
  '0', 'Informational',
  '1', 'Low',
  '2', 'Medium',
  '3', 'High'
];
let VMConnectionProjected = VMConnection | project-away AdditionalInformation, AgentId, TenantId, TLPLevel, SourceSystem, IsActive, *ReportedDateTime, LinksFailed, LinksLive, LinksTerminated, Description, Responses, ResponseTimeMin, ResponseTimeMax, RemoteClassification, RemoteDnsQuestions;
let outbound = (disabled:bool=false) {
  VMConnectionProjected
  | where not (disabled)
  | where Direction == "outbound"
  | extend
      SrcAppType = "Process",
      SrcDvcIdType = "VMConnectionId",
      SrcHostnameType = "Simple",
      DstGeoCountry = RemoteCountry,
      DstGeoLongitude = RemoteLongitude,
      DstGeoLatitude = RemoteLatitude,
      SrcAppId = Process,
      SrcAppName = ProcessName,
      SrcDvcId = Machine,
      ThreatField = iff (MaliciousIp != "", "DstIpAddr", "")
  | invoke _ASIM_ResolveSrcFQDN ("Computer")
  | extend FQDN = iff(RemoteDnsCanonicalNames == "", "", todynamic(RemoteDnsCanonicalNames)[0])
  | invoke _ASIM_ResolveDstFQDN("FQDN")
  | project-away Computer, RemoteDnsCanonicalNames
  | extend
      RemoteFQDN = DstFQDN,
      RemoteHostname = DstHostname,
      RemoteDomain = DstDomain,
      RemoteDomainType = DstDomainType,
      LocalFQDN = SrcFQDN,
      LocalHostname = SrcHostname,
      LocalDomain = SrcDomain,
      LocalDomainType = SrcDomainType,
      LocalIpAddr = SourceIp
};
let inbound = (disabled:bool=false) {
  VMConnectionProjected
  | where not (disabled)
  | where Direction == "inbound"
  | extend
      DstAppType = "Process",
      DstDvcIdType = "VMConnectionId",
      SrcGeoCountry = RemoteCountry,
      SrcGeoLongitude = RemoteLongitude,
      SrcGeoLatitude = RemoteLatitude,
      DstAppId = Process,
      DstAppName = ProcessName,
      DstDvcId = Machine,
      ThreatField = iff (MaliciousIp != "", "SrcIpAddr", "")
  | invoke _ASIM_ResolveDstFQDN ("Computer")
  | extend FQDN = iff(RemoteDnsCanonicalNames == "", "", todynamic(RemoteDnsCanonicalNames)[0])
  | invoke _ASIM_ResolveSrcFQDN("FQDN")
  | project-away Computer, RemoteDnsCanonicalNames
  | extend
      RemoteFQDN = SrcFQDN,
      RemoteHostname = SrcHostname,
      RemoteDomain = SrcDomain,
      RemoteDomainType = SrcDomainType,
      LocalFQDN = DstFQDN,
      LocalHostname = DstHostname,
      LocalDomain = DstDomain,
      LocalDomainType = DstDomainType,
      LocalIpAddr = DestinationIp
};
let parser=(disabled:bool=false){
  union outbound(disabled), inbound(disabled)
  // Event fields
  | extend 
    EventCount = toint(LinksEstablished), // -- prioritized over LinksLive and LinksTerminated
    EventStartTime = TimeGenerated,
    EventVendor = "Microsoft",
    EventProduct = "VMConnection",
    EventSchema = "NetworkSession",
    EventSchemaVersion = "0.2.2",
    EventType = "EndpointNetworkSession",
    DvcIdType = "VMConnectionId",
    NetworkDirection = iff(Direction=="inbound", "Inbound", "Outbound"),
    EventEndTime = TimeGenerated
  | project-rename
    DstIpAddr = DestinationIp,
    DstPortNumber = DestinationPort, 
    SrcIpAddr = SourceIp, 
    NetworkSessionId = ConnectionId,
    ThreatName = IndicatorThreatType,
    RemoteGeoCountry = RemoteCountry,
    RemoteGeoLatitude = RemoteLatitude, 
    RemoteGeoLongitude = RemoteLongitude,
    LocalAppId = Process,
    LocalAppName = ProcessName,
    DvcId = Machine,
    RemoteIpAddr = RemoteIp,
    EventReportUrl = ReportReferenceLink,
    ThreatIpAddr = MaliciousIp
  // -- Calculated fields
  | extend EventOriginalSeverity = tostring(Severity)
  | lookup SeverityLookup on EventOriginalSeverity
  | extend
    EventResult = "Success",
    LocalAppType = "Process",
    NetworkDuration = toint(ResponseTimeSum/LinksEstablished) ,
    ThreatRiskLevel = toint(Confidence),
    NetworkProtocol = toupper(Protocol),
    SrcBytes = tolong(BytesSent),
    DstBytes = tolong(BytesReceived)
  | project-away BytesSent, BytesReceived, Confidence, ResponseTimeSum, Protocol, Direction, Severity, LinksEstablished
  // -- Aliases
  | extend
    IpAddr = RemoteIpAddr,
    Src = SrcIpAddr,
    Local = LocalIpAddr,
    DvcIpAddr = LocalIpAddr,
    Dst = DstIpAddr,
    Remote = RemoteIpAddr,
    Dvc = LocalHostname,
    DvcHostname = LocalHostname,
    DvcDomain = LocalDomain,
    DvcDomainType = LocalDomainType,
    DvcFQDN = LocalFQDN,
    Hostname = RemoteHostname,
    Duration = NetworkDuration,
    SessionId = NetworkSessionId
};
parser (disabled)
}



//
// Function Name: ASimNetworkSessionVMwareCarbonBlackCloud
// Description: This ASIM parser supports normalizing VMware Carbon Black Cloud logs to the ASIM NetworkSession normalized schema. VMware Carbon Black Cloud events are captured through VMware Carbon Black Cloud data connector which ingests Carbon Black Audit, Notification and Event data into Microsoft Sentinel through the REST API.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionVMwareCarbonBlackCloud(    ['disabled']:bool=false)
{
let NetworkProtocolLookup = datatable (netconn_protocol_s: string, NetworkProtocol: string)
  [
  "PROTO_TCP", "TCP",
  "PROTO_UDP", "UDP"
  ];
  let DvcActionLookup = datatable (sensor_action_s: string, DvcAction: string)
      [
      "ACTION_ALLOW", "Allow",
      "ACTION_SUSPEND", "Drop",
      "ACTION_TERMINATE", "Drop",
      "ACTION_BREAK", "Drop",
      "ACTION_BLOCK", "Deny"
  ];
  let EventSeverityLookup = datatable (DvcAction: string, EventSeverity: string)
      [
      "Allow", "Informational",
      "Drop", "Low",
      "Deny", "Low"
  ];
  let ThreatConfidenceLookup = datatable (ThreatOriginalConfidence: string, ThreatConfidence: int)
      [
      "1", 10,
      "2", 20,
      "3", 30,
      "4", 40,
      "5", 50,
      "6", 60,
      "7", 70,
      "8", 80,
      "9", 90,
      "10", 100
  ];
  let parser=(disabled: bool=false) {
      let CarbonBlackEventsSchema = datatable ( 
      eventType_s: string,
      netconn_protocol_s: string,
      sensor_action_s: string,
      alert_id_g: string,
      device_name_s: string,
      action_s: string,
      createTime_s: string,
      netconn_domain_s: string,
      remote_ip_s: string,
      netconn_inbound_b: bool,
      process_guid_s: string,
      remote_port_d: real,
      local_port_d: real,
      process_pid_d: real,
      device_external_ip_s: string,
      local_ip_s: string,
      device_id_s: string,
      device_os_s: string,
      event_description_s: string,
      event_id_g: string,
      event_origin_s: string,
      process_path_s: string,
      process_username_s: string,
      org_key_s: string,
  )[];
      let CarbonBlackNotificationsSchema = datatable (
      type_s: string,
      threatInfo_incidentId_g: string,
      threatInfo_score_d: real,
      threatInfo_summary_s: string,
      threatInfo_time_d: real,
      threatInfo_threatCause_threatCategory_s: string,
      threatInfo_threatCause_causeEventId_g: string,
      ruleName_s: string,
      deviceInfo_deviceVersion_s: string,
      threatInfo_threatCause_originSourceType_s: string,
      threatInfo_threatCause_reputation_s: string,
      threatInfo_threatCause_reason_s: string,
      id_g: string,
      primary_event_id_g: string,
      threat_id_g: string
  )[];
      let alldata = union (CarbonBlackEventsSchema), (CarbonBlackEvents_CL)
          | where not(disabled)
          | where eventType_s == "endpoint.event.netconn"
          | lookup NetworkProtocolLookup on netconn_protocol_s
          | lookup DvcActionLookup on sensor_action_s
          | lookup EventSeverityLookup on DvcAction;
      let alldatawiththreat = alldata 
          | where isnotempty(alert_id_g)
          | join kind=leftouter(union (CarbonBlackNotifications_CL), (CarbonBlackNotificationsSchema)
              | where type_s == "THREAT"
              | project
                  threatInfo_incidentId_g,
                  threatInfo_score_d,
                  threatInfo_summary_s,
                  threatInfo_time_d,
                  threatInfo_threatCause_threatCategory_s,
                  threatInfo_threatCause_causeEventId_g,
                  ruleName_s,
                  deviceInfo_deviceVersion_s,
                  threatInfo_threatCause_originSourceType_s,
                  threatInfo_threatCause_reputation_s,
                  threatInfo_threatCause_reason_s)
              on $left.alert_id_g == $right.threatInfo_incidentId_g
          | join kind=leftouter(union (CarbonBlackNotifications_CL), (CarbonBlackNotificationsSchema)
              | where type_s == "CB_ANALYTICS"
              | project
                  id_g,
                  deviceInfo_deviceVersion_s,
                  threat_id_g,
                  threatInfo_score_d,
                  threatInfo_summary_s,
                  threatInfo_threatCause_reason_s)
              on $left.alert_id_g == $right.id_g
          | extend 
              ThreatCategory = threatInfo_threatCause_threatCategory_s,
              ThreatFirstReportedTime = unixtime_milliseconds_todatetime(threatInfo_time_d),
              RuleName = ruleName_s,
              AdditionalFields_threat = bag_pack(
                              "threatInfo_threatCause_reason",
                              coalesce(threatInfo_threatCause_reason_s, threatInfo_threatCause_reason_s1),
                              "threatInfo_threatCause_reputation",
                              threatInfo_threatCause_reputation_s,
                              "threatInfo_threatCause_originSourceType",
                              threatInfo_threatCause_originSourceType_s,
                              "threatInfo_summary",
                              coalesce(threatInfo_summary_s, threatInfo_summary_s1)
                          ),
              ThreatId = threat_id_g,
              ThreatOriginalConfidence = tostring(toint(coalesce(threatInfo_score_d, threatInfo_score_d1))),
              DvcOsVersion = coalesce(deviceInfo_deviceVersion_s, deviceInfo_deviceVersion_s1)
          | lookup ThreatConfidenceLookup on ThreatOriginalConfidence;
      let alldatawithoutthreat = alldata
          | where isempty(alert_id_g);
      union alldatawiththreat, alldatawithoutthreat
      | invoke _ASIM_ResolveDvcFQDN('device_name_s')
      | extend temp_action = tostring(split(action_s, "|")[0])
      | extend
          EventStartTime = todatetime(split(createTime_s, '+')[0]),
          SrcDomain = case(
                  netconn_domain_s == remote_ip_s or netconn_domain_s has ":" or netconn_domain_s !has ".",
                  "",
                  netconn_inbound_b,
                  netconn_domain_s,
                  ""
              ),
          AdditionalFields_Common = bag_pack(
                              "Process Guid",
                              process_guid_s
                          ),
          DstPortNumber = toint(remote_port_d),
          NetworkDirection = case(
                      temp_action == "ACTION_CONNECTION_LISTEN",
                      "Listen",
                      netconn_inbound_b == true,
                      "Inbound",
                      "Unknown"
                  ),
          SrcPortNumber = toint(local_port_d),
          SrcProcessId = tostring(toint(process_pid_d))
      | project-rename
          DstIpAddr = remote_ip_s,
          DvcIpAddr = device_external_ip_s,
          EventUid = _ItemId,
          SrcIpAddr = local_ip_s,
          DvcId = device_id_s,
          DvcOriginalAction = sensor_action_s,
          DvcOs = device_os_s,
          EventMessage = event_description_s,
          EventOriginalType = action_s,
          EventOriginalUid = event_id_g,
          EventOwner = event_origin_s,
          SrcProcessName = process_path_s,
          SrcUsername = process_username_s,
          DvcScopeId = org_key_s
      | extend
          EventCount = int(1),
          EventProduct = "Carbon Black Cloud",
          EventSchema = "NetworkSession",
          EventSchemaVersion = "0.2.6",
          EventType = "EndpointNetworkSession",
          EventVendor = "VMware",
          SrcHostname = SrcIpAddr,
          DstHostname = iff(NetworkDirection == "Inbound", coalesce(DvcHostname, DstIpAddr), DstIpAddr),
          EventResult = case(
                  temp_action == "ACTION_CONNECTION_CREATE_FAILED",
                  "Failure",
                  DvcOriginalAction == "ACTION_ALLOW" or isempty(DvcOriginalAction),
                  "Success",
                  "Failure"
              ),
          NetworkProtocolVersion = case(
                              DstIpAddr contains ".",
                              "IPv4",       
                              DstIpAddr contains ":",
                              "IPv6", 
                              ""
                          )
      | extend
          Dvc = coalesce(DvcFQDN, DvcId, DvcHostname, DvcIpAddr),
          EventEndTime = EventStartTime,
          Dst = coalesce(DstHostname, DstIpAddr),
          Src = coalesce(SrcHostname, SrcIpAddr),
          IpAddr = SrcIpAddr,
          SrcUsernameType = _ASIM_GetUsernameType(SrcUsername),
          SrcUserType = _ASIM_GetUserType(SrcUsername, ""),
          SrcDomainType = iff(isnotempty(SrcDomain), "FQDN", ""),
          DvcIdType = iff(isnotempty(DvcId), "Other", ""),
          AdditionalFields = bag_merge(AdditionalFields_threat, AdditionalFields_Common),
          SrcAppName = SrcProcessName,
          SrcAppId = SrcProcessId,
          SrcAppType = "Process",
          Hostname = DstHostname
      | project-away
          *_d,
          *_s,
          *_g,
          *_b,
          temp_action,
          _ResourceId,
          Computer,
          MG,
          ManagementGroupName,
          RawData,
          SourceSystem,
          TenantId,
          AdditionalFields_*
  };
  parser(disabled = disabled)
}



//
// Function Name: ASimNetworkSessionWatchGuardFirewareOS
// Description: This ASIM parser supports normalizing WatchGuard Fireware OS logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionWatchGuardFirewareOS(    ['disabled']:bool=false)
{
let Parser=(disabled:bool=false){
  let EventLookup=datatable(DvcAction:string,EventResult:string,EventSeverity:string)
  [
      "Allow","Success","Informational"
      , "Deny","Failure","Low"
  ];
  let SyslogParser = (T:(SyslogMessage:string)) {
      T
      | parse-kv SyslogMessage as (geo_src:string
      , geo_dst:string
      , src_user:string
      , dst_user:string
      , duration:int
      , sent_bytes:long
      , rcvd_bytes:long
      , fqdn_src_match:string
      , fqdn_dst_match:string) with (pair_delimiter=' ', kv_delimiter='=', quote='"')
      | project-rename SrcGeoCountry = geo_src
      , DstGeoCountry = geo_dst
      , SrcUsername = src_user
      , DstUsername = dst_user
      , NetworkDuration = duration
      , SrcBytes = sent_bytes
      , DstBytes = rcvd_bytes
      , DstDomain = fqdn_dst_match
      , SrcDomain = fqdn_src_match
      | extend DvcAction = extract(@'" (Allow|Deny) ', 1, SyslogMessage)
      | lookup EventLookup on DvcAction
      | extend DstDomainType = iif(isnotempty(DstDomain),"FQDN","")
      | extend SrcDomainType = iif(isnotempty(SrcDomain),"FQDN","")
      | extend NetworkProtocol = extract(@" (tcp|udp|icmp|igmp) ", 1, SyslogMessage)
      | extend SrcUsernameType = case(isempty(SrcUsername), ""
        , countof(SrcUsername, "@") == 1, "UPN"
        , "Simple"
      )
      | extend DstUsernameType = case(isempty(DstUsername), ""
        , countof(DstUsername, "@") == 1, "UPN"
        , "Simple"
      )
      | parse SyslogMessage with * "repeated " EventCount:int " times" *
      | extend EventCount = iif(isnotempty(EventCount), EventCount, toint(1))
      | project-away SyslogMessage
  };
  let AllSyslog = 
  Syslog
  | where not(disabled)
  | where SyslogMessage has_any('msg_id="3000-0148"' 
      , 'msg_id="3000-0149"' 
      , 'msg_id="3000-0150"'
      , 'msg_id="3000-0151"'
      , 'msg_id="3000-0173"'
  ) and SyslogMessage !has 'msg="DNS Forwarding" '
  | project TimeGenerated, SyslogMessage, HostName
  ;
  let Parse1 = 
  AllSyslog
  | where SyslogMessage !has "icmp" and SyslogMessage !has "igmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} (tcp|udp) \d{2,5} \d{2,5} " SrcIpAddr " " DstIpAddr " " SrcPortNumber:int @" " DstPortNumber:int @" " *
  | invoke SyslogParser()
  ;
  let Parse2 = 
  AllSyslog
  | where SyslogMessage !has "icmp" and SyslogMessage !has "igmp" and SyslogMessage has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" (tcp|udp) " SrcIpAddr " " DstIpAddr " " SrcPortNumber:int @" " DstPortNumber:int @" " *
  | invoke SyslogParser()
  ;
  let Parse3 = 
  AllSyslog
  | where SyslogMessage has "icmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} icmp \d{2,5} \d{1,5} " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  ;
  let Parse4 = 
  AllSyslog
  | where SyslogMessage has "icmp" and SyslogMessage has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" icmp " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  ;
  let Parse5 = 
  AllSyslog
  | where SyslogMessage has "igmp" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'" (Allow|Deny) ' RuleName @" \d{2,5} igmp \d{2,5} \d{1,5} " SrcIpAddr " " DstIpAddr " " * 
  | invoke SyslogParser()
  ;
  union isfuzzy=false Parse1, Parse2, Parse3, Parse4, Parse5
  | extend EventSchema = "NetworkSession"
      , EventSchemaVersion = "0.2.4"
      , EventVendor = "WatchGuard"
      , EventProduct = "Fireware"
      , EventType = "NetworkSession"
      , DvcHostname = HostName
      , NetworkProtocolVersion = case(DstIpAddr contains ".", "IPv4"
          , DstIpAddr contains ":", "IPv6"
          , "")
      , NetworkProtocol = toupper(NetworkProtocol)
      , NetworkDuration = toint(NetworkDuration * toint(1000))
      , NetworkBytes = SrcBytes + DstBytes
      , EventEndTime = TimeGenerated
      , EventStartTime = TimeGenerated
      , Src = SrcIpAddr
      , Dst = DstIpAddr
      , Duration = NetworkDuration
      , User = DstUsername
      , IpAddr = SrcIpAddr
  | project-rename Dvc = HostName
};
Parser (disabled)
}



//
// Function Name: ASimNetworkSessionZscalerZIA
// Description: This ASIM parser supports normalizing Zscaler ZIA proxy logs produced by the Microsoft Sentinel Zscaler connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) ASimNetworkSessionZscalerZIA(    ['disabled']:bool=false)
{
let ActionLookup = datatable (DvcOriginalAction: string, DvcAction:string) [
  // See https://help.zscaler.com/zia/firewall-insights-logs-filters
  'Allow','Allow',
  'Allow due to insufficient app data','Allow',
  'Block/Drop','Drop',
  'Block/ICMP','Drop ICMP',
  'Block/Reset', 'Reset',
  'IPS Drop', 'Drop',
  'IPS Reset', 'Reset',
  // Observed in real world events
  'Block ICMP', 'Drop ICMP',
  'Drop', 'Drop'
];
let parser=(disabled:bool=false){
CommonSecurityLog | where not(disabled)
| where DeviceVendor == "Zscaler"
| where DeviceProduct == "NSSFWlog"
// Event fields
| extend 
  EventStartTime=TimeGenerated, 
  EventVendor = "Zscaler", 
  EventProduct = "ZIA Firewall", 
  EventSchema = "NetworkSession", 
  EventSchemaVersion="0.2.1", 
  EventType = 'NetworkSession', 
  EventSeverity = 'Informational',
  EventEndTime=TimeGenerated 
| project-rename
  DvcOriginalAction = DeviceAction, 
  DvcHostname = Computer, 
  EventProductVersion = DeviceVersion, 
  NetworkProtocol = Protocol, 
  DstIpAddr = DestinationIP, 
  DstPortNumber = DestinationPort, 
  DstNatIpAddr = DestinationTranslatedAddress, 
  DstNatPortNumber = DestinationTranslatedPort,
  DstAppName = DeviceCustomString3, 
  NetworkApplicationProtocol = DeviceCustomString2, 
  SrcIpAddr = SourceIP, 
  SrcPortNumber = SourcePort, 
  SrcUsername = SourceUserName,
  SrcNatIpAddr= SourceTranslatedAddress, 
  SrcNatPortNumber = SourceTranslatedPort, 
  SrcUserDepartment = DeviceCustomString1,  // Not in standard schema
  SrcUserLocation = SourceUserPrivileges,  // Not in standard schema
  ThreatName = DeviceCustomString6, 
  ThreatCategory = DeviceCustomString5, 
  NetworkRuleName = Activity,
  EventOriginalSeverity = LogSeverity,
  EventMessage = Message
// -- Calculated fields
| lookup ActionLookup on DvcOriginalAction 
| extend
  // -- Adjustment to support both old and new CSL fields.
  EventCount=coalesce(
    toint(column_ifexists("FieldDeviceCustomNumber2", int(null))), 
    toint(column_ifexists("DeviceCustomNumber2",int(null)))
  ),
  NetworkDuration = coalesce(
    toint(column_ifexists("FieldDeviceCustomNumber1", int(null))),
    toint(column_ifexists("DeviceCustomNumber1",int(null)))
  ),
  ThreatCategory = iff(DeviceCustomString4 == "None", "", ThreatCategory),
  SrcUsername = iff (SrcUsername == SrcUserLocation, "", SrcUsername),
  DstBytes = tolong(ReceivedBytes), 
  SrcBytes = tolong(SentBytes)
// -- Enrichment
| extend
  EventResult = iff (DvcOriginalAction == "Allow", "Success", "Failure"),
  DstAppType = "Service", 
  SrcUsernameType = "UPN" 
// -- Aliases
| extend
  Dvc = DvcHostname,
  User = SrcUsername,
  IpAddr = SrcIpAddr,
  Src = SrcIpAddr,
  Dst = DstIpAddr,
  Rule = NetworkRuleName,
  Duration = NetworkDuration
| project-away AdditionalExtensions, CommunicationDirection, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, ReceiptTime, ReceivedBytes, Remote*, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, EventOutcome, FieldDevice*, ExtID, Reason, ApplicationProtocol, ReportReferenceLink
};
parser (disabled)
}



//
// Function Name: imNetworkSession
// Description: This ASIM parser supports filtering and normalizing Network Session logs from all supported sources to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) imNetworkSession(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['pack']:bool=false)
{
let DisabledParsers=materialize(_GetWatchlist('ASimDisabledParsers') | where SearchKey in ('Any', 'ExcludevimNetworkSession') | extend SourceSpecificParser=column_ifexists('SourceSpecificParser','') | distinct SourceSpecificParser | where isnotempty(SourceSpecificParser));
let ASimBuiltInDisabled=toscalar('ExcludevimNetworkSession' in (DisabledParsers) or 'Any' in (DisabledParsers)); 
let NetworkSessionsGeneric=(
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null),
  srcipaddr_has_any_prefix:dynamic=dynamic([]),
  dstipaddr_has_any_prefix:dynamic=dynamic([]),
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null),
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]),
  eventresult:string='*',
  pack:bool=false)
{
union isfuzzy=true
  vimNetworkSessionEmpty
  , vimNetworkSessionLinuxSysmon                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionLinuxSysmon'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoft365Defender            (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoft365Defender'      in (DisabledParsers) ))
  , vimNetworkSessionMD4IoTAgent                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMD4IoTAgent'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftWindowsEventFirewall   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftWindowsEventFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftSecurityEventFirewall   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftSecurityEventFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionPaloAltoCEF                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionPaloAltoCEF'      in (DisabledParsers) ))
  , vimNetworkSessionVMConnection                    (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionVMConnection'      in (DisabledParsers) ))
  , vimNetworkSessionAWSVPC                          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAWSVPC'      in (DisabledParsers) ))
  , vimNetworkSessionAzureFirewall                   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAzureFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionAzureNSG                        (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAzureNSG'      in (DisabledParsers) ))
  , vimNetworkSessionVectraAI                        (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, pack=pack, disabled=(ASimBuiltInDisabled or ('ExcludevimNetworkSessionVectraAI' in (DisabledParsers) )))
  , vimNetworkSessionCiscoMeraki                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoMeraki'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoMerakiSyslog                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoMerakiSyslog'      in (DisabledParsers) ))
  , vimNetworkSessionAppGateSDP                      (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionAppGateSDP'      in (DisabledParsers) ))
  , vimNetworkSessionFortinetFortiGate               (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionFortinetFortiGate'      in (DisabledParsers) ))
  , vimNetworkSessionCorelightZeek                   (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCorelightZeek'      in (DisabledParsers) ))
  , vimNetworkSessionCheckPointFirewall              (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCheckPointFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionWatchGuardFirewareOS            (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionWatchGuardFirewareOS'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoASA                        (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoASA'      in (DisabledParsers) ))
  , vimNetworkSessionForcePointFirewall              (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionForcePointFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionNative                          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionNative'      in (DisabledParsers) ))
  , vimNetworkSessionSentinelOne                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionSentinelOne'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoMeraki                     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoMeraki'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoISE                        (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoISE'      in (DisabledParsers) ))
  , vimNetworkSessionBarracudaWAF                    (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionBarracudaWAF'      in (DisabledParsers) ))
  , vimNetworkSessionBarracudaCEF                  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionBarracudaCEF'      in (DisabledParsers) ))
  , vimNetworkSessionCiscoFirepower                  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCiscoFirepower'      in (DisabledParsers) ))
  , vimNetworkSessionCrowdStrikeFalconHost           (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionCrowdStrikeFalconHost'      in (DisabledParsers) ))
  , vimNetworkSessionVMwareCarbonBlackCloud          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionVMwareCarbonBlackCloud'      in (DisabledParsers) ))
  , vimNetworkSessionPaloAltoCortexDataLake          (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionPaloAltoCortexDataLake'      in (DisabledParsers) ))
  , vimNetworkSessionSonicWallFirewall               (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionSonicWallFirewall'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftSysmon                 (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftSysmon'      in (DisabledParsers) ))
  , vimNetworkSessionMicrosoftSysmonWindowsEvent     (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, ASimBuiltInDisabled or ('ExcludevimNetworkSessionMicrosoftSysmonWindowsEvent'      in (DisabledParsers) ))
};
NetworkSessionsGeneric(starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, pack=pack)
}



//
// Function Name: vimNetworkSessionAppGateSDP
// Description: This ASIM parser supports filtering and normalizing AppGate SDP with event type 'ip-access' logs to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAppGateSDP(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
  starttime:datetime=datetime(null), 
  endtime:datetime=datetime(null), 
  srcipaddr_has_any_prefix:dynamic=dynamic([]), 
  dstipaddr_has_any_prefix:dynamic=dynamic([]), 
  ipaddr_has_any_prefix:dynamic=dynamic([]),
  dstportnumber:int=int(null), 
  hostname_has_any:dynamic=dynamic([]), 
  dvcaction:dynamic=dynamic([]), 
  eventresult:string='*', 
  disabled:bool=false
) 
{
  let DirectionLookup = datatable (direction:string, NetworkDirection:string) 
  [
    'up', 'Inbound',
    'down', 'Outbound'
  ];
  let ActionLookup = datatable (DvcOriginalAction:string, DvcAction:string, EventSeverity:string, EventResult:string)
  [
    'allow', 'Allow', 'Informational', 'Success',
    'drop', 'Drop', 'Low', 'Failure',
    'reject', 'Deny', 'Low', 'Failure',
    'block', 'Deny', 'Low', 'Failure',
    'block_report', 'Deny', 'Low', 'Failure',
    'allow_report', 'Allow', 'Informational', 'Success'
  ];
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);    
  let ip_access_events = 
    Syslog
    | where (isnull(starttime) or TimeGenerated>=starttime) 
      and (isnull(endtime) or TimeGenerated<=endtime) 
      and not(disabled)
      and (array_length(hostname_has_any) == 0)
      and ProcessName in ("cz-sessiond", "cz-vpnd")
      and SyslogMessage has_all ("[AUDIT]",'"event_type":"ip_access"')
    | project TimeGenerated, SyslogMessage, Computer
  ;
  let tcpupd_success = 
    ip_access_events
    | where 
      SyslogMessage has '"rule_name"'
      and SyslogMessage has_any ('"protocol":"UDP"','"protocol":"TCP"') 
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any)) 
      and (isnull(dstportnumber) or SyslogMessage has (strcat('"destination_port":', tostring(dstportnumber)))) 
      and (eventresult=='*' or iff(eventresult=='Success', SyslogMessage has 'allow', SyslogMessage has_any('drop', 'reject','block')))
    | parse SyslogMessage with * '"action":"' DvcOriginalAction:string '",' * 
    | lookup ActionLookup on DvcOriginalAction
    | where 
      (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
      and (eventresult=='*' or EventResult == eventresult)
    | parse-where SyslogMessage with 
        *
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"destination_port":' DstPortNumber:int ',' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *          
        '"rule_name":"' NetworkRuleName:string '",' *  
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"source_port":' SrcNatPortNumber:int ',' * 
        '"version":' EventProductVersion:string '}' *
    ;
  let tcpupd_fail = 
    ip_access_events
    | where 
      SyslogMessage has'"drop-reason"'
      and SyslogMessage has_any ('"protocol":"UDP"','"protocol":"TCP"') 
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any)) 
      and (isnull(dstportnumber) or SyslogMessage has (strcat('"destination_port":', tostring(dstportnumber)))) 
      and (eventresult=='*' or iff(eventresult=='Success', SyslogMessage has 'allow', SyslogMessage has_any('drop', 'reject','block')))
    | parse SyslogMessage with * '"action":"' DvcOriginalAction:string '",' * 
    | lookup ActionLookup on DvcOriginalAction
    | where 
      (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
      and (eventresult=='*' or EventResult == eventresult)
    | parse-where SyslogMessage with 
        *
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"destination_port":' DstPortNumber:int ',' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"drop-reason":"' EventOriginalResultDetails:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"source_port":' SrcNatPortNumber:int ',' * 
        '"version":' EventProductVersion:string '}' *
      ;
  let icmp_success = 
    ip_access_events
    | where 
      SyslogMessage has '"ICMP"'
      and (array_length(ip_any)==0 or has_any_ipv4_prefix(SyslogMessage,ip_any)) 
      and (isnull(dstportnumber)) 
      and (eventresult=='*' or iff(eventresult=='Success', SyslogMessage has 'allow', SyslogMessage has_any('drop', 'reject','block')))
    | parse SyslogMessage with * '"action":"' DvcOriginalAction:string '",' * 
    | lookup ActionLookup on DvcOriginalAction
    | where 
      (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
      and (eventresult=='*' or EventResult == eventresult)
    | parse-where SyslogMessage with 
        *
        '"action":"' DvcOriginalAction:string '",' * 
        '"client_ip":"' SrcIpAddr:string '",' *
        '"client_port":' SrcPortNumber:int ',' *
        '"destination_ip":"' DstIpAddr:string '",' *
        '"direction":"' direction:string '",' * 
        '"distinguished_name_device_id":"' SrcDvcId:string '",' *
        '"distinguished_name_user":"' SrcUsername:string '",' *
        '"entitlement_token_id":"' NetworkSessionId:string '",' *
        '"icmp_code":' NetworkIcmpSubCode:int ',' *
        '"icmp_type":' NetworkIcmpCode:int ',' *  
        '"packet_size":' SrcBytes:long ',' *
        '"protocol":"' NetworkProtocol:string '",' *          
        '"rule_name":"' NetworkRuleName:string '",' *  
        '"source_ip":"' SrcNatIpAddr:string '",' *
        '"version":' EventProductVersion:string '}' *
    ;
  union  tcpupd_success, tcpupd_fail, icmp_success 
  | extend 
    temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), 
    temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | project-away temp*
  | where ASimMatchingIpAddr != "No match"
  | parse SyslogMessage with 
      *
      '"country_name":"' SrcGeoCountry:string '",' *
      '"lat":' SrcGeoLatitude:real ',' *        
      '"lon":' SrcGeoLongitude:real '}' *
  | parse SyslogMessage with 
       *
      '"city_name":"' SrcGeoCity:string '",' *
      '"region_name":"' SrcGeoRegion:string '",' *
  | extend 
      SrcDvcIdType = 'AppGateId',
      SrcUsernameType = 'UPN'
  // -- Event fields
  | project-rename 
      DvcHostname = Computer
  | extend 
      EventCount = int(1),
      EventEndTime = TimeGenerated,
      EventStartTime = TimeGenerated,
      EventSchema = 'NetworkSession',
      EventSchemaVersion = '0.2.3',
      EventVendor = 'AppGate',
      EventProduct = 'SDP',
      EventType = 'NetworkSession'
  | lookup DirectionLookup on direction
  // -- Aliases
  | extend 
      Src = SrcIpAddr,
      Dst = DstIpAddr,
      Dvc = DvcHostname,
      SessionId = NetworkSessionId,
      IpAddr = SrcIpAddr,
      Rule = NetworkRuleName,
  // -- Entity identifier explicit aliases
      SrcUserUpn = SrcUsername
  | project-away 
      SyslogMessage, direction
};
parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



//
// Function Name: vimNetworkSessionAWSVPC
// Description: This ASIM parser supports normalizing and filtering AWS VPC logs produced by the Microsoft Sentinel AWS S3 connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAWSVPC(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ProtocolLookup = datatable(Protocol:int, NetworkProtocol:string) [
    0,"HOPOPT",
    1,"ICMP",
    2,"IGMP",
    3,"GGP",
    4,"IPv4",
    5,"ST",
    6,"TCP",
    7,"CBT",
    8,"EGP",
    9,"IGP",
    10,"BBN-RCC-MON",
    11,"NVP-II",
    12,"PUP",
    13,"ARGUS (deprecated)",
    14,"EMCON",
    15,"XNET",
    16,"CHAOS",
    17,"UDP",
    18,"MUX",
    19,"DCN-MEAS",
    20,"HMP",
    21,"PRM",
    22,"XNS-IDP",
    23,"TRUNK-1",
    24,"TRUNK-2",
    25,"LEAF-1",
    26,"LEAF-2",
    27,"RDP",
    28,"IRTP",
    29,"ISO-TP4",
    30,"NETBLT",
    31,"MFE-NSP",
    32,"MERIT-INP",
    33,"DCCP",
    34,"3PC",
    35,"IDPR",
    36,"XTP",
    37,"DDP",
    38,"IDPR-CMTP",
    39,"TP++",
    40,"IL",
    41,"IPv6",
    42,"SDRP",
    43,"IPv6-Route",
    44,"IPv6-Frag",
    45,"IDRP",
    46,"RSVP",
    47,"GRE",
    48,"DSR",
    49,"BNA",
    50,"ESP",
    51,"AH",
    52,"I-NLSP",
    53,"SWIPE (deprecated)",
    54,"NARP",
    55,"MOBILE",
    56,"TLSP",
    57,"SKIP",
    58,"IPv6-ICMP",
    59,"IPv6-NoNxt",
    60,"IPv6-Opts",
    61,"",
    62,"CFTP",
    63,"",
    64,"SAT-EXPAK",
    65,"KRYPTOLAN",
    66,"RVD",
    67,"IPPC",
    68,"",
    69,"SAT-MON",
    70,"VISA",
    71,"IPCV",
    72,"CPNX",
    73,"CPHB",
    74,"WSN",
    75,"PVP",
    76,"BR-SAT-MON",
    77,"SUN-ND",
    78,"WB-MON",
    79,"WB-EXPAK",
    80,"ISO-IP",
    81,"VMTP",
    82,"SECURE-VMTP",
    83,"VINES",
    84,"TTP",
    84,"IPTM",
    85,"NSFNET-IGP",
    86,"DGP",
    87,"TCF",
    88,"EIGRP",
    89,"OSPFIGP",
    90,"Sprite-RPC",
    91,"LARP",
    92,"MTP",
    93,"AX.25",
    94,"IPIP",
    95,"MICP (deprecated)",
    96,"SCC-SP",
    97,"ETHERIP",
    98,"ENCAP",
    99,"",
    100,"GMTP",
    101,"IFMP",
    102,"PNNI",
    103,"PIM",
    104,"ARIS",
    105,"SCPS",
    106,"QNX",
    107,"A/N",
    108,"IPComp",
    109,"SNP",
    110,"Compaq-Peer",
    111,"IPX-in-IP",
    112,"VRRP",
    113,"PGM",
    114,"",
    115,"L2TP",
    116,"DDX",
    117,"IATP",
    118,"STP",
    119,"SRP",
    120,"UTI",
    121,"SMP",
    122,"SM (deprecated)",
    123,"PTP",
    124,"ISIS over IPv4",
    125,"FIRE",
    126,"CRTP",
    127,"CRUDP",
    128,"SSCOPMCE",
    129,"IPLT",
    130,"SPS",
    131,"PIPE",
    132,"SCTP",
    133,"FC",
    134,"RSVP-E2E-IGNORE",
    135,"Mobility Header",
    136,"UDPLite",
    137,"MPLS-in-IP",
    138,"manet",
    139,"HIP",
    140,"Shim6",
    141,"WESP",
    142,"ROHC",
    143,"Ethernet",
    253,"",
    254,"",
    255,"Reserved"
  ];
  let DirectionLookup = datatable (FlowDirection:string, NetworkDirection:string)  [
    'ingress', 'Inbound',
    'egress', 'Outbound'
  ];
  let ActionLookup = datatable (Action:string, DvcAction:string)  [
    'ACCEPT', 'Allow',
    'REJECT', 'Deny'
  ];
  let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null), 
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false
      )
  {
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  
  AWSVPCFlow 
  | where(isnull(starttime) or TimeGenerated >= starttime)
    and (isnull(endtime)   or TimeGenerated <= endtime)
  | where not(disabled)
  | where LogStatus == "OK"
  // -- Pre-filtering:
  | where
         (isnull(dstportnumber) or (DstPort == dstportnumber))
    and (array_length(hostname_has_any) == 0)
  | extend EventResult = iff (Action=="ACCEPT","Success","Failure")
  | where (eventresult == "*" or eventresult == EventResult) 
  | lookup ActionLookup on Action
  | where  (array_length(dvcaction) == 0 or DvcAction in (dvcaction))
  | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcAddr,src_or_any)
         , temp_isDstMatch=has_any_ipv4_prefix(DstAddr,dst_or_any)
  | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
  )
  | project-away temp_*
  | where ASimMatchingIpAddr != "No match"
  // -- End pre-filtering
  | extend
      EventVendor="AWS", 
      EventProduct="VPC",
      NetworkBytes = tolong(Bytes),
      NetworkPackets = tolong(Packets),
      EventProductVersion = tostring(Version),
      EventType="NetworkSession",
      EventCount=toint(1),
      EventSeverity = iff (Action=="ACCEPT","Informational","Low"),
      EventSchemaVersion="0.2.3",
      EventSchema="NetworkSession",
      SrcAppType = iff (PktSrcAwsService != "", "CloudService", ""),
      DstAppType = iff (PktDstAwsService != "", "CloudService", ""),
      DvcIdType = "AwsVpcId"
  | lookup ProtocolLookup on Protocol
  | lookup DirectionLookup on FlowDirection
  | project-rename
      DstIpAddr = DstAddr,  
      DstPortNumber = DstPort, 
      SrcNatIpAddr=PktSrcAddr, 
      DstNatIpAddr=PktDstAddr, 
      SrcPortNumber = SrcPort,  
      SrcIpAddr = SrcAddr, 
      EventEndTime = End, 
      DvcInboundInterface = InterfaceId,
      DvcSubscriptionId = AccountId,
      DvcId = VpcId,
      NetworkProtocolVersion = TrafficType,
      EventOriginalResultDetails = LogStatus,
      SrcAppName = PktSrcAwsService,
      DstAppName = PktDstAwsService
  // -- Aliases
  | extend
      IpAddr = SrcIpAddr,
      Src = SrcIpAddr,
      Dst = DstIpAddr,
      Dvc = DvcId,
      EventStartTime = TimeGenerated,
      DvcInterface = DvcInboundInterface
  | project-away Action, AzId, Bytes, FlowDirection, InstanceId, Packets, Protocol, Region, SourceSystem, SublocationId, SublocationType, SubnetId, TcpFlags, TenantId, TrafficPath, Version
  };
  parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix,dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionAzureFirewall
// Description: This ASIM parser supports filtering and normalizing Azure Firewall logs to the ASIM Network Session normalized schema. This parser is partially based on a work by [Koos Goossens](https://github.com/TheCloudScout).

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAzureFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null), 
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false)
{
    let ip_any=set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
    let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
    let AzureFirewallNetworkRuleLogs = 
        AzureDiagnostics
        | where (isnull(starttime) or TimeGenerated >= starttime) 
          and (isnull(endtime)   or TimeGenerated <= endtime) 
          and not(disabled)
        | where Category == "AzureFirewallNetworkRule"
        | where isnotempty(msg_s)
        | project msg_s, OperationName, SubscriptionId, ResourceId, TimeGenerated, Type, _ResourceId;
    let prefilter = (T: (msg_s:string, TimeGenerated:datetime, OperationName:string)) {
      T | where  
      //(isnull(starttime) or TimeGenerated >= starttime) 
       // and (isnull(endtime)   or TimeGenerated <= endtime) 
       (array_length(hostname_has_any) == 0)
       and (isnull(dstportnumber) or msg_s has (tostring(dstportnumber)))
       and (array_length(ip_any)==0 
          or has_any_ipv4_prefix(msg_s,ip_any)
        ) 
    };
    let AzureFirewallSessionLogs = 
        AzureFirewallNetworkRuleLogs
        | where OperationName in ("AzureFirewallNetworkRuleLog","AzureFirewallThreatIntelLog")
        // -- pre-filter
        | where (array_length(dvcaction) == 0) or (msg_s has_any (dvcaction))
        | where (eventresult == "*") or ((eventresult == "Success") and (msg_s has "Allow")) or ((eventresult == "Failure") and (msg_s has "Deny"))
        | invoke prefilter()
        // -- end pre-filter
        | parse-where
            msg_s with           NetworkProtocol:string 
            " request from "     SrcIpAddr:string
            ":"                  SrcPortNumber:int
            " to "               DstIpAddr:string
            ":"                  DstPortNumber:int
            ". Action: "         DvcAction:string
            "."                  *
        | project-away msg_s
        | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
               , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
         | extend ASimMatchingIpAddr = case(
              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" 
              , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
              , temp_isSrcMatch, "SrcIpAddr"
              , temp_isDstMatch, "DstIpAddr"
              , "No match"
           )
        | project-away temp_*
        | where ASimMatchingIpAddr != "No match"
        | extend NetworkIcmpCode = iff(NetworkProtocol startswith "ICMP", toint(extract ("type=(\\d+)",1,NetworkProtocol)), int(null))
        | extend NetworkIcmpType = iff(isnotnull(NetworkIcmpCode), _ASIM_LookupICMPType(NetworkIcmpCode), "")
        | extend NetworkProtocol = iff(NetworkProtocol startswith "ICMP", "ICMP", NetworkProtocol)
        | extend EventSeverity = case (
            OperationName  == "AzureFirewallThreatIntelLog", "Medium",
            DvcAction == "Deny", "Low",
            "Informational")
        | extend EventResult = iff(DvcAction == "Allow", "Success", "Failure")
        ;
    let AzureFirewallNATLogs = 
        AzureFirewallNetworkRuleLogs
        | where OperationName == "AzureFirewallNatRuleLog"
        // -- pre-filter
        | where (array_length(dvcaction) == 0) or ("Allow" in (dvcaction))
        | where eventresult in ("*", "Success")
        | invoke prefilter()
        // -- end pre-filter
        | parse-where
            msg_s with           NetworkProtocol:string 
            " request from "     SrcIpAddr:string
            ":"                  SrcPortNumber:int
            " to "               DstIpAddr:string
            ":"                  DstPortNumber:int
            " was DNAT'ed to "   DstNatIpAddr:string
            ":"                  DstNatPortNumber:int
        | project-away msg_s
        | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any)
               , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
         | extend ASimMatchingIpAddr = case(
              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" 
              , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
              , temp_isSrcMatch, "SrcIpAddr"
              , temp_isDstMatch, "DstIpAddr"
              , "No match"
           )
        | project-away temp_*
        | where ASimMatchingIpAddr != "No match"
        | extend EventSeverity = "Informational"
        | extend EventResult = "Success"
        | extend DvcAction = "Allow"
        ;
    union AzureFirewallSessionLogs, AzureFirewallNATLogs
    | where 
        (isnull(dstportnumber) or DstPortNumber ==dstportnumber)
    // -- end post-filtering
    | extend
        EventVendor="Microsoft",
        EventProduct="Azure Firewall",
        EventType="NetworkSession",
        EventCount=toint(1),
        EventSchemaVersion="0.2.3",
        EventSchema="NetworkSession",
        DvcIdType = "AzureResourceId"
    | project-rename
        DvcSubscriptionId = SubscriptionId,
        DvcId = ResourceId
    // -- Aliases
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        Dvc = DvcId,
        EventStartTime = TimeGenerated,
        EventEndTime = TimeGenerated // ??
    | project-keep
        ASim*,
        Src*,
        Dst*,
        Event*,
        Dvc*,
        IpAddr,
        NetworkIcmpCode,
        NetworkIcmpType,
        NetworkProtocol,
        Type,
        _ResourceId,
        TimeGenerated
};
parser  (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionAzureNSG
// Description: This ASIM parser supports normalizing and filtering Azure Azure Network Security Groups (NSG) flows to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionAzureNSG(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let DvcActionLookup = datatable(FlowStatus_s:string, DvcAction:string, EventResult:string) [
    'A', 'Allow', 'Success',
    'D', 'Deny', 'Failure',
];
let NetworkDirectionLookup = datatable(FlowDirection_s:string, NetworkDirection:string, isOutBound:bool) [
    'I', 'Inbound', false,
    'O', 'Outbound', true
];
let NetworkProtocolLookup = datatable(L4Protocol_s:string, NetworkProtocol:string)[
    'T', 'TCP',
    'U', 'UDP'
];
let parser = (
      starttime:datetime=datetime(null), 
      endtime:datetime=datetime(null),
      srcipaddr_has_any_prefix:dynamic=dynamic([]), 
      dstipaddr_has_any_prefix:dynamic=dynamic([]), 
      ipaddr_has_any_prefix:dynamic=dynamic([]),
      dstportnumber:int=int(null), 
      hostname_has_any:dynamic=dynamic([]), 
      dvcaction:dynamic=dynamic([]), 
      eventresult:string='*', 
      disabled:bool=false)
{
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let prefilter = (T:(TimeGenerated:datetime, SrcIP_s:string, SrcPublicIPs_s:string, DestIP_s:string, DestPublicIPs_s:string, DestPort_d:real, FlowStatus_s:string, VM1_s:string, VM2_s:string)) { 
    T
    | where
      (isnull(dstportnumber) or dstportnumber == toint(DestPort_d)) 
    | extend dataSrcIPs = strcat(SrcIP_s," ",SrcPublicIPs_s),
             dataDstIPs = strcat(DestIP_s," ",DestPublicIPs_s)
    | extend temp_isSrcMatch=has_any_ipv4_prefix(dataSrcIPs,src_or_any)
           , temp_isDstMatch=has_any_ipv4_prefix(dataDstIPs,dst_or_any)
    | extend ASimMatchingIpAddr = case(
          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
          , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
          , temp_isSrcMatch, "SrcIpAddr"
          , temp_isDstMatch, "DstIpAddr"
          , "No match"
        )
    | where ASimMatchingIpAddr != "No match"
    | extend temp_is_MatchSrcHostname = VM1_s has_any (hostname_has_any)
            , temp_is_MatchDstHostname = VM2_s has_any (hostname_has_any)
    | extend ASimMatchingHostname = case(array_length(hostname_has_any) == 0 ,"-",
                                temp_is_MatchSrcHostname and temp_is_MatchDstHostname, "Both",
                                temp_is_MatchSrcHostname, "SrcHostname",
                                temp_is_MatchDstHostname, "DstHostname",
                                "No match"
                              )
    | where ASimMatchingHostname != "No match"
    | project-away temp_*
    | lookup DvcActionLookup on FlowStatus_s
    | where array_length(dvcaction) == 0 or DvcAction in (dvcaction)
    | where (eventresult=='*' or EventResult == eventresult)
  }; // prefilter ends
  let AzureNetworkAnalytics = 
    AzureNetworkAnalytics_CL
    | where
     (isnull(starttime) or TimeGenerated >= starttime)
      and  (isnull(endtime) or TimeGenerated <= endtime)
    | where not(disabled) and isnotempty(FlowType_s)
    | lookup NetworkDirectionLookup on FlowDirection_s
  ;
  let AzureNetworkAnalyticsInbound =
    AzureNetworkAnalytics
    | where not(isOutBound)
    | invoke prefilter()
    | project-rename
        DstMacAddr = MACAddress_s
    | extend
        DstBytes = tolong(OutboundBytes_d), // -- size fields seem not to be populated for inbound
        DstPackets = tolong(OutboundPackets_d),
        SrcBytes = tolong(InboundBytes_d),
        SrcPackets = tolong(InboundPackets_d),
        SrcInterfaceName = tostring(split(NIC_s, '/')[1]),
        SrcGeoCountry = toupper(Country_s)
    | extend hostelements=split(VM2_s,'/')
    | extend 
        DstFQDN = strcat(hostelements[0], @"\", hostelements[1]),
        DstHostname = tostring(hostelements[1]),
        DstDomain = tostring(hostelements[0]),
        DstDomainType = "ResourceGroup"
    | extend Hostname = DstHostname
    | project-away hostelements, isOutBound
  ;  
  let AzureNetworkAnalyticsOutbound =
    AzureNetworkAnalytics
    | where isOutBound
    | invoke prefilter()
    | project-rename
        SrcMacAddr = MACAddress_s
    | extend
        SrcBytes   = tolong(OutboundBytes_d), 
        SrcPackets = tolong(OutboundPackets_d),
        DstBytes   = tolong(InboundBytes_d),
        DstPackets = tolong(InboundPackets_d),
        DstInterfaceName = tostring(split(NIC_s, '/')[1]),
        DstGeoCountry = toupper(Country_s)
    | extend hostelements=split(VM1_s,'/')
    | extend 
        SrcFQDN = strcat(hostelements[0], @"\", hostelements[1]),
        SrcHostname = tostring(hostelements[1]),
        SrcDomain = tostring(hostelements[0]),
        SrcDomainType = "ResourceGroup"
    | extend Hostname = SrcHostname
    | project-away hostelements, isOutBound
  ;
  union AzureNetworkAnalyticsInbound, AzureNetworkAnalyticsOutbound
  | project-rename
      Dvc = NSGList_s,
      DvcSubscriptionId = Subscription_g,
      EventEndTime = FlowEndTime_t,
      EventStartTime = FlowStartTime_t,
      NetworkApplicationProtocol = L7Protocol_s,
      NetworkRuleName = NSGRule_s,
      NetworkSessionId = ConnectionName_s,
      EventOriginalSubType = FlowType_s
  | extend
      DstPortNumber = toint(DestPort_d),
      EventProduct = 'NSGFlow',
      EventSchema = 'NetworkSession',
      EventSchemaVersion='0.2.3',
      EventSeverity = 'Informational', //??
      EventType = 'Flow',
      EventVendor = 'Microsoft',
      EventCount = toint(AllowedInFlows_d+DeniedInFlows_d+AllowedOutFlows_d+DeniedOutFlows_d),
      NetworkDuration = toint((((EventEndTime - datetime(1970-01-01)) / 1s) - ((EventStartTime - datetime(1970-01-01)) / 1s )) * 1000),
      Rule = NetworkRuleName,
      SessionId = NetworkSessionId
  | extend 
      DstIpAddr = iff(isnotempty(DestIP_s),
                      DestIP_s,
                      split(DestPublicIPs_s, '|')[0]),
      Duration = NetworkDuration,
      NetworkBytes = tolong(DstBytes + SrcBytes),
      NetworkPackets = tolong(DstPackets + SrcPackets),
      SrcIpAddr = iff(isnotempty(SrcIP_s),
                      SrcIP_s,
                      split(SrcPublicIPs_s, '|')[0])
  | extend
      Dst = DstIpAddr,
      IpAddr = SrcIpAddr,
      Src = SrcIpAddr
  | lookup NetworkProtocolLookup on L4Protocol_s
  | project-keep
      Src*,
      Dst*,
      Event*,
      Dvc*,
      Network*,
      IpAddr,
      Hostname,
      Type,
      Duration,
      SessionId,
      _ResourceId,
      TimeGenerated,
      ASim*
  | project-away *_s
};
parser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)
}



//
// Function Name: vimNetworkSessionBarracudaCEF
// Description: This ASIM parser supports normalizing Barracuda WAF logs ingested in 'CommonSecurityLog' table to the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionBarracudaCEF(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ProtocolLookup = datatable(
    Protocol_s: string,
    NetworkProtocol: string,
    NetworkProtocolVersion: string
)[
    "TCP", "TCP", "",
    "TCP/ip", "TCP", "",
    "UDP", "UDP", "",
    "UDP/ip", "UDP", "",
    "ICMP", "ICMP", "IPV4",
    "ICMPv6", "ICMP", "IPV6",
];
let SeverityLookup = datatable (severity: int, EventSeverity: string)
    [
    0, "High", 
    1, "High", 
    2, "High", 
    3, "Medium",
    4, "Low",
    5, "Low", 
    6, "Informational",
    7, "Informational" 
];
let EventResultLookup = datatable (
    ActionID_s: string,
    EventResult: string,
    DvcAction: string
)
    [
    "ALLOW", "Success", "Allow",
    "DENY", "Failure", "Deny"
];
let parser = (
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]),
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false){
let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
let BarracudaCEF = 
    CommonSecurityLog
    | where not(disabled) and DeviceVendor startswith "Barracuda" and (DeviceProduct == "WAF" or DeviceProduct == "WAAS")
    | where DeviceEventCategory == "NF"
    | where (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DestinationIP, dst_or_any)
    | extend ASimMatchingIpAddr = case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
        and (array_length(hostname_has_any) == 0 or DeviceName has_any (hostname_has_any))
    | where (isnull(dstportnumber) or (DestinationPort == dstportnumber))
    | lookup EventResultLookup on $left.DeviceAction == $right.ActionID_s
    | where (array_length(dvcaction) == 0 or DvcAction has_any(dvcaction))
    | where (eventresult == '*' or EventResult =~ eventresult)
    | extend 
        severity = toint(LogSeverity)
    | lookup SeverityLookup on severity
    | lookup ProtocolLookup on $left.Protocol == $right.Protocol_s
    | extend
        EventCount = toint(1),
        EventProduct = "WAF",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventVendor = "Barracuda"
    | extend
        Dvc = DeviceName,
        DstIpAddr = DestinationIP,
        SrcIpAddr = SourceIP,
        DvcHostname = DeviceName,
        DvcIpAddr = DestinationIP,                            
        DstPortNumber = toint(DestinationPort),
        SrcPortNumber = toint(SourcePort),
        EventProductVersion = DeviceVersion,
        EventUid = _ItemId,
        EventStartTime = iff(isnotempty(FlexNumber2), unixtime_milliseconds_todatetime(tolong(ReceiptTime)-tolong(FlexNumber2)), unixtime_milliseconds_todatetime(tolong(ReceiptTime)))
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst=DstIpAddr,
        EventEndTime = EventStartTime
    | project-away
        ThreatConfidence,
        CommunicationDirection,
        AdditionalExtensions,
        Device*,
        Source*,
        Destination*,
        Activity,
        LogSeverity,
        ApplicationProtocol,
        ProcessID,
        ExtID,
        Protocol,
        Reason,
        ReceiptTime,
        SimplifiedDeviceAction,
        OriginalLogSeverity,
        ProcessName,
        EndTime,
        ExternalID,
        File*,
        ReceivedBytes,
        Message,
        Old*,
        EventOutcome,
        Request*,
        StartTime,
        Field*,
        Flex*,
        Remote*,
        Malicious*,
        severity,
        ThreatSeverity,
        IndicatorThreatType,
        ThreatDescription,
        _ResourceId,
        SentBytes,
        ReportReferenceLink,
        Computer,
        temp_*,
        TenantId,CollectorHostName;
BarracudaCEF
};
parser(
    starttime=starttime, 
    endtime=endtime, 
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber,
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction,
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionBarracudaWAF
// Description: This ASIM parser supports normalizing Barracuda WAF logs ingested in 'barracuda_CL' tablet o the ASIM Web Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionBarracudaWAF(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let barracudaSchema = datatable(
    UnitName_s: string,
    DeviceReceiptTime_s: string,
    ActionID_s: string,
    DestinationIP_s: string,
    SourceIP: string,
    host_s: string,
    HostIP_s: string,
    Severity_s: string,
    LogType_s: string,
    DestinationPort_d: real,
    SourcePort_d: real,
    Protocol_s: string,
    DeviceVersion_s: string,
    TimeTaken_d: real,
    _ResourceId: string,
    RawData: string,
    Message: string,
    Computer: string,
    MG: string,
    ManagementGroupName: string,
    TenantId: string,
    SourceSystem: string,
    TimeGenerated: datetime
)[];
let ProtocolLookup = datatable(
    Protocol_s: string,
    NetworkProtocol: string,
    NetworkProtocolVersion: string
)[
    "TCP", "TCP", "",
    "TCP/ip", "TCP", "",
    "UDP", "UDP", "",
    "UDP/ip", "UDP", "",
    "ICMP", "ICMP", "IPV4",
    "ICMPv6", "ICMP", "IPV6",
];
let SeverityLookup = datatable (severity: int, EventSeverity: string)
    [
    0, "High", 
    1, "High", 
    2, "High", 
    3, "Medium",
    4, "Low",
    5, "Low", 
    6, "Informational",
    7, "Informational" 
];
let EventResultLookup = datatable (
    ActionID_s: string,
    EventResult: string,
    DvcAction: string
)
    [
    "ALLOW", "Success", "Allow",
    "DENY", "Failure", "Deny"
];
let parser = (
    starttime: datetime=datetime(null), 
    endtime: datetime=datetime(null),
    srcipaddr_has_any_prefix: dynamic=dynamic([]), 
    dstipaddr_has_any_prefix: dynamic=dynamic([]),
    ipaddr_has_any_prefix: dynamic=dynamic([]),
    dstportnumber: int=int(null), 
    hostname_has_any: dynamic=dynamic([]),
    dvcaction: dynamic=dynamic([]), 
    eventresult: string='*', 
    disabled: bool=false){
let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
let BarracudaCustom =  union isfuzzy=true
        barracudaSchema,
        barracuda_CL
    | where not(disabled)
        and LogType_s == "NF"
    | where (isnull(starttime) or TimeGenerated >= starttime)
        and (isnull(endtime) or TimeGenerated <= endtime)
    | extend
        temp_SrcMatch = has_any_ipv4_prefix(SourceIP, src_or_any),
        temp_DstMatch = has_any_ipv4_prefix(DestinationIP_s, dst_or_any)
    | extend ASimMatchingIpAddr = case(
                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0,
                                "-",
                                temp_SrcMatch and temp_DstMatch,
                                "Both",
                                temp_SrcMatch,
                                "SrcIpAddr",
                                temp_DstMatch,
                                "DstIpAddr",
                                "No match"
                            )
    | where ASimMatchingIpAddr != "No match"
        and (array_length(hostname_has_any) == 0 or host_s has_any (hostname_has_any))
    | where (isnull(dstportnumber) or (DestinationPort_d == dstportnumber))
    | lookup EventResultLookup on ActionID_s
    | where (array_length(dvcaction) == 0 or DvcAction has_any(dvcaction))
    | where (eventresult == '*' or EventResult =~ eventresult)
    | extend 
        severity = toint(Severity_s)
    | lookup SeverityLookup on severity
    | lookup ProtocolLookup on Protocol_s
    | extend
        EventCount = toint(1),
        EventProduct = "WAF",
        EventSchema = "NetworkSession",
        EventSchemaVersion = "0.2.6",
        EventType = "NetworkSession",
        EventVendor = "Barracuda"
    | extend
        Dvc = UnitName_s,
        DstIpAddr = DestinationIP_s,
        SrcIpAddr = SourceIP,
        DvcHostname = host_s,
        DvcIpAddr = HostIP_s,                            
        DstPortNumber = toint(DestinationPort_d),
        SrcPortNumber = toint(SourcePort_d),
        EventProductVersion = DeviceVersion_s,
        EventUid = _ItemId,
        EventStartTime = iff(isnotempty(TimeTaken_d), unixtime_milliseconds_todatetime(tolong(DeviceReceiptTime_s)-tolong(TimeTaken_d)), unixtime_milliseconds_todatetime(tolong(DeviceReceiptTime_s)))
    | extend
        IpAddr = SrcIpAddr,
        Src = SrcIpAddr,
        Dst = DstIpAddr,
        EventEndTime = EventStartTime
    | project-away
        *_d,
        *_s,
        _ResourceId,
        severity,
        RawData,
        Message,
        Computer,
        MG,
        ManagementGroupName,
        TenantId,
        SourceSystem,
        temp_SrcMatch,
        temp_DstMatch,
        SourceIP;
BarracudaCustom
};parser(
    starttime=starttime, 
    endtime=endtime, 
    srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, 
    dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, 
    ipaddr_has_any_prefix=ipaddr_has_any_prefix,
    dstportnumber=dstportnumber,
    hostname_has_any=hostname_has_any, 
    dvcaction=dvcaction,
    eventresult=eventresult, 
    disabled=disabled
)
}



//
// Function Name: vimNetworkSessionCheckPointFirewall
// Description: This ASIM parser supports normalizing Check Point VPN-1 & Firewall-1 logs coming from CEF Data Connector to the ASIM Network Session normalized schema.

// Version: 
// Last Updated: 
//
.create-or-alter function with (skipvalidation=true) vimNetworkSessionCheckPointFirewall(    ['starttime']:datetime=datetime(null),
    ['endtime']:datetime=datetime(null),
    ['srcipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['ipaddr_has_any_prefix']:dynamic=dynamic([]),
    ['dstportnumber']:int=int(null),
    ['hostname_has_any']:dynamic=dynamic([]),
    ['dvcaction']:dynamic=dynamic([]),
    ['eventresult']:string='*',
    ['disabled']:bool=false)
{
let ProtocolLookup=datatable(Protocol:string,NetworkProtocol:string)
    [
        "0","HOPOPT"
        , "1","ICMP"
        , "2","IGMP"
        , "3","GGP"
        , "4","IPv4"
        , "5","ST"
        , "6","TCP"
        , "7","CBT"
        , "8","EGP"
        , "9","IGP"
        , "10","BBN-RCC-MON"
        , "11","NVP-II"
        , "12","PUP"
        , "13","ARGUS (deprecated)"
        , "14","EMCON"
        , "15","XNET"
        , "16","CHAOS"
        , "17","UDP"
        , "18","MUX"
        , "19","DCN-MEAS"
        , "20","HMP"
        , "21","PRM"
        , "22","XNS-IDP"
        , "23","TRUNK-1"
        , "24","TRUNK-2"
        , "25","LEAF-1"
        , "26","LEAF-2"
        , "27","RDP"
        , "28","IRTP"
        , "29","ISO-TP4"
        , "30","NETBLT"
        , "31","MFE-NSP"
        , "32","MERIT-INP"
        , "33","DCCP"
        , "34","3PC"
        , "35","IDPR"
        , "36","XTP"
        , "37","DDP"
        , "38","IDPR-CMTP"
        , "39","TP++"
        , "40","IL"
        , "41","IPv6"
        , "42","SDRP"
        , "43","IPv6-Route"
        , "44","IPv6-Frag"
        , "45","IDRP"
        , "46","RSVP"
        , "47","GRE"
        , "48","DSR"
        , "49","BNA"
        , "50","ESP"
        , "51","AH"
        , "52","I-NLSP"
        , "53","SWIPE (deprecated)"
        , "54","NARP"
        , "55","MOBILE"
        , "56","TLSP"
        , "57","SKIP"
        , "58","IPv6-ICMP"
        , "59","IPv6-NoNxt"
        , "60","IPv6-Opts"
        , "61",""
        , "62","CFTP"
        , "63",""
        , "64","SAT-EXPAK"
        , "65","KRYPTOLAN"
        , "66","RVD"
        , "67","IPPC"
        , "68",""
        , "69","SAT-MON"
        , "70","VISA"
        , "71","IPCV"
        , "72","CPNX"
        , "73","CPHB"
        , "74","WSN"
        , "75","PVP"
        , "76","BR-SAT-MON"
        , "77","SUN-ND"
        , "78","WB-MON"
        , "79","WB-EXPAK"
        , "80","ISO-IP"
        , "81","VMTP"
        , "82","SECURE-VMTP"
        , "83","VINES"
        , "84","TTP"
        , "84","IPTM"
        , "85","NSFNET-IGP"
        , "86","DGP"
        , "87","TCF"
        , "88","EIGRP"
        , "89","OSPFIGP"
        , "90","Sprite-RPC"
        , "91","LARP"
        , "92","MTP"
        , "93","AX.25"
        , "94","IPIP"
        , "95","MICP (deprecated)"
        , "96","SCC-SP"
        , "97","ETHERIP"
        , "98","ENCAP"
        , "99",""
        , "100","GMTP"
        , "101","IFMP"
        , "102","PNNI"
        , "103","PIM"
        , "104","ARIS"
        , "105","SCPS"
        , "106","QNX"
        , "107","A/N"
        , "108","IPComp"
        , "109","SNP"
        , "110","Compaq-Peer"
        , "111","IPX-in-IP"
        , "112","VRRP"
        , "113","PGM"
        , "114",""
        , "115","L2TP"
        , "116","DDX"
        , "117","IATP"
        , "118","STP"
        , "119","SRP"
        , "120","UTI"
        , "121","SMP"
        , "122","SM (deprecated)"
        , "123","PTP"
        , "124","ISIS over IPv4"
        , "125","FIRE"
        , "126","CRTP"
        , "127","CRUDP"
        , "128","SSCOPMCE"
        , "129","IPLT"
        , "130","SPS"
        , "131","PIPE"
        , "132","SCTP"
        , "133","FC"
        , "134","RSVP-E2E-IGNORE"
        , "135","Mobility Header"
        , "136","UDPLite"
        , "137","MPLS-in-IP"
        , "138","manet"
        , "139","HIP"
        , "140","Shim6"
        , "141","WESP"
        , "142","ROHC"
        , "143","Ethernet"
        , "253",""
        , "254",""
        , "255","Reserved"];
    let DirectionLookup=datatable(conn_direction:string,NetworkDirection:string)
    [
        "Incoming","Inbound", 
        "Outgoing","Outbound", 
        "Internal","Local"];
    let ActionLookup=datatable(DeviceAction:string,DvcAction:string,EventResult:string,EventSeverity:string)
    [
        "Accept","Allow","Success","Informational",
        "Allow","Allow","Success","Informational",
        "Drop","Drop","Failure","Low",
        "Reject","Deny","Failure","Low",
        "Encrypt","Encrypt","Success","Informational",
        "Decrypt","Decrypt","Success","Informational",
        "Bypass","Allow","Success","Informational",
        "Block","Deny","Failure","Low",
        "","","NA","Informational"
     ];
      let NWParser=(
          starttime:datetime=datetime(null), 
          endtime:datetime=datetime(null),
          srcipaddr_has_any_prefix:dynamic=dynamic([]), 
          dstipaddr_has_any_prefix:dynamic=dynamic([]), 
          ipaddr_has_any_prefix:dynamic=dynamic([]),
          dstportnumber:int=int(null), 
          hostname_has_any:dynamic=dynamic([]), 
          dvcaction:dynamic=dynamic([]), 
          eventresult:string='*', 
          disabled:bool=false)
      {
      let src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
      let dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
      CommonSecurityLog
      | where not(disabled)
      | where
                      (isnull(starttime) or TimeGenerated >= starttime) 
                      and (isnull(endtime) or TimeGenerated <= endtime)
      | where 
                      array_length(hostname_has_any) == 0
      | where DeviceVendor=="Check Point" and DeviceProduct=="VPN-1 & FireWall-1"
      | where (isnull(dstportnumber) or (DestinationPort == dstportnumber))
      | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), 
               temp_isDstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
      | extend ASimMatchingIpAddr = case(
                          array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-", // match not requested
                          (temp_isSrcMatch and temp_isDstMatch), "Both", // has to be checked before the individual 
                          temp_isSrcMatch, "SrcIpAddr",
                          temp_isDstMatch, "DstIpAddr",
                          "No match"
                      )
      | where ASimMatchingIpAddr != "No match"
      | lookup ActionLookup on DeviceAction
      | where ((array_length(dvcaction) == 0) or DvcAction has_any (dvcaction))
      | where ((eventresult == "*") or (EventResult == eventresult))
      | lookup ProtocolLookup on Protocol
      | extend 
              EventProduct = "Firewall",
              EventCount = toint(1),
              EventType = "NetworkSession",
              EventSchema = "NetworkSession",
              EventSchemaVersion = "0.2.4"
      | parse-kv AdditionalExtensions as (
                  rule_uid:string,
                  loguid:string,
                  origin:string,
                  originsicname:string,
                  inzone:string,
                  outzone:string,
                  conn_direction:string,
                  alert:string,
                  inspection_category:string,
                  inspection_item:string
              ) with (pair_delimiter=';', kv_delimiter='=')
      | extend
              ThreatCategory = coalesce(alert, inspection_category),
              NetworkRuleName = coalesce(DeviceCustomString2, rule_uid, Activity),
              EventStartTime = TimeGenerated
      | parse originsicname with "CN\\=" DvcHostname "," *
      | project-rename
              Dvc = origin,                
              EventOriginalUid = loguid,
              ThreatName = inspection_item,
              EventVendor = DeviceVendor,
              DstPortNumber = DestinationPort,
              DstIpAddr = DestinationIP,
              SrcPortNumber = SourcePort,
              SrcIpAddr = SourceIP,
              DstNatIpAddr = DestinationTranslatedAddress,
              DstNatPortNumber = DestinationTranslatedPort,
              SrcNatIpAddr = SourceTranslatedAddress,
              SrcNatPortNumber = SourceTranslatedPort,
              EventProductVersion = DeviceVersion,
              EventOriginalSeverity = LogSeverity,
              Rule = NetworkRuleName,
              DvcOriginalAction = DeviceAction,
              DstAppName = Activity,
              EventMessage = Message
      | lookup DirectionLookup on conn_direction
      | extend 
              EventEndTime = EventStartTime,
              IpAddr = SrcIpAddr,
              Dst = DstIpAddr,
              Src = SrcIpAddr,
              NetworkDirection = case(
                                  isnotempty(NetworkDirection), NetworkDirection,
                                  inzone == "Internal" and (outzone == "Internal" or outzone == "Local"), "Local",
                                  (inzone == "Internal" or inzone == "Local") and outzone == "External", "Outbound",
                                  inzone == "External" and (outzone == "Internal" or outzone == "Local"), "Inbound",
                                  CommunicationDirection == "0", "Inbound",
                                  CommunicationDirection == "1", "Outbound",
                                  ""
                                  ),
              EventSeverity = iif(isnotempty(ThreatCategory),"High",EventSeverity),
              NetworkIcmpType = coalesce(
                                      tostring(column_ifexists("FieldDeviceCustomNumber2", long(null))),
                                      tostring(column_ifexists("DeviceCustomNumber2",long(null)))
                                      ),
              NetworkIcmpCode = coalesce(
                                      toint(column_ifexists("FieldDeviceCustomNumber3", long(null))),
                                      toint(column_ifexists("DeviceCustomNumber3",long(null)))
                                      )
      | project-away ApplicationProtocol, AdditionalExtensions, CommunicationDirection, Computer, Device*, Destination*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, Malicious*, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, ReceivedBytes, Remote*, ReportReferenceLink, Request*, Sent*, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity, rule_uid, originsicname, inzone, outzone, alert, conn_direction, inspection_category, temp_isDstMatch, temp_isSrcMatch, ExtID, EventOutcome, FieldDevice*, Reason
    };
    NWParser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
}



